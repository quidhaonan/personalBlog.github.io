<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Liu Mingyang's personal blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Java 高级部分</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="java-高级部分"><a href="#java-高级部分" class="headerlink" title="java 高级部分"></a><center>java 高级部分</center></h1><p>@[TOC]</p>
<h2 id="一-Java-GUI-入门"><a href="#一-Java-GUI-入门" class="headerlink" title="一 Java GUI 入门"></a>一 Java GUI 入门</h2><h3 id="1-基础概念"><a href="#1-基础概念" class="headerlink" title="1.基础概念"></a>1.基础概念</h3><ol>
<li>GUI ( graphics user interface )：图形界面用户接口，Java 用来做界面的一套 API ( application program interface )</li>
<li>程序界面有两种<ul>
<li>控制台程序：console()  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println();</span><br></pre></td></tr></table></figure></li>
<li>窗口界面<br>  <img src="https://img-blog.csdnimg.cn/422a7375952f4f1faa6cf7a5b5452e04.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ol>
<h3 id="2-窗口开发"><a href="#2-窗口开发" class="headerlink" title="2.窗口开发"></a>2.窗口开发</h3><ol>
<li>容器<br> <img src="https://img-blog.csdnimg.cn/9f17ab85dff04806b7dd1a0d40920c86.png" alt="在这里插入图片描述"></li>
<li>基本组件<br> <img src="https://img-blog.csdnimg.cn/86f2334650ce4f548902193961b49746.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="3-基本界面"><a href="#3-基本界面" class="headerlink" title="3.基本界面"></a>3.基本界面</h3><ol>
<li>做一个窗口<ul>
<li>编写一个类，找准一个父类 JFrame</li>
<li>编写一个构造方法，设置一些属性  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wnd1</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	<span class="type">JLabel</span> <span class="variable">lblAccount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;账号：&quot;</span>);</span><br><span class="line">  		<span class="type">JTextField</span> <span class="variable">jtfAccount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">25</span>);</span><br><span class="line">  		<span class="type">JLabel</span> <span class="variable">lblPwd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;密码：&quot;</span>);</span><br><span class="line">  		<span class="type">JPasswordField</span> <span class="variable">jtfPwd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPasswordField</span>(<span class="number">25</span>);</span><br><span class="line">  		<span class="type">JButton</span> <span class="variable">btnLogin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;登录&quot;</span>);</span><br><span class="line">  		<span class="type">JButton</span> <span class="variable">btnCalcel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;取消&quot;</span>);</span><br><span class="line">  		<span class="comment">/*</span></span><br><span class="line"><span class="comment">  		JButton jb1 = new JButton(&quot;东&quot;);</span></span><br><span class="line"><span class="comment">  		JButton jb2 = new JButton(&quot;南&quot;);</span></span><br><span class="line"><span class="comment">  		JButton jb3 = new JButton(&quot;西&quot;);</span></span><br><span class="line"><span class="comment">  		JButton jb4 = new JButton(&quot;北&quot;);</span></span><br><span class="line"><span class="comment">  		JButton jb5 = new JButton(&quot;中&quot;);*/</span></span><br><span class="line">  		<span class="type">JPanel</span> <span class="variable">jp1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">  		<span class="type">JPanel</span> <span class="variable">jp2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">  		<span class="type">JPanel</span> <span class="variable">jp4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">  		<span class="type">JPanel</span> <span class="variable">jp3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Wnd1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//设置窗口的一些特性:</span></span><br><span class="line">     			<span class="comment">//1、设置大小</span></span><br><span class="line">      		<span class="built_in">this</span>.setSize(<span class="number">400</span>,<span class="number">300</span>);</span><br><span class="line">      		</span><br><span class="line">     		 	<span class="comment">//2、设置标题</span></span><br><span class="line">      		<span class="built_in">this</span>.setTitle(<span class="string">&quot;QQ登录&quot;</span>);</span><br><span class="line">      		</span><br><span class="line">     		 	<span class="comment">//3、设置可见</span></span><br><span class="line">     		 	<span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">     		 	</span><br><span class="line">      		<span class="comment">//4、设置可以被关闭</span></span><br><span class="line">      		<span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">      		</span><br><span class="line">     		 	<span class="comment">//5、设置窗口的位置,相对桌面居中</span></span><br><span class="line">     		 	<span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">     		 	</span><br><span class="line">      		<span class="comment">//6、设置不能改变大小</span></span><br><span class="line">      		<span class="built_in">this</span>.setResizable(<span class="literal">false</span>);</span><br><span class="line">      		</span><br><span class="line">      		<span class="comment">//放入我们的组件</span></span><br><span class="line">      		initComponent();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *初始化各个组件</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initComponent</span><span class="params">()</span>&#123;</span><br><span class="line">     			jp1.add(lblAccount);</span><br><span class="line">     			jp1.add(jtfAccount);</span><br><span class="line">     			jp2.add(lblPwd);</span><br><span class="line">      		jp2.add(jtfPwd);</span><br><span class="line">      		jp4.add(btnLogin);</span><br><span class="line">      		jp4.add(btnCalcel);</span><br><span class="line">      		jp3.add(jp1);</span><br><span class="line">      		jp3.add(jp2);</span><br><span class="line">      		jp3.add(jp4);</span><br><span class="line">      		</span><br><span class="line">      		<span class="comment">// 将jp3放在窗口的中间.</span></span><br><span class="line">      		<span class="built_in">this</span>.add(jp3, <span class="string">&quot;Center&quot;</span>);</span><br><span class="line">      		</span><br><span class="line">      		<span class="comment">// 事件处理者</span></span><br><span class="line">      		<span class="type">MyHandler</span> <span class="variable">myHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyHandler</span>();</span><br><span class="line">      		<span class="comment">// 将事件源和事件处理者关联</span></span><br><span class="line">      		btnLogin.addActionListener(myHandler);</span><br><span class="line">      		</span><br><span class="line">      		<span class="comment">// 将组件放入窗口受布局的影响，我们JFrame的默认布局是边框布局。</span></span><br><span class="line">     			<span class="comment">/*this.add(jb5,&quot;Center&quot;);</span></span><br><span class="line"><span class="comment">     			this.add(jb1, &quot;East&quot;);</span></span><br><span class="line"><span class="comment">    			this.add(jb2, &quot;South&quot;);</span></span><br><span class="line"><span class="comment">     			this.add(jb3,&quot;West&quot;);</span></span><br><span class="line"><span class="comment">     			this.add(jb4,&quot;North&quot;);*/</span></span><br><span class="line">  		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">   		 *事件处理者</span></span><br><span class="line"><span class="comment">  		 *ActionListener:按钮的点击事件接口</span></span><br><span class="line"><span class="comment">   		*/</span></span><br><span class="line">   		<span class="keyword">class</span> <span class="title class_">MyHandler</span> <span class="keyword">implements</span> <span class="title class_">ActionListener</span> &#123;</span><br><span class="line">      		<span class="meta">@Override</span></span><br><span class="line">      		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">          		<span class="comment">// 获取账号，密码信息</span></span><br><span class="line">          		<span class="type">String</span> <span class="variable">account</span> <span class="operator">=</span> Wnd1.<span class="built_in">this</span>.jtfAccount.getText();</span><br><span class="line">          		<span class="type">String</span> <span class="variable">pwd</span> <span class="operator">=</span> jtfPwd.getText();</span><br><span class="line">          		</span><br><span class="line">          		<span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(account) &amp;&amp; <span class="string">&quot;123&quot;</span>.equals(pwd))&#123;</span><br><span class="line">              		System.out.println(<span class="string">&quot;登录成功!&quot;</span>);</span><br><span class="line">              		<span class="type">Wnd2</span> <span class="variable">wnd2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Wnd2</span>();</span><br><span class="line">              		<span class="comment">// 释放窗口</span></span><br><span class="line">              		dispose();</span><br><span class="line">          		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              		System.out.println(<span class="string">&quot;账号或密码错误！&quot;</span>);</span><br><span class="line">              		</span><br><span class="line">              		<span class="comment">// null:表示是这个消息框的父窗口</span></span><br><span class="line">              		JOptionPane.showMessageDialog(Wnd1.<span class="built_in">this</span>,<span class="string">&quot;账号或密码错误！&quot;</span>);</span><br><span class="line">          		&#125;</span><br><span class="line">      		&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      		<span class="keyword">new</span> <span class="title class_">Wnd1</span>();</span><br><span class="line">  		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Wnd2</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Wnd2</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.setSize(<span class="number">800</span>,<span class="number">400</span>);</span><br><span class="line">		<span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>开发组件<br> <img src="https://img-blog.csdnimg.cn/2d208ef1401b47f19c7d469a66a2701b.png" alt="在这里插入图片描述"><ul>
<li>登录界面开发<br>  <img src="https://img-blog.csdnimg.cn/44e1ec5e56b94c1f9639e42250af375a.png" alt="在这里插入图片描述"></li>
<li>组件布局<ul>
<li>边框布局 BorderLayout<br>  <img src="https://img-blog.csdnimg.cn/09494484fc9c45a1b068511acfdae0bf.png" alt="在这里插入图片描述"></li>
<li>流水布局 FlowLayout，从左往右，从上往下的布局<br>  JPanel：默认是流水布局的<br>  <img src="https://img-blog.csdnimg.cn/62140a73856a4aa0a4823c668c9a5f19.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
</li>
<li>事件处理<ul>
<li>点击按钮，需要有所反应</li>
</ul>
</li>
<li>观察者模式<ul>
<li>事件源：发生事件的对象</li>
<li>事件处理者：实现了 ActionListener 接口的类的对象</li>
<li>事件源.addActionListener(事件处理者)</li>
</ul>
</li>
</ol>
<h3 id="4-Swing-高级组件"><a href="#4-Swing-高级组件" class="headerlink" title="4.Swing 高级组件"></a>4.Swing 高级组件</h3><ol>
<li>表格组件<ul>
<li>JTable</li>
</ul>
</li>
<li>构造方法<br> <img src="https://img-blog.csdnimg.cn/b4a93646c5404ea7a4cdf4544c740869.png" alt="在这里插入图片描述"> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构造一个指定行和列的空表格</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JTable(<span class="type">int</span>,<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 第一个参数为 Object 类型的二维数组，第一维表示行，第二维表示</span></span><br><span class="line"><span class="comment"> * 每行的具体数据</span></span><br><span class="line"><span class="comment"> * 第二个参数为 Object 类型的一维数组，表示每列的列表名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JTable(Object[][],Object[])</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用模型来构造表格，TableModel 是一个接口，我们可以</span></span><br><span class="line"><span class="comment"> * 自己写一个类实现这个接口，从而完成模型的功能</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * Java 也帮我们提供了一个默认的表模型，DefaultTableModel</span></span><br><span class="line"><span class="comment"> * DefaultTableModel mdl=new DefaultTableModel(vRows,vColums);</span></span><br><span class="line"><span class="comment"> * JTable myTable=new JTable(mdl);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JTable(TableModel model)</span><br></pre></td></tr></table></figure></li>
<li>新增行 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">addRow</span><span class="params">(Object[] rowData)</span>	<span class="comment">// 在模型的末尾添加一行</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">addRow</span><span class="params">(Vector rowData)</span>		<span class="comment">// 在模型的末尾添加一行</span></span><br></pre></td></tr></table></figure></li>
<li>删除行 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">removeRow</span><span class="params">(<span class="type">int</span> row)</span>		<span class="comment">// 从模型中删除 row 的行</span></span><br></pre></td></tr></table></figure></li>
<li>代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTableDemo1</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	JTable myTable;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">JTableDemo1</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.setSize(<span class="number">500</span>,<span class="number">400</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setTitle(<span class="string">&quot;我的数据表&quot;</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">       	<span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">       	initComponent();</span><br><span class="line">       	<span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initComponent</span><span class="params">()</span>&#123;</span><br><span class="line">       	Object[] columns = &#123;</span><br><span class="line">               	<span class="string">&quot;编号&quot;</span>,</span><br><span class="line">               	<span class="string">&quot;姓名&quot;</span>,</span><br><span class="line">               	<span class="string">&quot;性别&quot;</span>,</span><br><span class="line">               	<span class="string">&quot;职位&quot;</span></span><br><span class="line">       	&#125;;</span><br><span class="line">       	Object[][] rowData = &#123;</span><br><span class="line">               	&#123;<span class="number">1</span>,<span class="string">&quot;张飞&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;打手&quot;</span>&#125;,</span><br><span class="line">               	&#123;<span class="number">2</span>,<span class="string">&quot;关羽&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;打手&quot;</span>&#125;,</span><br><span class="line">               	&#123;<span class="number">3</span>,<span class="string">&quot;孔明&quot;</span>,<span class="string">&quot;男&quot;</span>,<span class="string">&quot;军事&quot;</span>&#125;,</span><br><span class="line">               	&#123;<span class="number">4</span>,<span class="string">&quot;小乔&quot;</span>,<span class="string">&quot;女&quot;</span>,<span class="string">&quot;小三&quot;</span>&#125;,</span><br><span class="line">       	&#125;;</span><br><span class="line">       	</span><br><span class="line">       	<span class="comment">// 将表格放入窗口中</span></span><br><span class="line">       	myTable = <span class="keyword">new</span> <span class="title class_">JTable</span>(rowData, columns);</span><br><span class="line">       	<span class="comment">// 设置单元格的高</span></span><br><span class="line">       	myTable.setRowHeight(<span class="number">30</span>);</span><br><span class="line">       	<span class="comment">// 将表格放入一个滚动界面中</span></span><br><span class="line">       	<span class="built_in">this</span>.add(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(myTable));</span><br><span class="line">   	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">JTableDemo1</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTableDemo2</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	JTable myTable;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">JTableDemo2</span><span class="params">()</span>&#123;</span><br><span class="line">       	<span class="built_in">this</span>.setSize(<span class="number">500</span>,<span class="number">400</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setTitle(<span class="string">&quot;我的数据表&quot;</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">       	<span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">       	initComponent();</span><br><span class="line">       	<span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initComponent</span><span class="params">()</span>&#123;</span><br><span class="line">       	<span class="comment">// 表示是列名称</span></span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">vColumns</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	vColumns.add(<span class="string">&quot;编号&quot;</span>);</span><br><span class="line">       	vColumns.add(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">       	vColumns.add(<span class="string">&quot;性别&quot;</span>);</span><br><span class="line">       	vColumns.add(<span class="string">&quot;职位&quot;</span>);</span><br><span class="line">       	</span><br><span class="line">       	<span class="comment">//表示行的数据</span></span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">vRows</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v1.add(<span class="number">1</span>);</span><br><span class="line">       	v1.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v1.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v1.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v1);</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v2.add(<span class="number">2</span>);</span><br><span class="line">       	v2.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v2.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v2.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v2);</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v3.add(<span class="number">3</span>);</span><br><span class="line">       	v3.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v3.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v3.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v3);</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v4.add(<span class="number">4</span>);</span><br><span class="line">       	v4.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v4.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v4.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v4);</span><br><span class="line">       	</span><br><span class="line">       	<span class="comment">// 不加入这个模型的话，后续进行增删改有问题</span></span><br><span class="line">       	<span class="type">DefaultTableModel</span> <span class="variable">mdl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTableModel</span>(vRows, vColumns);</span><br><span class="line">       	<span class="comment">// 将表格放入窗口中</span></span><br><span class="line">       	myTable = <span class="keyword">new</span> <span class="title class_">JTable</span>(mdl);</span><br><span class="line">       	<span class="comment">// 设置单元格的高</span></span><br><span class="line">       	myTable.setRowHeight(<span class="number">30</span>);</span><br><span class="line">       	<span class="comment">// 将表格放入一个滚动界面中</span></span><br><span class="line">       	<span class="built_in">this</span>.add(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(myTable));</span><br><span class="line">   	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="keyword">new</span> <span class="title class_">JTableDemo2</span>();</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JTableDemo3</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	JTable myTable;</span><br><span class="line">	<span class="type">JButton</span> <span class="variable">btnAdd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;新增&quot;</span>);</span><br><span class="line">   	<span class="type">JButton</span> <span class="variable">btnDel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;删除&quot;</span>);</span><br><span class="line">   	<span class="type">JPanel</span> <span class="variable">pnl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">   	<span class="keyword">private</span> DefaultTableModel mdl;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">JTableDemo3</span><span class="params">()</span>&#123;</span><br><span class="line">       	<span class="built_in">this</span>.setSize(<span class="number">500</span>,<span class="number">400</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setTitle(<span class="string">&quot;我的数据表&quot;</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">       	<span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">       	initComponent();</span><br><span class="line">       	<span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initComponent</span><span class="params">()</span>&#123;</span><br><span class="line">       	pnl.add(btnAdd);</span><br><span class="line">       	pnl.add(btnDel);</span><br><span class="line">       	<span class="built_in">this</span>.add(pnl,<span class="string">&quot;South&quot;</span>);</span><br><span class="line">       	</span><br><span class="line">       	btnAdd.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">           	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">               	<span class="type">AddEmpFrame</span> <span class="variable">addEmpFrame</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddEmpFrame</span>(mdl);</span><br><span class="line">           	&#125;</span><br><span class="line">       	&#125;);</span><br><span class="line">       	btnDel.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">           	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">           		<span class="comment">// 点击是：0，否：1，取消：2，×：-1</span></span><br><span class="line">               	<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> JOptionPane.showConfirmDialog(<span class="literal">null</span>, <span class="string">&quot;确认删除吗?&quot;</span>);</span><br><span class="line">               	<span class="keyword">if</span>(i==<span class="number">0</span>)&#123;</span><br><span class="line">                   	<span class="comment">// 获取表格的选中的行</span></span><br><span class="line">                   	<span class="type">int</span> <span class="variable">selectedRow</span> <span class="operator">=</span> myTable.getSelectedRow();</span><br><span class="line">                   	<span class="keyword">if</span>(selectedRow==-<span class="number">1</span>)&#123;</span><br><span class="line">                       	JOptionPane.showMessageDialog(<span class="literal">null</span>,<span class="string">&quot;没有选中任何行!&quot;</span>);</span><br><span class="line">                       	<span class="keyword">return</span>;</span><br><span class="line">                   	&#125;</span><br><span class="line">                   	mdl.removeRow(selectedRow);</span><br><span class="line">               	&#125;</span><br><span class="line">           	&#125;</span><br><span class="line">       	&#125;);</span><br><span class="line"></span><br><span class="line">       	<span class="comment">//表示是列名称</span></span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">vColumns</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	vColumns.add(<span class="string">&quot;编号&quot;</span>);</span><br><span class="line">       	vColumns.add(<span class="string">&quot;姓名&quot;</span>);</span><br><span class="line">       	vColumns.add(<span class="string">&quot;性别&quot;</span>);</span><br><span class="line">       	vColumns.add(<span class="string">&quot;职位&quot;</span>);</span><br><span class="line">       	</span><br><span class="line">       	<span class="comment">//表示行的数据</span></span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">vRows</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v1.add(<span class="number">1</span>);</span><br><span class="line">       	v1.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v1.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v1.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v1);</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v2.add(<span class="number">2</span>);</span><br><span class="line">       	v2.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v2.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v2.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v2);</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v3.add(<span class="number">3</span>);</span><br><span class="line">       	v3.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v3.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v3.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v3);</span><br><span class="line">       	<span class="type">Vector</span> <span class="variable">v4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">       	v4.add(<span class="number">4</span>);</span><br><span class="line">       	v4.add(<span class="string">&quot;张飞&quot;</span>);</span><br><span class="line">       	v4.add(<span class="string">&quot;男&quot;</span>);</span><br><span class="line">       	v4.add(<span class="string">&quot;打手&quot;</span>);</span><br><span class="line">       	vRows.add(v4);</span><br><span class="line">       	</span><br><span class="line">       	<span class="comment">// 不加入这个模型的话，后续进行增删改有问题</span></span><br><span class="line">       	mdl = <span class="keyword">new</span> <span class="title class_">DefaultTableModel</span>(vRows, vColumns);</span><br><span class="line">       	<span class="comment">// 将表格放入窗口中</span></span><br><span class="line">       	myTable = <span class="keyword">new</span> <span class="title class_">JTable</span>(mdl);</span><br><span class="line">       	<span class="comment">// 设置单元格的高</span></span><br><span class="line">       	myTable.setRowHeight(<span class="number">30</span>);</span><br><span class="line">       	<span class="comment">// 将表格放入一个滚动界面中</span></span><br><span class="line">       	<span class="built_in">this</span>.add(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(myTable));</span><br><span class="line">   	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">       	<span class="keyword">new</span> <span class="title class_">JTableDemo3</span>();</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddEmpFrame</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span>&#123;</span><br><span class="line">	DefaultTableModel mdl;</span><br><span class="line">   	<span class="type">JLabel</span> <span class="variable">lbl1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;编号:&quot;</span>);</span><br><span class="line">   	<span class="type">JLabel</span> <span class="variable">lbl2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;姓名:&quot;</span>);</span><br><span class="line">   	<span class="type">JLabel</span> <span class="variable">lbl3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;性别:&quot;</span>);</span><br><span class="line">   	<span class="type">JLabel</span> <span class="variable">lbl4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;职业:&quot;</span>);</span><br><span class="line">   	<span class="type">JTextField</span> <span class="variable">jtf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">25</span>);</span><br><span class="line">   	<span class="type">JTextField</span> <span class="variable">jtf2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">25</span>);</span><br><span class="line">   	<span class="type">JTextField</span> <span class="variable">jtf3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">25</span>);</span><br><span class="line">   	<span class="type">JTextField</span> <span class="variable">jtf4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">25</span>);</span><br><span class="line">   	<span class="type">JButton</span> <span class="variable">btnSave</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;保存&quot;</span>);</span><br><span class="line">   	<span class="type">JButton</span> <span class="variable">btnClose</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;关闭&quot;</span>);</span><br><span class="line">   	<span class="type">JPanel</span> <span class="variable">pn1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">   	<span class="type">JPanel</span> <span class="variable">pn2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">   	<span class="type">JPanel</span> <span class="variable">pn3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">   	<span class="type">JPanel</span> <span class="variable">pn4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">   	<span class="type">JPanel</span> <span class="variable">pn5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">   	<span class="type">JPanel</span> <span class="variable">pn6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>  <span class="title function_">AddEmpFrame</span><span class="params">(DefaultTableModel mdl)</span>&#123;</span><br><span class="line">       	<span class="built_in">this</span>.mdl = mdl;</span><br><span class="line">       	<span class="built_in">this</span>.setSize(<span class="number">400</span>,<span class="number">500</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setTitle(<span class="string">&quot;新增员工&quot;</span>);</span><br><span class="line">       	<span class="built_in">this</span>.initComponent();</span><br><span class="line">       	<span class="built_in">this</span>.setResizable(<span class="literal">false</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setLocationRelativeTo(<span class="literal">null</span>);</span><br><span class="line">       	<span class="built_in">this</span>.setVisible(<span class="literal">true</span>);</span><br><span class="line">   	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initComponent</span><span class="params">()</span>&#123;</span><br><span class="line">       	pn1.add(lbl1);</span><br><span class="line">       	pn1.add(jtf1);</span><br><span class="line">       	pn2.add(lbl2);</span><br><span class="line">       	pn2.add(jtf2);</span><br><span class="line">       	pn3.add(lbl3);</span><br><span class="line">       	pn3.add(jtf3);</span><br><span class="line">       	pn4.add(lbl4);</span><br><span class="line">       	pn4.add(jtf4);</span><br><span class="line">       	pn5.add(btnSave);</span><br><span class="line">       	pn5.add(btnClose);</span><br><span class="line">       	pn6.add(pn1);</span><br><span class="line">       	pn6.add(pn2);</span><br><span class="line">       	pn6.add(pn3);</span><br><span class="line">       	pn6.add(pn4);</span><br><span class="line">       	pn6.add(pn5);</span><br><span class="line">       	<span class="built_in">this</span>.add(pn6);</span><br><span class="line">       	</span><br><span class="line">       	btnSave.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">           	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">               	<span class="type">Vector</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Vector</span>();</span><br><span class="line">               	v.add(jtf1.getText());</span><br><span class="line">               	v.add(jtf2.getText());</span><br><span class="line">               	v.add(jtf3.getText());</span><br><span class="line">               	v.add(jtf4.getText());</span><br><span class="line">               	mdl.addRow(v);</span><br><span class="line">           	&#125;</span><br><span class="line">       	&#125;);</span><br><span class="line">       	btnClose.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>() &#123;</span><br><span class="line">           	<span class="meta">@Override</span></span><br><span class="line">           	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span> &#123;</span><br><span class="line">               	dispose();</span><br><span class="line">           	&#125;</span><br><span class="line">       	&#125;);</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-Swing-图形绘制"><a href="#5-Swing-图形绘制" class="headerlink" title="5.Swing 图形绘制"></a>5.Swing 图形绘制</h3><ol>
<li>核心对象 Graphics<ul>
<li>Graphics：当成一只笔<ul>
<li>public abstract class Graphics extends Object{ &#x2F;&#x2F; 代码体 }</li>
<li>Graphics 类是所有图形上下文的抽象基类，允许应用程序可以在组件（已知在各种设备上实现），以及闭屏图像上，进行绘制</li>
<li>Graphics 对象封装了 Java 支持的基本呈现操作所需的状态信息</li>
</ul>
</li>
<li>对象的获取<ul>
<li>Graphics g&#x3D;this.getGraphics();</li>
<li>利用这个对象可以在窗口中，按钮上进行绘图</li>
</ul>
</li>
</ul>
</li>
<li>重绘<ul>
<li>当窗口发生改变以后，窗口会被重绘，只会重绘自己的一些窗口特征，而我们自己绘制的内容没有被重绘的，我们需要重写 paint() 方法，在这个方法中重绘  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@OVerride</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">paint</span><span class="params">(Graphics g)</span>&#123;</span><br><span class="line">	<span class="built_in">super</span>.paint(g);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 绘制你自己的图形</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;lines.size()&#123;</span><br><span class="line">		Line line=(Line) lines.get(i);</span><br><span class="line">		g.drawLine(line.x1,line.y1,line.x2,line.y2);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>绘图操作 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Toolkit：工具包</span></span><br><span class="line"><span class="comment"> * Toolkit.getDefaultToolkit()：获取默认工具包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Image img=Toolkit.getDefaultToolkit().getImage(<span class="string">&quot;pName.png&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="二-Java-常用类"><a href="#二-Java-常用类" class="headerlink" title="二 Java 常用类"></a>二 Java 常用类</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/yuwtJBdGcE6">JAVA_API_CN.exe</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/kTMTY5B9uUU">JavaAPI 学习(java.lang).pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/iw3guHJkYSp">java笔记.txt</a></td>
</tr>
</tbody></table>
<h3 id="1-Object"><a href="#1-Object" class="headerlink" title="1.Object"></a>1.Object</h3><h3 id="2-包装类"><a href="#2-包装类" class="headerlink" title="2.包装类"></a>2.包装类</h3><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_18505715/article/details/73824325">基本数据类型、包装类型和 String 间的转换</a></td>
</tr>
</tbody></table>
<p><img src="https://img-blog.csdnimg.cn/2625d89136654ff8ac3f44322291b2c8.png" alt="在这里插入图片描述"></p>
<ol>
<li>包装类<ul>
<li>对于基本数据类型的封装，封装称为了对象，方便操作</li>
</ul>
</li>
<li>字符串 –&gt; 基本数据类型、包装类<ul>
<li>Integer 包装类的 public static int parseInt(String s)：可以将由“数字”字符组成的字符串转换为整型</li>
<li>类似地，使用 java.lang 包中的 Byte、Short、Long、Float、Double 类调用相应的类方法可以将由“数字”字符组成的字符串，转化为相应的基本数据类型</li>
</ul>
</li>
<li>基本数据类型、包装类 –&gt; 字符串<ul>
<li>调用 String 类的 public static String valueOf(int a n) 可将 int 型转换为字符串</li>
<li>相应的 valueOf(byte b)、valueOf(long l)、valueOf(float f)、valueOf(double d)、valueOf(boolean b) 可由参数的相应类型到字符串的转换</li>
</ul>
</li>
<li>字符数组 –&gt; 字符串<ul>
<li>String 类的构造器：String(char[] c) 和 String(char[] c,int offset,int length) 分别用字符数组中的全部字符和部分字符创建字符串对象</li>
</ul>
</li>
<li>字符串 –&gt; 字符数组<ul>
<li>public char[] toCharArray()：将字符串中的全部字符存放在一个字符数组中的方法</li>
<li>public void getChars(int srcBegin,int srcEnd,char[] dst,int dstBegin)：提供了将指定索引范围内的字符串存放到数组中的方法</li>
</ul>
</li>
<li>字节数组 –&gt; 字符串<ul>
<li>String(byte[] b)：通过使用平台的默认字符集解码指定的 byte 数组，构造一个新的字符串</li>
<li>String(byte[] b,int offset,int length)：用指定的字节数组的一部分，即从数组起始位置 offset 开始取 length 个字节构造一个字符串对象</li>
</ul>
</li>
<li>字符串 –&gt; 字节数组<ul>
<li>public byte[] getBytes()：使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中</li>
<li>public byte[] getBytes(String charsetName)：使用指定的字符集将此 String 编码到byte 序列，并将结果存储到新的 byte 数组</li>
</ul>
</li>
</ol>
<h3 id="3-String-类"><a href="#3-String-类" class="headerlink" title="3.String 类"></a>3.String 类</h3><ol>
<li><p>字符串的本质是字符数组，具有不可变性</p>
</li>
<li><p>字符串的构造</p>
<ul>
<li>String(byte[] bytes)：构造一个新的 String，方法是使用平台的默认字符集解码字节的指定数组</li>
<li>String(byte[] bytes,String charsetName)：构造一个新的 String，方法是使用指定的字符集解码指定的字节数组</li>
<li>适合于在各种编码中进行转换</li>
</ul>
</li>
<li><p>String 的常用 API</p>
<table>
<thead>
<tr>
<th>方法原型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean equalsIgnoreCase(String anotherString)</td>
<td>判断字符串 anotherString 是否与当前字符串相等，忽略大小写模式</td>
</tr>
<tr>
<td>int compareTo(String anotherString</td>
<td>根据 ASCII 码比较字符串 anotherString 和当前字符串的大小，比较方式类似于 c 语言中的 strcmp 函数</td>
</tr>
<tr>
<td>boolean startsWith(String prefix)</td>
<td>判断当前字符串是否以字符串 prefix 为开头</td>
</tr>
<tr>
<td>boolean endsWith(String suffix)</td>
<td>判断当前字符串是否以字符串 suffix 为后缀</td>
</tr>
<tr>
<td>int indexOf(int ch)</td>
<td>搜索字符 ch 在当前字符串中第一次出现的索引，没有出现则返回 -1</td>
</tr>
<tr>
<td>int indexOf(String str)</td>
<td>搜索字符串 str 在当前字符串中第一次出现的索引，没有出现则返回 -1</td>
</tr>
<tr>
<td>int lastIndexOf(int ch)</td>
<td>搜索字符 ch 在当前字符串中最后一次出现的索引，没有出现则返回 -1</td>
</tr>
<tr>
<td>int lastIndexOf(String str)</td>
<td>搜索字符串 str 在当前字符串中最后一次出现的索引，没有出现则返回 -1</td>
</tr>
<tr>
<td>char cahrAt(int index)</td>
<td>用于从指定位置提取单个字符，该位置由 index 指定，索引值必须为非负数</td>
</tr>
<tr>
<td>String substring(in index)</td>
<td>用于提取从 index 指定的位置开始的字符串部分</td>
</tr>
<tr>
<td>String substring(int begin,int end)</td>
<td>用于提取 begin 和 end 位置之间的字符串部分</td>
</tr>
<tr>
<td>String concat(String str)</td>
<td>用于连接两个字符串，并新建一个包含调用字符串的字符串对象</td>
</tr>
<tr>
<td>String replace(char oldChar,char newChar)</td>
<td>用于将调用字符串中出现的 oldChar 指定的字符全部替换为 newChar 指定的字符</td>
</tr>
<tr>
<td>replaceAll(String regex,String replacement)</td>
<td>用于将调用字符串中出现或者匹配 regex 的字符串全部都替换为 replacement 指定的字符</td>
</tr>
<tr>
<td>String trim()</td>
<td>用于返回一个前后不含任何空格的调用字符串的副本</td>
</tr>
</tbody></table>
</li>
<li><p>正则表达式(用于验证指定字符串是否合法的一个模板)</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// s：你要验证的字符串，表达式：（匹配公式）</span></span><br><span class="line"><span class="type">boolean</span> bFlag=s.matches(表达式);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>单个字符</p>
<table>
<thead>
<tr>
<th>标识符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>某个单词(例如：1)</td>
<td>直接匹配</td>
</tr>
<tr>
<td>.</td>
<td>匹配任意的字符</td>
</tr>
<tr>
<td>[0-9]</td>
<td>数组1-9，在里面时</td>
</tr>
<tr>
<td>^表达式</td>
<td>必须以表达式的规则为开头</td>
</tr>
<tr>
<td>表达式$</td>
<td>必须以表达式的规则为结尾</td>
</tr>
</tbody></table>
</li>
<li><p>字符个数</p>
<table>
<thead>
<tr>
<th>标识符</th>
<th>次数</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0次或者多次</td>
</tr>
<tr>
<td>+</td>
<td>1次或者多次</td>
</tr>
<tr>
<td>？</td>
<td>0次或者1次</td>
</tr>
<tr>
<td>{n}</td>
<td>恰好 n 次</td>
</tr>
<tr>
<td>{n, }</td>
<td>n 次到无限</td>
</tr>
<tr>
<td>{n,m}</td>
<td>从 n 次到 m 次</td>
</tr>
</tbody></table>
</li>
<li><p>快捷符号</p>
<table>
<thead>
<tr>
<th>标识符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>\d</td>
<td>表示 [0-9]</td>
</tr>
<tr>
<td>\D</td>
<td>表示 [^ 0-9]</td>
</tr>
<tr>
<td>\w</td>
<td>表示 [0-9A-Z_a-z]</td>
</tr>
<tr>
<td>\W</td>
<td>表示[^0-9A-Z_a-z]</td>
</tr>
<tr>
<td>\s</td>
<td>表示 [\t \n \r]</td>
</tr>
<tr>
<td>\S</td>
<td>表示 [^ \t \n \r \f]</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>正则表达式作用</p>
<ul>
<li>用于验证手机号码、邮箱、生日等</li>
<li>过滤<ul>
<li>replaceAll()</li>
</ul>
</li>
<li>拆分<ul>
<li>split()</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="4-StringBuffer-与-StringBuilder"><a href="#4-StringBuffer-与-StringBuilder" class="headerlink" title="4.StringBuffer 与 StringBuilder"></a>4.StringBuffer 与 StringBuilder</h3><ol>
<li>可变字符串，当大量的对于字符串做操作，可以使用</li>
<li>代表可变的字符序列，JDK1.0 中声明，可以对字符串内容进行增删，此时不会产生新的对象</li>
<li>作为参数传递时，方法内部可以改变值</li>
<li>StringBuffer 类不同于 String ，其对象必须使用构造器生成<ul>
<li>StringBuffer()：初始容量为 16 的字符串缓冲区</li>
<li>StringBuffer(int size)：构造指定容量的字符串缓冲区</li>
<li>StringBuffer(String str)：将内容初始化为指定字符串内容</li>
</ul>
</li>
<li>StringBuffer 类的常用方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当 append 和 insert 时，如果原来 value 数组长度不够，可扩容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">StringBuffer <span class="title function_">append</span><span class="params">(xxx)</span>;	<span class="comment">// 提供了很多的 append() 方法，用于进行字符串拼接</span></span><br><span class="line">StringBuffer <span class="title function_">insert</span><span class="params">(<span class="type">int</span> offset,xxx)</span>;	<span class="comment">// 在指定位置插入 xxx</span></span><br><span class="line">StringBuffer <span class="title function_">delete</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>;	<span class="comment">// 删除指定位置的内容</span></span><br><span class="line">StringBuffer <span class="title function_">replace</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end,String str)</span>;	<span class="comment">// 把 [start,end) 位置替换成 str</span></span><br><span class="line">StringBuffer <span class="title function_">reverse</span><span class="params">()</span>;	<span class="comment">// 把当前字符串序列逆转</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">indexOf</span><span class="params">(String str)</span>;</span><br><span class="line"><span class="type">char</span> <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> n)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setCharAt</span><span class="params">(<span class="type">int</span> n,<span class="type">char</span> ch)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">()</span>;</span><br><span class="line">String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span>;</span><br></pre></td></tr></table></figure></li>
<li>StringBuilder 类<ul>
<li>StringBuilder 和 StringBuffer 非常相似，均代表可变的字符序列，而且提供相关功能的方法也一样</li>
</ul>
</li>
<li>面试题：对比 String、StringBuffer、StringBuilder<ul>
<li>String(JDK1.0)：不可变字符序列</li>
<li>StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全</li>
<li>StringBuilder(JDK5.0)：可变字符序列、效率高、线程不安全</li>
</ul>
</li>
<li>注意：作为参数传递的话，方法内部 String 不会改变其值，StringBuffer 和 StringBuilder 会改变其值</li>
</ol>
<h3 id="5-Math-类"><a href="#5-Math-类" class="headerlink" title="5.Math 类"></a>5.Math 类</h3><ol>
<li>里面都是静态常量和静态方法：用于对数学做一些计算用</li>
<li>一些常用方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">ceil</span><span class="params">(<span class="type">double</span> a)</span>&#123;  <span class="comment">// 代码体 &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">floor</span><span class="params">(<span class="type">double</span> a)</span>&#123;  <span class="comment">// 代码体 &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">round</span><span class="params">(<span class="type">float</span> a)</span>&#123;  <span class="comment">// 代码体 &#125;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">round</span><span class="params">(<span class="type">double</span> a)</span>&#123;  <span class="comment">// 代码体 &#125;	// -12.5会出现错误</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">pow</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b)</span>&#123;  <span class="comment">// 代码体 &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/d1486651890/article/details/111993368">Math.round() 四舍五入方法</a></li>
</ol>
<h2 id="三-Java-集合"><a href="#三-Java-集合" class="headerlink" title="三 Java 集合"></a>三 Java 集合</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/UCfGnQRcHvF">java集合框架.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/gB1U4cagbLj">Java集合框架2.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/d2pLFedu2dg">第11章节_Java集合.doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/wjX5F9uvQzm">第11章_Java集合.pptx</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/gx2gzSHqXvX">HashMap面试题.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/yhZZZS5JRo4">深入java8的集合3：HashMap的实现原理.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/NL3FTZNsDXy">java集合框架Over.pdf</a></td>
</tr>
</tbody></table>
<h3 id="1-集合框架的概述"><a href="#1-集合框架的概述" class="headerlink" title="1.集合框架的概述"></a>1.集合框架的概述</h3><ol>
<li>集合、数组都是对多个数据进行存储操作的结构，简称 Java 容器<ul>
<li>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（ .txt, .jpg , .avi ，数据库中）</li>
</ul>
</li>
<li>数组在存储多个数据方面的特点<ul>
<li>一旦初始化以后，其长度就确定了</li>
<li>数组一旦定义好，其元素的类型也就确定了。我们也就只能操作指定类型的数据了</li>
<li>比如：String[] arr; int[] arr1; Object[] arr2</li>
</ul>
</li>
<li>数组在存储多个数据方面的缺点<ul>
<li>一旦初始化以后，其长度就不可修改</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足</li>
</ul>
</li>
<li>集合框架<ul>
<li>Collection 接口：单列集合，用来存储一个一个的对象<ul>
<li>List 接口：存储有序的、可重复的数据	–&gt;	“动态”数组<ul>
<li>ArrayList 、LinkedList 、Vector</li>
</ul>
</li>
<li>Set 接口：存储无序的、不可重复的数据	–&gt;	高中讲的“集合”<ul>
<li>HashSet 、LinkedHashSet 、TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map 接口：双列集合，用来存储一对(key - value)一对的数据	–&gt;	高中函数：y &#x3D; f(x)<ul>
<li>HashMap：作为 Map 的主要实现类；线程不安全的，效率高；存储 null 的 key 和 value<ul>
<li>LinkedHashMap：保证在遍历 map 元素时，可以按照添加的顺序实现遍历</li>
</ul>
</li>
<li>TreeMap：保证按照添加的 key-value 对进行排序，实现排序遍历，此时考虑 key 的自然排序或定制排序</li>
<li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储 null 的 key 和 value<ul>
<li>Properties：常用来处理配置文件，key 和 value 都是 String 类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="2-Collection"><a href="#2-Collection" class="headerlink" title="2.Collection"></a>2.Collection</h3><ol>
<li>Collection 接口方法<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean add(Object obj)</td>
<td>将元素 e 添加到集合中</td>
</tr>
<tr>
<td>boolean addAll(Collection coll)</td>
<td>将 coll 集合中的元素添加到当前的集合中</td>
</tr>
<tr>
<td>int size()</td>
<td>获取有效元素的个数</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空集合元素</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断当前集合是否为空</td>
</tr>
<tr>
<td>boolean contains(Object obj)</td>
<td>是通过元素的 equals() 来判断是否是同一个对象</td>
</tr>
<tr>
<td>boolean containsAll(Collection c)</td>
<td>也是调用元素的equals方法来比较的，拿两个集合的元素挨个比较</td>
</tr>
<tr>
<td>boolean remove(Object obj)</td>
<td>通过元素的 equals() 判断是否是要删除的那个元素，只会删除找到的第一个元素</td>
</tr>
<tr>
<td>boolean removeAll(Collection coll)</td>
<td>取当前集合的差集</td>
</tr>
<tr>
<td>boolean retainAll(Collection c)</td>
<td>把交集的结果存在当前集合中，不影响c</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>集合是否相等，要想返回 true ，需要当前集合和形参集合的元素都相同</td>
</tr>
<tr>
<td>Object[] toArray()</td>
<td>转成对象数组</td>
</tr>
<tr>
<td>int hashCode()</td>
<td>获取集合对象的哈希值</td>
</tr>
<tr>
<td>Iterator&lt;E&gt; iterator()</td>
<td>返回迭代器对象，用于集合遍历</td>
</tr>
</tbody></table>
</li>
<li>Iterator 迭代器接口<ul>
<li>Iterator对象称为迭代器(设计模式的一种)，主要用于遍历 Collection 集合中的元素</li>
<li>Collection 接口继承了 java.lang.Iterable 接口，该接口有一个 iterator() 方法，那么所<br>有实现了 Collection 接口的集合类都有一个 iterator() 方法，用以返回一个实现了 Iterator 接口的对象</li>
<li>Iterator 仅用于遍历集合，Iterator 本身并不提供承装对象的能力，如果需要创建<br>Iterator 对象，则必须有一个被迭代的集合</li>
<li>集合对象每次调用 iterator() 方法都得到一个全新的迭代器对象，默认游标都在集合<br>的第一个元素之前</li>
</ul>
</li>
<li>Iterator 接口的方法<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean hasNext()</td>
<td>判断是否还有下一个元素</td>
</tr>
<tr>
<td>E next()</td>
<td>①指针下移	②将下移以后集合位置上的元素返回</td>
</tr>
<tr>
<td>default void remove()</td>
<td>Iterator 可以删除集合的元素，但是是遍历过程中通过迭代器对象的 remove 方法，不是集合对象的 remove 方法</td>
</tr>
</tbody></table>
</li>
<li>注意<ul>
<li>在调用 next() 方法之前必须要调用 hasNext() 进行检测。若不调用，且<br>下一条记录无效，直接调用 next() 会抛出 NoSuchElementException 异常</li>
<li>如果还未调用 next() 或在上一次调用 next 方法之后已经调用了 remove 方法，<br>再调用 remove 都会报 IllegalStateException</li>
</ul>
</li>
<li>foreach 循环<ul>
<li>Java 5.0 提供了 foreach 循环迭代访问 Collection 和数组</li>
<li>遍历操作不需获取 Collection 或数组的长度，无需使用索引访问元素</li>
<li>遍历集合的底层调用 Iterator 完成操作</li>
<li>foreach 还可以用来遍历数组</li>
</ul>
</li>
</ol>
<h4 id="①List-接口"><a href="#①List-接口" class="headerlink" title="①List 接口"></a>①List 接口</h4><ol>
<li><p>List 接口框架</p>
<ul>
<li>Collection 接口：单列集合，用来存储一个一个的对象<ul>
<li>List 接口：存储有序的、可重复的数据	–&gt;	“动态”数组,替换原有的数组<ul>
<li>ArrayList：作为 List 接口的主要实现类；线程不安全的，效率高；底层使用 Object[] elementData 存储</li>
<li>LinkedList：对于频繁的插入、删除操作，使用此类效率比 ArrayList 高；底层使用双向链表存储</li>
<li>Vector：作为 List 接口的古老实现类；线程安全的，效率低；底层使用 Object[] elementData 存储</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayList 的源码分析</p>
<ol>
<li>jdk 7 情况下<ul>
<li>ArrayList list &#x3D; new ArrayList();	&#x2F;&#x2F; 底层创建了长度是 10 的 Object[] 数组 elementData</li>
<li>list.add(123);	&#x2F;&#x2F; elementData[0] &#x3D; new Integer(123);</li>
<li>…</li>
<li>list.add(11);	&#x2F;&#x2F; 如果此次的添加导致底层 elementData 数组容量不够，则扩容</li>
<li>默认情况下，扩容为原来的容量的 1.5 倍，同时需要将原有数组中的数据复制到新的数组中</li>
<li>结论：建议开发中使用带参的构造器：ArrayList list &#x3D; new ArrayList(int capacity)</li>
</ul>
</li>
<li>jdk 8 中 ArrayList 的变化<ul>
<li>ArrayList list &#x3D; new ArrayList();	&#x2F;&#x2F;底层 Object[] elementData 初始化为 {} ，并没有创建长度为 10 的数组</li>
<li>list.add(123);	&#x2F;&#x2F; 第一次调用 add() 时，底层才创建了长度 10 的数组，并将数据 123 添加到 elementData[0]</li>
<li>…</li>
<li>后续的添加和扩容操作与 jdk 7 无异</li>
</ul>
</li>
<li>小结：jdk7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 jdk8 中的 ArrayList 的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存</li>
</ol>
</li>
<li><p>LinkedList 的源码分析</p>
<ul>
<li>LinkedList list &#x3D; new LinkedList();	&#x2F;&#x2F; 内部声明了 Node 类型的 first 和 last 属性，默认值为 null</li>
<li>list.add(123);	&#x2F;&#x2F; 将 123 封装到 Node 中，创建了 Node 对象</li>
<li>其中，Node 定义为：体现了 LinkedList 的双向链表的说法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    Eitem;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">	    <span class="built_in">this</span>.item = element;</span><br><span class="line">	    <span class="built_in">this</span>.next = next;</span><br><span class="line">	    <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vector 的源码分析</p>
<ul>
<li>jdk7 和 jdk8 中通过 Vector() 构造器创建对象时，底层都创建了长度为 10 的数组。在扩容方面，默认扩容为原来的数组长度的 2 倍</li>
</ul>
</li>
<li><p>List 接口</p>
<ul>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th>List 接口方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void add(int index,Object ele)</td>
<td>在 index 位置插入 ele 元素</td>
</tr>
<tr>
<td>boolean addAll(index,Collection eles)</td>
<td>从 index 位置开始将 eles 中的所有元素添加进来</td>
</tr>
<tr>
<td>Object get(int index)</td>
<td>获取指定 index 位置的元素</td>
</tr>
<tr>
<td>int indexOf(Object obj)</td>
<td>返回 obj 在集合中首次出现的位置</td>
</tr>
<tr>
<td>int lastIndexOf(Object obj)</td>
<td>返回 obj 在当前集合中末次出现的位置</td>
</tr>
<tr>
<td>Object remove(int index)</td>
<td>移除指定 index 位置的元素，并返回此元素</td>
</tr>
<tr>
<td>Object set(index,Object ele)</td>
<td>设置指定 index 位置的元素为 ele</td>
</tr>
<tr>
<td>List subList(int fromIndex,int toIndex)</td>
<td>返回从 fromIndex 到 toIndex 位置的子集合</td>
</tr>
</tbody></table>
</li>
<li><p>总结：常用方法</p>
<ul>
<li>增：add(Object obj)</li>
<li>删：remove(int index) &#x2F; remove(Object obj)</li>
<li>改：set(int index, Object ele)</li>
<li>查：get(int index)</li>
<li>插：add(int index, Object ele)</li>
<li>长度：size()</li>
<li>遍历：<ul>
<li>Iterator 迭代器方式</li>
<li>增强 for 循环</li>
<li>普通的循环</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>ArrayList 实现类</p>
<ul>
<li>Arrays.asList(…)：方法返回的 List 集合，既不是 ArrayList 实例，也不是<br>Vector 实例，Arrays.asList(…) 返回值是一个固定长度的 List 集合</li>
</ul>
</li>
<li><p>LinkedList 实现类</p>
<ul>
<li>新增方法	<table>
<thead>
<tr>
<th>新增方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void addFirst(Object obj)</td>
<td>插入列表头部</td>
</tr>
<tr>
<td>void addLast(Object obj)</td>
<td>插入列表尾部</td>
</tr>
<tr>
<td>Object getFirst()</td>
<td>获取头部元素</td>
</tr>
<tr>
<td>Object getLast()</td>
<td>获取尾部元素</td>
</tr>
<tr>
<td>Object removeFirst()</td>
<td>移除头部元素</td>
</tr>
<tr>
<td>Object removeLast()</td>
<td>移除尾部元素</td>
</tr>
</tbody></table>
</li>
<li>双向链表，内部没有声明数组，而是定义了 Node 类型的 first 和 last ，用于记录首末元素。同时，定义内部类 Node ，作为 LinkedList 中保存数据的基本结构。Node 除了保存数据，还定义了两个变量<ul>
<li>prev 变量记录前一个元素的位置</li>
<li>next 变量记录下一个元素的位置</li>
</ul>
</li>
<li>代码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">	E item;</span><br><span class="line">	Node&lt;E&gt; next;</span><br><span class="line">	Node&lt;E&gt; prev;</span><br><span class="line">	Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">		<span class="built_in">this</span>.item = element;</span><br><span class="line">		<span class="built_in">this</span>.next = next;</span><br><span class="line">		<span class="built_in">this</span>.prev = prev;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Vector 实现类</p>
<ul>
<li>Vector 是一个古老的集合，JDK1.0 就有了。大多数操作与 ArrayList 相同，区别之处在于 Vector 是线程安全的</li>
<li>在各种 list 中，最好把 ArrayList 作为缺省选择。当插入、删除频繁时，使用 LinkedList；Vector 总是比 ArrayList 慢，所以尽量避免使用</li>
<li>新增方法<table>
<thead>
<tr>
<th>新增方法</th>
</tr>
</thead>
<tbody><tr>
<td>void addElement(Object obj)</td>
</tr>
<tr>
<td>void insertElementAt(Object obj,int index)</td>
</tr>
<tr>
<td>void setElementAt(Object obj,int index)</td>
</tr>
<tr>
<td>void removeElement(Object obj)</td>
</tr>
<tr>
<td>void removeAllElements()</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>面试题①：ArrayList、LinkedList、Vector 三者的异同？</p>
<ul>
<li>相同点：三个类都是实现了 List 接口，存储数据的特点相同：存储有序的、可重复的数据</li>
<li>不同点：见上</li>
</ul>
</li>
<li><p>面试题②：请问 ArrayList &#x2F; LinkedList &#x2F; Vector 的异同？谈谈你的理解？ArrayList 底层是什么？扩容机制？Vector 和 ArrayList 的最大区别?</p>
<ol>
<li>ArrayList 和 LinkedList 的异同：<ul>
<li>二者都线程不安全，相对线程安全的 Vector，执行效率高</li>
<li>此外，ArrayList 是实现了基于动态数组的数据结构，LinkedList 基于链表的数据结构。对于随机访问 get 和 set ，ArrayList 绝对优于 LinkedList ，因为 LinkedList 要移动指针。对于新增和删除操作 add(特指插入)和 remove ，LinkedList 比较占优势，因为 ArrayList 要移动数据</li>
</ul>
</li>
<li>ArrayList 和 Vector 的区别<ul>
<li>Vector 和 ArrayList 几乎是完全相同的,唯一的区别在于 Vector 是同步类(synchronized)，属于强同步类。因此开销就比 ArrayList 要大，访问要慢。正常情况下,大多数的 Java 程序员使用 ArrayList 而不是 Vector ,因为同步完全可以由程序员自己来控制</li>
<li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍</li>
<li>Vector 还有一个子类 Stack</li>
</ul>
</li>
</ol>
</li>
</ol>
<h4 id="②Set-接口"><a href="#②Set-接口" class="headerlink" title="②Set 接口"></a>②Set 接口</h4><ol>
<li>Set 接口的框架<ul>
<li>Collection 接口：单列集合，用来存储一个一个的对象<ul>
<li>Set 接口：存储无序的、不可重复的数据	–&gt;	高中讲的“集合”<ul>
<li>HashSet：作为 Set 接口的主要实现类；线程不安全的；可以存储 null 值<ul>
<li>作为 HashSet 的子类；遍历其内部数据时，可以按照添加的顺序遍历对于频繁的遍历操作，LinkedHashSet 效率高于 HashSet</li>
</ul>
</li>
<li>TreeSet：可以按照添加对象的指定属性，进行排序</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Set 接口中没有额外定义新的方法，使用的都是 Collection 中声明过的方法</li>
<li>向Set(主要指：HashSet、LinkedHashSet )中添加的数据，其所在的类一定要重写 hashCode() 和 equals()<ul>
<li>要求①：重写的 hashCode() 和 equals() 尽可能保持一致性：相等的对象必须具有相等的散列码</li>
<li>要求②：重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值</li>
</ul>
</li>
<li>Set：存储无序的、不可重复的数据<br> 以 HashSet 为例：<ul>
<li>无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的</li>
<li>不可重复性：保证添加的元素按照 equals() 判断时，不能返回 true。即：相同的元素只能添加一个</li>
</ul>
</li>
<li>添加元素的过程<br> 以 HashSet 为例<ul>
<li>我们向 HashSet 中添加元素 a ,首先调用元素 a 所在类的 hashCode() 方法，计算元素 a 的哈希值，此哈希值接着通过某种算法计算出在 HashSet 底层数组中的存放位置（即为：索引位置），判断 数组此位置上是否已经有元素：<ul>
<li>如果此位置上没有其他元素，则元素a添加成功	—&gt;	情况 1</li>
<li>如果此位置上有其他元素 b (或以链表形式存在的多个元素），则比较元素 a 与元素 b 的 hash 值：<ul>
<li>如果 hash 值不相同，则元素 a 添加成功	—&gt;	情况 2</li>
<li>如果 hash 值相同，进而需要调用元素 a 所在类的 equals() 方法：<ul>
<li>equals() 返回 true ,元素 a 添加失败</li>
<li>equals() 返回 false ,则元素 a 添加成功	—&gt;	情况 2</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>对于添加成功的情况 2 和情况 3 而言：元素 a 与已经存在指定索引位置上数据以链表的方式存储<ul>
<li>jdk 7 :元素 a 放到数组中，指向原来的元素</li>
<li>jdk 8 :原来的元素在数组中，指向元素 a</li>
<li>总结：七上八下</li>
</ul>
</li>
</ul>
</li>
<li>HashSet 实现类<ul>
<li>不能保证元素的排列顺序</li>
<li>HashSet 不是线程安全的</li>
<li>集合元素可以是 null</li>
</ul>
</li>
<li>LinkedHashSet 实现类<ul>
<li>LinkedHashSet 是 HashSet 的子类</li>
<li>LinkedHashSet 根据元素的 hashCode 值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的</li>
<li>LinkedHashSet 插入性能略低于 HashSet ，但在迭代访问 Set 里的全<br>部元素时有很好的性能</li>
<li>LinkedHashSet 不允许集合元素重复</li>
<li>图示：<br><img src="https://img-blog.csdnimg.cn/3c54acbc48bc4ce9987ecddf820be1df.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>TreeSet 实现类<ol>
<li>TreeSet 是 SortedSet 接口的实现类，TreeSet 可以确保集合元素处于排序状态</li>
<li>TreeSet 底层使用红黑树结构存储数据</li>
<li>新增的方法（了解）<table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>Comparator comparator()</td>
</tr>
<tr>
<td>Object first()</td>
</tr>
<tr>
<td>Object last()</td>
</tr>
<tr>
<td>Object lower(Object e)</td>
</tr>
<tr>
<td>Object higher(Object e)</td>
</tr>
<tr>
<td>SortedSet subSet(fromElement, toElement)</td>
</tr>
<tr>
<td>SortedSet headSet(toElement)</td>
</tr>
<tr>
<td>SortedSet tailSet(fromElement)</td>
</tr>
</tbody></table>
</li>
<li>TreeSet 两种排序方法：自然排序（添加的对象的类实现 Comparable 接口）和定制排序（创建 TreeSet时传入 Comparator ）。默认情况下，TreeSet 采用自然排序<ul>
<li>自然排序中，比较两个对象是否相同的标准为：compareTo() 返回 0，不再是 equals()</li>
<li>定制排序中，比较两个对象是否相同的标准为：compare() 返回 0，不再是 equals()</li>
</ul>
</li>
<li>TreeSet 采用红黑树的存储结构，有序，查询速度比 List 快</li>
</ol>
</li>
</ol>
<h3 id="3-Map"><a href="#3-Map" class="headerlink" title="3.Map"></a>3.Map</h3><ol>
<li>Map 的实现类的结构<ul>
<li>Map：双列数据，存储 key-value 对的数据	—&gt;	类似于高中的函数：y &#x3D; f(x)<ul>
<li>HashMap:作为 Map 的主要实现类；线程不安全的，效率高；存储 null 的 key 和 value<ul>
<li>LinkedHashMap：保证在遍历 map 元素时，可以按照添加的顺序实现遍历<br>  原因：在原有的 HashMap 底层结构基础上，添加了一对指针，指向前一个和后一个元素。对于频繁的遍历操作，此类执行效率高于 HashMap</li>
</ul>
</li>
<li>TreeMap：保证按照添加的 key-value 对进行排序，实现排序遍历。此时考虑 key 的自然排序或定制排序<br>  底层使用红黑树</li>
<li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储 null 的 key 和 value<ul>
<li>Properties：常用来处理配置文件。key 和 value 都是 String 类型</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Map 结构的理解<ul>
<li>Map 中的 key ：无序的、不可重复的，使用 Set 存储所有的 key	—&gt;	key 所在的类要重写equals() 和 hashCode() （以HashMap为例）</li>
<li>Map 中的value：无序的、可重复的，使用 Collection 存储所有的 value	—&gt;	value 所在的类要重写 equals()</li>
<li>一个键值对：key-value 构成了一个 Entry 对象</li>
<li>Map 中的 entry：无序的、不可重复的，使用 Set 存储所有的 entry<br> <img src="https://img-blog.csdnimg.cn/39492de774fe42a088438b1aac71c798.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>常用方法<table>
<thead>
<tr>
<th>添加、删除、修改操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object put(Object key,Object value)</td>
<td>将指定 key-value 添加到(或修改)当前 map 对象中</td>
</tr>
<tr>
<td>void putAll(Map m)</td>
<td>将 m 中的所有 key-value 对存放到当前 map 中</td>
</tr>
<tr>
<td>Object remove(Object key)</td>
<td>移除指定 key 的 key-value 对，并返回 value</td>
</tr>
<tr>
<td>void clear()</td>
<td>清空当前 map 中的所有数据</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>元素查询的操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object get(Object key)</td>
<td>获取指定 key 对应的 value</td>
</tr>
<tr>
<td>boolean containsKey(Object key)</td>
<td>是否包含指定的 key</td>
</tr>
<tr>
<td>boolean containsValue(Object value)</td>
<td>是否包含指定的 value</td>
</tr>
<tr>
<td>int size()</td>
<td>返回 map 中 key-value 对的个数</td>
</tr>
<tr>
<td>boolean isEmpty()</td>
<td>判断当前 map 是否为空</td>
</tr>
<tr>
<td>boolean equals(Object obj)</td>
<td>判断当前 map 和参数对象 obj 是否相等</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>元视图操作</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Set keySet()</td>
<td>返回所有 key 构成的 Set 集合</td>
</tr>
<tr>
<td>Collection values()</td>
<td>返回所有 value 构成的 Collection 集合</td>
</tr>
<tr>
<td>Set entrySet()</td>
<td>返回所有 key-value 对构成的 Set 集合</td>
</tr>
</tbody></table>
</li>
</ol>
<h4 id="①HashMap-与-LinkedHashMap"><a href="#①HashMap-与-LinkedHashMap" class="headerlink" title="①HashMap 与 LinkedHashMap"></a>①HashMap 与 LinkedHashMap</h4><ol>
<li>HashMap 的底层实现原理（以 jdk7 为例说明）<ul>
<li>HashMap map &#x3D; new HashMap();	在实例化以后，底层创建了长度是16的一维数组 Entry[] table</li>
<li>…可能已经执行过多次put…</li>
<li>map.put(key1,value1);</li>
<li>首先，调用 key1 所在类的 hashCode() 计算 key1 哈希值，此哈希值经过某种算法计算以后，得到在 Entry 数组中的存放位置</li>
<li>如果此位置上的数据为空，此时的 key1-value1 添加成功	–&gt;	情况 1</li>
<li>如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较 key1 和已经存在的一个或多个数据的哈希值<ul>
<li>如果 key1 的哈希值与已经存在的数据的哈希值都不相同，此时 key1-value1 添加成功	–&gt;	情况 2</li>
<li>如果 key1 的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用 key1 所在类的 equals(key2) 方法，比较<ul>
<li>如果 equals() 返回 false，此时 key1-value1 添加成功	–&gt;	情况 3</li>
<li>如果 equals() 返回 true，使用 value1 替换 value2</li>
</ul>
</li>
</ul>
</li>
<li>补充：关于情况 2 和情况 3 ：此时 key1-value1 和原来的数据以链表的方式存储</li>
<li>在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的 2 倍，并将原有的数据复制过来</li>
</ul>
</li>
<li>HashMap 中 jdk8 相较于 jdk7 在底层实现方面的不同<ul>
<li>new HashMap()：底层没有创建一个长度为 16 的数组</li>
<li>jdk 8底层的数组是：Node[]，而非 Entry[]</li>
<li>首次调用 put() 方法时，底层创建长度为 16 的数组</li>
<li>jdk7 底层结构只有：数组+链表。jdk8 中底层结构：数组+链表+红黑树<ul>
<li>形成链表时，七上八下（jdk7：新的元素指向旧的元素。jdk8：旧的元素指向新的元素）</li>
<li>当数组的某一个索引位置上的元素以链表形式存在的 数据个数 &gt; 8 且 当前数组的长度 &gt; 64时，此时此索引位置上的所数据改为使用红黑树存储</li>
</ul>
</li>
</ul>
</li>
<li>HashMap 的特点<ul>
<li>允许使用 null 键和 null 值，与 HashSet 一样，不保证映射的顺序</li>
<li>所有的 key 构成的集合是 Set ：无序的、不可重复的。所以，key 所在的类要重写：equals() 和 hashCode()</li>
<li>所有的 value 构成的集合是 Collection：无序的、可以重复的。所以，value 所在的类<br>要重写：equals()</li>
<li>HashMap 判断两个 key 相等的标准是：两个 key 通过 equals() 方法返回 true，<br>hashCode 值也相等</li>
<li>HashMap 判断两个 value 相等的标准是：两个 value 通过 equals() 方法返回 true<br> <img src="https://img-blog.csdnimg.cn/bfba5c502d5c474b8db41204f99b2549.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>HashMap 源码中的重要常量<table>
<thead>
<tr>
<th>常量</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DEFAULT_INITIAL_CAPACITY</td>
<td>HashMap 的默认容量，16</td>
</tr>
<tr>
<td>MAXIMUM_CAPACITY</td>
<td>HashMap 的最大支持容量，2^30</td>
</tr>
<tr>
<td>DEFAULT_LOAD_FACTOR</td>
<td>HashMap 的默认加载因子</td>
</tr>
<tr>
<td>TREEIFY_THRESHOLD</td>
<td>Bucket 中链表长度大于该默认值，转化为红黑树</td>
</tr>
<tr>
<td>UNTREEIFY_THRESHOLD</td>
<td>Bucket 中红黑树存储的 Node 小于该默认值，转化为链表</td>
</tr>
<tr>
<td>MIN_TREEIFY_CAPACITY</td>
<td>桶中的 Node 被树化时最小的 hash 表容量。（当桶中 Node 的数量大到需要变红黑树时，若 hash 表容量小于 MIN_TREEIFY_CAPACITY 时，此时应执行 resize 扩容操作这个 MIN_TREEIFY_CAPACITY 的值至少是 TREEIFY_THRESHOLD 的 4 倍）</td>
</tr>
<tr>
<td>table</td>
<td>存储元素的数组，总是 2 的 n 次幂</td>
</tr>
<tr>
<td>entrySet</td>
<td>存储具体元素的集</td>
</tr>
<tr>
<td>size</td>
<td>HashMap 中存储的键值对的数量</td>
</tr>
<tr>
<td>modCount</td>
<td>HashMap 扩容和结构改变的次数</td>
</tr>
<tr>
<td>threshold</td>
<td>扩容的临界值 &#x3D; 容量 * 填充因子</td>
</tr>
<tr>
<td>loadFactor</td>
<td>填充因子</td>
</tr>
</tbody></table>
</li>
<li>HashMap 面试题①<br> 负载因子值的大小，对 HashMap 有什么影响<ul>
<li>负载因子的大小决定了 HashMap 的数据密度</li>
<li>负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降</li>
<li>负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间</li>
<li>按照其他语言的参考及研究经验，会考虑将负载因子设置为 0.7~0.75，此时平均检索长度接近于常数</li>
</ul>
</li>
<li>HashMap 注意点<ol>
<li>HashMap 的扩容<ul>
<li>当 HashMap 中的元素越来越多的时候，hash冲突的几率也就越来越高，因为数组的长度是固定的。所以为了提高查询的效率，就要对 HashMap 的数组进行扩容，而在 HashMap 数组扩容之后，最消耗性能的点就出现了：原数组中的数据必须重新计算其在新数组中的位置，并放进去，这就是 resize</li>
</ul>
</li>
<li>HashMap 什么时候进行扩容和树形化<ul>
<li>当 HashMap 中的其中一个链的对象个数如果达到了 8 个，此时如果 capacity 没有达到 64 ，那么 HashMap 会先扩容解决，如果已经达到了 64 ，那么这个链会变成树，结点类型由 Node 变成 TreeNode 类型。当然，如果当映射关系被移除后，下次 resize 方法时判断树的结点个数低于 6 个，也会把树再转为链表</li>
</ul>
</li>
<li>关于映射关系的 key 是否可以修改<ul>
<li>映射关系存储到 HashMap 中会存储 key 的 hash 值，这样就不用在每次查找时重新计算每一个 Entry 或 Node（TreeNode）的 hash 值了，因此如果已经 put 到 Map 中的映射关系，再修改 key 的属性，而这个属性又参与 hashcode 值的计算，那么会导致匹配不上</li>
</ul>
</li>
</ol>
</li>
<li>LinkedHashMap 特点<ul>
<li>LinkedHashMap 是 HashMap 的子类</li>
<li>在 HashMap 存储结构的基础上，使用了一对双向链表来记录添加元素的顺序</li>
<li>与 LinkedHashSet 类似，LinkedHashMap 可以维护 Map 的迭代顺序：迭代顺序与 Key-Value 对的插入顺序一致</li>
</ul>
</li>
<li>LinkedHashMap 中的内部类：Entry <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Entry</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">HashMap</span>.Node&lt;K,V&gt; &#123;</span><br><span class="line">	Entry&lt;K,V&gt; before, after;</span><br><span class="line">	Entry(<span class="type">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">		<span class="built_in">super</span>(hash, key, value, next);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="②TreeMap"><a href="#②TreeMap" class="headerlink" title="②TreeMap"></a>②TreeMap</h4><ol>
<li>TreeMap 存储 Key-Value 对时，需要根据 key-value 对进行排序。TreeMap 可以保证所有的 Key-Value 对处于有序状态</li>
<li>TreeMap 底层使用红黑树结构存储数据</li>
<li>TreeMap 的 Key 的排序<ul>
<li>自然排序：TreeMap 的所有的 Key 必须实现 Comparable 接口，而且所有的 Key 应该是同一个类的对象，否则将会抛出 ClasssCastException</li>
<li>定制排序：创建 TreeMap 时，传入一个 Comparator 对象，该对象负责对 TreeMap 中的所有 key 进行排序。此时不需要 Map 的 Key 实现 Comparable 接口</li>
</ul>
</li>
<li>TreeMap 判断两个 key 相等的标准：两个 key 通过 compareTo() 方法或者 compare() 方法返回 0</li>
</ol>
<h4 id="③Hashtable-与-Properties"><a href="#③Hashtable-与-Properties" class="headerlink" title="③Hashtable 与 Properties"></a>③Hashtable 与 Properties</h4><ol>
<li>Hashtable<ul>
<li>Hashtable 是个古老的 Map 实现类，JDK1.0 就提供了。不同于 HashMap，Hashtable 是线程安全的</li>
<li>Hashtable 实现原理和 HashMap 相同，功能相同。底层都使用哈希表结构，查询<br>速度快，很多情况下可以互用</li>
<li>与 HashMap 不同，Hashtable 不允许使用 null 作为 key 和 value</li>
<li>与 HashMap 一样，Hashtable 也不能保证其中 Key-Value 对的顺序</li>
<li>Hashtable 判断两个 key 相等、两个 value 相等的标准，与 HashMap 一致</li>
</ul>
</li>
<li>Properties<ul>
<li>Properties 类是 Hashtable 的子类，该对象用于处理属性文件</li>
<li>由于属性文件里的 key、value 都是字符串类型，所以 Properties 里的 key 和 value 都是字符串类型</li>
<li>存取数据时，建议使用 setProperty(String key,String value) 方法和 getProperty(String key) 方法</li>
</ul>
</li>
</ol>
<h3 id="4-Collections-工具类"><a href="#4-Collections-工具类" class="headerlink" title="4.Collections 工具类"></a>4.Collections 工具类</h3><ol>
<li>Collections 是一个操作 Set、List 和 Map 等集合的工具类</li>
<li>Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法</li>
<li>常用方法<table>
<thead>
<tr>
<th>排序操作（均为 static 方法）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void reverse(List list)</td>
<td>反转 List 中元素的顺序</td>
</tr>
<tr>
<td>void shuffle(List list)</td>
<td>对 List 集合元素进行随机排序</td>
</tr>
<tr>
<td>void sort(List list)</td>
<td>根据元素的自然顺序对指定 List 集合元素按升序排序</td>
</tr>
<tr>
<td>void sort(List list , Comparator comp)</td>
<td>根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</td>
</tr>
<tr>
<td>void swap(List list , int i , int j)</td>
<td>将指定 list 集合中的 i 处元素和 j 处元素进行交换</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>查找、替换（均为 static 方法）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Object max(Collection coll)</td>
<td>根据元素的自然顺序，返回给定集合中的最大元素</td>
</tr>
<tr>
<td>Object max(Collection coll , Comparator comp)</td>
<td>根据 Comparator 指定的顺序，返回给定集合中的最大元素</td>
</tr>
<tr>
<td>Object min(Collection coll)</td>
<td>根据元素的自然顺序，返回给定集合中的最小元素</td>
</tr>
<tr>
<td>Object min(Collection coll , Comparator comp)</td>
<td>根据 Comparator 指定的顺序，返回给定集合中的最小元素</td>
</tr>
<tr>
<td>int frequency(Collection coll , Object obj)</td>
<td>返回指定集合中指定元素的出现次数</td>
</tr>
<tr>
<td>void copy(List dest , List src)</td>
<td>将 src 中的内容复制到 dest 中</td>
</tr>
<tr>
<td>boolean replaceAll(List list , Object oldVal , Object newVal)</td>
<td>使用新值替换 List 对象的所有旧值</td>
</tr>
</tbody></table>
</li>
<li>Collections 同步控制<ul>
<li>Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题</li>
</ul>
</li>
</ol>
<h2 id="四-泛型"><a href="#四-泛型" class="headerlink" title="四 泛型"></a>四 泛型</h2><ol>
<li>所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）</li>
<li>从 JDK1.5 以后，Java 引入了“参数化类型（Parameterized type）”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明该 List 只能保存字符串类型的对象</li>
<li>JDK1.5 改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类型实参</li>
</ol>
<h3 id="1-在集合中使用泛型"><a href="#1-在集合中使用泛型" class="headerlink" title="1.在集合中使用泛型"></a>1.在集合中使用泛型</h3><ol>
<li><p>在集合中使用泛型之前的情况</p>
<ul>
<li>问题①：类型不安全</li>
<li>问题②：强转时，可能出现 ClassCastException</li>
</ul>
</li>
<li><p>在集合中使用泛型的情况</p>
<ul>
<li>编译时，就会进行类型检查，保证数据的安全</li>
<li>避免了强转操作</li>
<li>JDK7 新特性：类型推断  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>集合接口或集合类在 JDK5.0 时都修改为带泛型的结构</p>
</li>
<li><p>在实例化集合类时，可以指明具体的泛型类型</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型</p>
<ul>
<li>比如：add(E e)  —&gt;实例化以后：add(Integer e)</li>
</ul>
</li>
<li><p>注意点：泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换</p>
</li>
<li><p>如果实例化时，没有指明泛型的类型。默认类型为 java.lang.Object 类型</p>
</li>
</ol>
<h3 id="2-自定义泛型结构"><a href="#2-自定义泛型结构" class="headerlink" title="2.自定义泛型结构"></a>2.自定义泛型结构</h3><ol>
<li>自定义泛型类、接口<ol>
<li>泛型的声明 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">GenericsInterface</span>&lt;T&gt;&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericsClass</span>&lt;T&gt;&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>体会：使用泛型的主要优点是能够在编译时而不是在运行时检测错误</li>
<li>注意点：<ul>
<li>泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt;</li>
<li>泛型类的构造器如下：public GenericClass(){}，而下面是错误的：public GenericClass<E>(){}</li>
<li>泛型如果不指定，将被擦除，泛型对应的类型均按照 Object 处理，但不等价于 Object 。经验：泛型要使用一路都用。要不用，一路都不要用</li>
<li>如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象</li>
<li>在类&#x2F;接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型</li>
<li>异常类不能是泛型的</li>
<li>不能使用 new E[]。但是可以：E[] elements &#x3D; (E[])new Object[capacity];<br>  参考：ArrayList源码中声明：Object[] elementData ，而非泛型参数类型数组</li>
</ul>
</li>
<li>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类不保留父类的泛型（此时子类不是泛型类）</span></span><br><span class="line"><span class="comment">// （1）没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son1</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;<span class="comment">// 等价于class Son extends Father&lt;Object,Object&gt;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// （2）具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span> <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类保留父类的泛型（此时子类是泛型类）</span></span><br><span class="line"><span class="comment">// （1）全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// （2）部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类不保留父类的泛型（此时子类不是泛型类）</span></span><br><span class="line"><span class="comment">// （1）没有类型 擦除</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&#123;<span class="comment">//等价于class Son&lt;A,B&gt; extends Father&lt;Object,Object&gt;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// （2）具体类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son2</span>&lt;A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类保留父类的泛型（此时子类是泛型类）</span></span><br><span class="line"><span class="comment">// （1）全部保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son3</span>&lt;T1, T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;T1, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// （2）部分保留</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Son4</span>&lt;T2, A, B&gt; <span class="keyword">extends</span> <span class="title class_">Father</span>&lt;Integer, T2&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型类的使用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&lt;T&gt; &#123;</span><br><span class="line">	<span class="comment">// 使用T类型定义变量</span></span><br><span class="line">	<span class="keyword">private</span> T info;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用T类型定义构造器</span></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(T info)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 使用T类型定义一般方法</span></span><br><span class="line">	<span class="keyword">public</span> T <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> info;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(T info)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.info = info;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// static的方法中不能声明泛型</span></span><br><span class="line">	<span class="comment">/*public static void show(T t) &#123;</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 不能在try-catch中使用泛型定义</span></span><br><span class="line">	<span class="comment">/*public void test() &#123;</span></span><br><span class="line"><span class="comment">		try &#123;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		&#125; catch (MyException&lt;T&gt; ex) &#123;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">		&#125;</span></span><br><span class="line"><span class="comment">	&#125;*/</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>泛型方法<ol>
<li>方法，也可以被泛型化，不管此时定义在其中的类是不是泛型类。在泛型方法中可以定义泛型参数，此时，参数的类型就是传入数据的类型</li>
<li>泛型方法的格式<ul>
<li>[访问权限] &lt;泛型&gt; 返回类型 方法名( [泛型标识 参数名称] ) 抛出的异常  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DAO</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> &lt;E&gt; E <span class="title function_">get</span><span class="params">(<span class="type">int</span> id, E e)</span> &#123;</span><br><span class="line">		<span class="type">E</span> <span class="variable">result</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>泛型方法声明泛型时也可以指定上限</li>
<li>总结<ul>
<li>在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系</li>
<li>换句话说，泛型方法所属的类是不是泛型类都没有关系</li>
<li>泛型方法，可以声明为静态的。原因：泛型参数是在调用方法时确定的，并非在实例化类时确定</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="3-泛型在继承上的体现"><a href="#3-泛型在继承上的体现" class="headerlink" title="3.泛型在继承上的体现"></a>3.泛型在继承上的体现</h3><ol>
<li>虽然类 A 是类 B 的父类，但是 G&lt;A&gt;  和 G&lt;B&gt; 二者不具备子父类关系，二者是并列关系</li>
<li>类A是类B的父类，A&lt;G&gt; 是 B&lt;G&gt; 的父类</li>
<li>示例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testGenericAndSubClass</span><span class="params">()</span> &#123;</span><br><span class="line">	Object[] obj = <span class="literal">null</span>;</span><br><span class="line">	String[] str = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// Object[] 是 String[] 的父类，多态</span></span><br><span class="line">	obj = str;</span><br><span class="line">	<span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> str[<span class="number">0</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 在泛型的集合上</span></span><br><span class="line">	List&lt;Person&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">	List&lt;Man&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">// list1 = list2;(报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-通配符的使用"><a href="#4-通配符的使用" class="headerlink" title="4.通配符的使用"></a>4.通配符的使用</h3><ol>
<li>通配符：?</li>
<li>类 A 是类B的父类，G&lt;A&gt; 和 G&lt;B&gt; 是没有关系的，二者共同的父类是：G&lt;?&gt;</li>
<li>通配符的使用<ul>
<li>读取 List&lt;?&gt; 的对象 list 中的元素时，永远是安全的，因为不管 list 的真实类型是什么，它的父类都是 Object</li>
<li>写入 list 中的元素时，不行。因为我们不知道 c 的元素类型，我们不能向其中添加对象<ul>
<li>唯一的例外是 null ，它是所有类型的成员</li>
</ul>
</li>
<li>示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">	List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">	list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Double&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// list.add(3);//编译不通过</span></span><br><span class="line">	list.add(<span class="literal">null</span>);</span><br><span class="line">	</span><br><span class="line">	List&lt;String&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">	List&lt;Integer&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">	l1.add(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">	l2.add(<span class="number">15</span>);</span><br><span class="line">	read(l1);</span><br><span class="line">	read(l2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">(List&lt;?&gt; list)</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> (Object o : list) &#123;</span><br><span class="line">		System.out.println(o);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意点 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意点1：编译错误：不能用在泛型方法声明上，返回值类型前面&lt;&gt;不能使用?</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;?&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(ArrayList&lt;?&gt; list)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点2：编译错误：不能用在泛型类的声明上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GenericTypeClass</span>&lt;?&gt;&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意点3：编译错误：不能用在创建对象上，右边属于创建集合对象</span></span><br><span class="line">ArrayList&lt;?&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;?&gt;();</span><br></pre></td></tr></table></figure></li>
<li>有限制的通配符<ul>
<li><?>：允许所有泛型的引用调用</li>
<li>extends：通配符指定上限，使用时指定的类型必须是继承某个类，或者实现某个接口，即 &lt;&#x3D;</li>
<li>super：通配符指定下限，使用时指定的类型不能小于操作的类，即 &gt;&#x3D;</li>
</ul>
</li>
<li>举例（有限制的通配符）<ul>
<li><? extends Number>	(无穷小 , Number]：只允许泛型为 Number 及 Number 子类的引用调用</li>
<li><? super Number> [Number , 无穷大)：只允许泛型为 Number 及 Number 父类的引用调用</li>
<li><? extends Comparable>：只允许泛型为实现 Comparable 接口的实现类的引用调用</li>
<li>代码：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">// 编译失败</span></span><br><span class="line">	<span class="comment">// list1 = list5;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 编译失败</span></span><br><span class="line">	<span class="comment">// list2 = list3;</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据：</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//编译失败</span></span><br><span class="line">    <span class="comment">// Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 编译失败</span></span><br><span class="line">	<span class="comment">// Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//写入数据：</span></span><br><span class="line">    <span class="comment">//编译失败</span></span><br><span class="line">	<span class="comment">// list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="五-IO-流"><a href="#五-IO-流" class="headerlink" title="五 IO 流"></a>五 IO 流</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/9NnJhoGNnsq">第13章_IO流.pptx</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/b5xF1e1B3zS">第13章节练习_IO流.doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/5ZPhSfkzC9T">计算机字符编码.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/RkZoQfwpBu7">拓展：装饰设计模式.pdf</a></td>
</tr>
</tbody></table>
<h3 id="1-File-类的使用"><a href="#1-File-类的使用" class="headerlink" title="1.File 类的使用"></a>1.File 类的使用</h3><ol>
<li>File 类的使用<ul>
<li>java.io.File 类：文件和文件目录路径的抽象表示形式，与平台无关</li>
<li>File 能新建、删除、重命名文件和目录，但 File 不能访问文件内容本身。如果需要访问文件内容本身，则需要使用 输入&#x2F;输出流</li>
<li>想要在 Java 程序中表示一个真实存在的文件或目录，那么必须有一个 File 对象，但是 Java 程序中的一个 File 对象，可能没有一个真实存在的文件或目录</li>
<li>File 对象可以作为参数传递给流的构造器</li>
</ul>
</li>
<li>常用构造器<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public File(String pathname)</td>
<td>以 pathname 为路径创建 File 对象，可以是绝对路径或者相对路径，如果 pathname 是相对路径，则默认的当前路径在系统属性 user.dir 中存储</td>
</tr>
<tr>
<td>public File(String parent,String child)</td>
<td>以 parent 为父路径，child 为子路径创建 File 对象</td>
</tr>
<tr>
<td>public File(File parent,String child)</td>
<td>根据一个父 File 对象和子文件路径创建 File 对象</td>
</tr>
</tbody></table>
</li>
<li>路径分隔符<ul>
<li>路径中的每级目录之间用一个路径分隔符隔开</li>
<li>路径分隔符和系统有关<ul>
<li>windows 和 DOS 系统默认使用 “\” 来表示</li>
<li>UNIX 和 URL 使用 “&#x2F;” 来表示</li>
</ul>
</li>
<li>Java 程序支持跨平台运行，因此路径分隔符要慎用</li>
<li>为了解决这个隐患，File 类提供了一个常量<ul>
<li>public static final String separator：根据操作系统，动态的提供分隔符  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:\\info.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:&quot;</span> + File.separator + <span class="string">&quot;info.txt&quot;</span>);</span><br><span class="line"><span class="type">File</span> <span class="variable">file3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;d:/info.txt&quot;</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>常用方法<table>
<thead>
<tr>
<th>File 类的获取功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String getAbsolutePath()</td>
<td>获取绝对路径</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>获取路径</td>
</tr>
<tr>
<td>public String getName()</td>
<td>获取名称</td>
</tr>
<tr>
<td>public String getParent()</td>
<td>获取上层文件目录路径，若无，返回 null</td>
</tr>
<tr>
<td>public long length()</td>
<td>获取文件长度（即：字节数），不能获取目录的长度</td>
</tr>
<tr>
<td>public long lastModified()</td>
<td>获取最后一次的修改时间，毫秒值</td>
</tr>
<tr>
<td>public String[] list()</td>
<td>获取指定目录下的所有文件或者文件目录的名称数组</td>
</tr>
<tr>
<td>public File[] listFiles()</td>
<td>获取指定目录下的所有文件或者文件目录的 File 数组</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>File 类的重命名功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean renameTo(File dest)</td>
<td>把文件重命名为指定的文件路径</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>File 类的判断功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean isDirectory()</td>
<td>判断是否是文件目录</td>
</tr>
<tr>
<td>public boolean isFile()</td>
<td>判断是否是文件</td>
</tr>
<tr>
<td>public boolean exists()</td>
<td>判断是否存在</td>
</tr>
<tr>
<td>public boolean canRead()</td>
<td>判断是否可读</td>
</tr>
<tr>
<td>public boolean canWrite()</td>
<td>判断是否可写</td>
</tr>
<tr>
<td>public boolean isHidden()</td>
<td>判断是否隐藏</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>File 类的创建功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean createNewFile()</td>
<td>创建文件，若文件存在，则不创建，返回false</td>
</tr>
<tr>
<td>public boolean mkdir()</td>
<td>创建文件目录，如果此文件目录存在，就不创建了，如果此文件目录的上层目录不存在，也不创建</td>
</tr>
<tr>
<td>public boolean mkdirs()</td>
<td>创建文件目录，如果上层文件目录不存在，一并创建</td>
</tr>
</tbody></table>
</li>
</ol>
<ul>
<li>注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目<br>路径下<table>
<thead>
<tr>
<th>File 类的删除功能</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public boolean delete()</td>
<td>删除文件或者文件夹</td>
</tr>
</tbody></table>
</li>
<li>删除注意事项：<ul>
<li>Java 中的删除不走回收站</li>
<li>要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录</li>
</ul>
</li>
</ul>
<ol start="5">
<li>说明<br><img src="https://img-blog.csdnimg.cn/8c5f6f7bc2ab4c00ac9798ddfbb52068.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="2-IO-流原理及流的分类"><a href="#2-IO-流原理及流的分类" class="headerlink" title="2.IO 流原理及流的分类"></a>2.IO 流原理及流的分类</h3><ol>
<li>Java IO 原理<ul>
<li>I&#x2F;O 是 Input&#x2F;Output 的缩写， I&#x2F;O 技术是非常实用的技术，用于处理设备之间的数据传输。如 读&#x2F;写 文件，网络通讯等</li>
<li>Java 程序中，对于数据的 输入&#x2F;输出 操作以“流(stream)” 的方式进行</li>
<li>java.io 包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据</li>
<li>图示<br><img src="https://img-blog.csdnimg.cn/f077ced0a52c42ae80fc800be5902731.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>流的分类<ul>
<li>按操作数据单位不同分为：字节流(8 bit)，字符流(16 bit)</li>
<li>按数据流的流向不同分为：输入流，输出流</li>
<li>按流的角色的不同分为：节点流，处理流<table>
<thead>
<tr>
<th>（抽象基类）</th>
<th>字节流</th>
<th>处理流</th>
</tr>
</thead>
<tbody><tr>
<td>输入流</td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td>输出流</td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
</li>
<li>补充：<ul>
<li>节点流和处理流<ul>
<li>节点流：直接从数据源或目的地读写数据</li>
<li>处理流：不直接连接到数据源或目的地，而是“连接”在已存在的流（节点流或处理流）之上，通过对数据的处理为程序提供更为强大的读写功能</li>
</ul>
</li>
<li>Java 的 IO 流共涉及 40 多个类，实际上非常规则，都是从 4 个抽象基类派生的</li>
<li>由这四个类派生出来的子类名称都是以其父类名作为子类名后缀</li>
</ul>
</li>
<li>图示<br><img src="https://img-blog.csdnimg.cn/27ee5ff2cad54abd8027273ccc7c2574.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>IO 流体系<table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td>抽象基类</td>
<td><font color="red">InputStream<font/></td>
<td><font color="red">OutputStream<font/></td>
<td><font color="red">Reader<font/></td>
<td><font color="red">Writer<font/></td>
</tr>
<tr>
<td>访问文件</td>
<td><font color="red">FileInputStream<font/></td>
<td><font color="red">FileOutputStream<font/></td>
<td><font color="red">FileReader<font/></td>
<td><font color="red">FileWriter<font/></td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td>缓冲流</td>
<td><font color="red">BufferedInputStream<font/></td>
<td><font color="red">BufferedOutputStream<font/></td>
<td><font color="red">BufferedReader<font/></td>
<td><font color="red">BufferedWriter<font/></td>
</tr>
<tr>
<td>转换流</td>
<td></td>
<td></td>
<td><font color="red">InputStreamReader<font/></td>
<td><font color="red">OutputStreamWriter<font/></td>
</tr>
<tr>
<td>对象流</td>
<td><font color="red">ObjectInputStream<font/></td>
<td><font color="red">ObjectOutputStream<font/></td>
<td></td>
<td></td>
</tr>
<tr>
<td>过滤流</td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td>PrintWriter</td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="3-节点流（文件流）"><a href="#3-节点流（文件流）" class="headerlink" title="3.节点流（文件流）"></a>3.节点流（文件流）</h3><ol>
<li>InputStream &amp; Reader<ul>
<li>InputStream 和 Reader 是所有输入流的基类</li>
<li>InputStream（典型实现：FileInputStream）</li>
<li>Reader（典型实现：FileReader）</li>
<li>程序中打开的文件 IO 资源不属于内存里的资源，垃圾回收机制无法回收该资源，所以应该显式关闭文件 IO 资源</li>
<li>FileInputStream 从文件系统中的某个文件中获得输入字节。FileInputStream 用于读取非文本数据之类的原始字节流。要读取字符流，需要使用 FileReader</li>
<li>InputStream<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>从输入流中读取数据的下一个字节（返回 0 到 255 范围内的 int 字节值。如果因为已经到达流末尾而没有可用的字节，则返回值 -1）</td>
</tr>
<tr>
<td>int read(byte[] b)</td>
<td>从此输入流中将最多 b.length 个字节的数据读入一个 byte 数组中，如果因为已经到达流末尾而没有可用的字节，则返回值 -1。否则以整数形式返回实际读取的字节数</td>
</tr>
<tr>
<td>int read(byte[] b, int off,int len)</td>
<td>将输入流中最多 len 个数据字节读入 byte 数组，尝试读取 len 个字节，但读取的字节也可能小于该值，以整数形式返回实际读取的字节数，如果因为流位于文件末尾而没有可用的字节，则返回值 -1</td>
</tr>
<tr>
<td>public void close() throws IOException</td>
<td>关闭此输入流并释放与该流关联的所有系统资源</td>
</tr>
</tbody></table>
</li>
<li>Reader<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>int read()</td>
<td>读取单个字符（作为整数读取的字符，范围在 0 到 65535 之间 (0x00-0xffff)（2 个字节的 Unicode 码），如果已到达流的末尾，则返回 -1）</td>
</tr>
<tr>
<td>int read(char[] cbuf)</td>
<td>将字符读入数组，如果已到达流的末尾，则返回 -1，否则返回本次读取的字符数</td>
</tr>
<tr>
<td>int read(char[] cbuf,int off,int len)</td>
<td>将字符读入数组的某一部分，存到数组 cbuf 中，从 off 处开始存储，最多读 len 个字符，如果已到达流的末尾，则返回 -1，否则返回本次读取的字符数</td>
</tr>
<tr>
<td>public void close() throws IOException</td>
<td>关闭此输入流并释放与该流关联的所有系统资源</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>OutputStream &amp; Writer<ul>
<li>因为字符流直接以字符作为操作单位，所以 Writer 可以用字符串来替换字符数组，即以 String 对象作为参数</li>
<li>FileOutputStream 用于写出非文本数据之类的原始字节流，要写出字符流，需要使用 FileWriter</li>
<li>OutputStream<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int b)</td>
<td>将指定的字节写入此输出流（write 的常规协定是：向输出流写入一个字节，要写入的字节是参数 b 的八个低位，b 的 24 个高位将被忽略， 即写入 0~255 范围的）</td>
</tr>
<tr>
<td>void write(byte[] b)</td>
<td>将 b.length 个字节从指定的 byte 数组写入此输出流（write(b) 的常规协定是：应该与调用 write(b, 0, b.length) 的效果完全相同）</td>
</tr>
<tr>
<td>void write(byte[] b,int off,int len)</td>
<td>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此输出流</td>
</tr>
<tr>
<td>public void flush()throws IOException</td>
<td>刷新此输出流并强制写出所有缓冲的输出字节，调用此方法指示应将这些字节立即写入它们预期的目标</td>
</tr>
<tr>
<td>public void close() throws IOException</td>
<td>关闭此输出流并释放与该流关联的所有系统资源（需要先刷新，再关闭此流）</td>
</tr>
</tbody></table>
</li>
<li>Writer<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void write(int c)</td>
<td>写入单个字符（要写入的字符包含在给定整数值的 16 个低位中，16 高位被忽略。 即写入 0 到 65535 之间的 Unicode 码）</td>
</tr>
<tr>
<td>void write(char[] cbuf)</td>
<td>写入字符数组</td>
</tr>
<tr>
<td>void write(char[] cbuf,int off,int len)</td>
<td>写入字符数组的某一部分，从 off 开始，写入 len 个字符</td>
</tr>
<tr>
<td>void write(String str)</td>
<td>写入字符串</td>
</tr>
<tr>
<td>void write(String str,int off,int len)</td>
<td>写入字符串的某一部分</td>
</tr>
<tr>
<td>void flush()</td>
<td>刷新该流的缓冲，则立即将它们写入预期目标</td>
</tr>
<tr>
<td>public void close() throws IOException</td>
<td>关闭此输出流并释放与该流关联的所有系统资源（需要先刷新，再关闭此流）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>注意点<ul>
<li>在写入一个文件时，如果使用构造器 FileOutputStream(file) ，则目录下有同名文件将被覆盖</li>
<li>如果使用构造器 FileOutputStream(file,true) ，则目录下的同名文件不会被覆盖，在文件内容末尾追加内容</li>
<li>在读取文件时，必须保证该文件已存在，否则报异常</li>
<li>字节流操作字节，比如：.mp3，.avi，.rmvb，mp4，.jpg，.doc，.ppt</li>
<li>字符流操作字符，只能操作普通文本文件。最常见的文本文件：.txt ，.java ，.c ，.cpp 等语言的源代码，尤其注意 .doc ，excel ，ppt 这些不是文本文件</li>
<li>文本文件如果只是单纯的复制，并不需要在内存中查看，那么可以使用字节流来进行操作，而非文本文件不可以使用字符流来进行复制</li>
</ul>
</li>
</ol>
<h3 id="4-缓冲流"><a href="#4-缓冲流" class="headerlink" title="4.缓冲流"></a>4.缓冲流</h3><ol>
<li>为了提高数据读写的速度，Java API 提供了带缓冲功能的流类，在使用这些流类时，会创建一个内部缓冲区数组，缺省使用 8192 个字节（8Kb）的缓冲区 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title class_">FilterInputStream</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> DEFAULT_BUFFER_SIZE=<span class="number">8192</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>缓冲流要“套接”在相应的节点流之上，根据数据操作单位可以把缓冲流分为<ul>
<li>BufferedInputStream 和 BufferedOutputStream</li>
<li>BufferedReader 和 BufferedWriter</li>
</ul>
</li>
<li>当读取数据时，数据按块读入缓冲区，其后的读操作则直接访问缓冲区</li>
<li>当使用 BufferedInputStream 读取字节文件时，BufferedInputStream 会一次性从文件中读取 8192 个(8Kb)，存在缓冲区中，直到缓冲区装满了，才重新从文件中读取下一个 8192 个字节数组（读取时还需要准备 byte[] 来进行存入）</li>
<li>向流中写入字节时，不会直接写到文件，先写到缓冲区中直到缓冲区写满， BufferedOutputStream 才会把缓冲区中的数据一次性写到文件里，使用方法 flush() 可以强制将缓冲区的内容全部写入输出流（写时还需要从 byte[] 来进行读取）</li>
<li>关闭流的顺序和打开流的顺序相反。只要关闭最外层流即可，关闭最外层流也<br>会相应关闭内层节点流</li>
<li>flush()方法的使用：手动将buffer中内容写入文件</li>
<li>如果是带缓冲区的流对象的 close() 方法，不但会关闭流，还会在关闭流之前刷<br>新缓冲区，关闭后不能再写出</li>
<li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 创建缓冲流对象：它是处理流，是对节点流的包装</span></span><br><span class="line">	br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;d:\\IOTest\\source.txt&quot;</span>));</span><br><span class="line">	bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="string">&quot;d:\\IOTest\\dest.txt&quot;</span>));</span><br><span class="line">	String str;</span><br><span class="line">	<span class="keyword">while</span> ((str = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 一次读取字符文本文件的一行字符</span></span><br><span class="line">		bw.write(str); <span class="comment">// 一次写入一行字符串</span></span><br><span class="line">		bw.newLine(); <span class="comment">// 写入行分隔符</span></span><br><span class="line">	&#125;</span><br><span class="line">	bw.flush(); <span class="comment">// 刷新缓冲区</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 关闭IO流对象</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (bw != <span class="literal">null</span>) &#123;</span><br><span class="line">			bw.close(); <span class="comment">// 关闭过滤流时,会自动关闭它所包装的底层节点流</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">			br.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-转换流"><a href="#5-转换流" class="headerlink" title="5.转换流"></a>5.转换流</h3><ol>
<li>转换流提供了在字节流和字符流之间的转换</li>
<li>Java API 提供了两个转换流<ul>
<li>InputStreamReader：将 InputStream 转换为 Reader</li>
<li>OutputStreamWriter：将 Writer 转换为 OutputStream</li>
</ul>
</li>
<li>字节流中的数据都是字符时，转成字符流操作更高效</li>
<li>很多时候我们使用转换流来处理文件乱码问题，实现编码和解码的功能 </li>
<li>InputStreamReader<ul>
<li><p>实现将字节的输入流按指定字符集转换为字符的输入流</p>
</li>
<li><p>需要和 InputStream “套接”</p>
</li>
<li><p>构造器：</p>
<table>
<thead>
<tr>
<th>构造器</th>
</tr>
</thead>
<tbody><tr>
<td>public InputStreamReader(InputStream in)</td>
</tr>
<tr>
<td>public InputStreamReader(InputStream in,String charsetName)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>OutputStreamWriter<ul>
<li>实现将字符的输出流按指定字符集转换为字节的输出流</li>
<li>需要和 OutputStream “套接”</li>
<li>构造器：<table>
<thead>
<tr>
<th>构造器</th>
</tr>
</thead>
<tbody><tr>
<td>public OutputStreamWriter(OutputStream out)</td>
</tr>
<tr>
<td>public OutputStreamWriter(OutputStream out,String charsetName)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>图示：<br><img src="https://img-blog.csdnimg.cn/6a17ad3de5094aa1a308799fbdfb8048.png" alt="在这里插入图片描述"></li>
</ol>
<h4 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h4><ol>
<li>编码表的由来<ul>
<li>计算机只能识别二进制数据，早期由来是电信号，为了方便应用计算机，让它可以识别各个国家的文字，就将各个国家的文字用数字来表示，并一一对应，形成一张表，这就是编码表</li>
</ul>
</li>
<li>常见的编码表<ul>
<li>ASCII：美国标准信息交换码<ul>
<li>用一个字节的7位可以表示</li>
</ul>
</li>
<li>ISO8859-1：拉丁码表，欧洲码表<ul>
<li>用一个字节的8位表示</li>
</ul>
</li>
<li>GB2312：中国的中文编码表，最多两个字节编码所有字符</li>
<li>GBK：中国的中文编码表升级，融合了更多的中文文字符号，最多两个字节编码</li>
<li>Unicode：国际标准码，融合了目前人类使用的所有字符，为每个字符分配唯一的字符码，所有的文字都用两个字节来表示</li>
<li>UTF-8：变长的编码方式，可用1-4 个字节来表示一个字符</li>
</ul>
</li>
<li>Unicode 不完美，这里就有三个问题（Unicode 在很长一段时间内无法推广，直到互联网的出现）<ul>
<li>我们已经知道，英文字母只用一个字节表示就够了</li>
<li>如何才能区别 Unicode 和 ASCII ？计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢</li>
<li>如果和 GBK 等双字节编码方式一样，用最高位是 1 或 0 表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符</li>
</ul>
</li>
<li>面向传输的众多 UTF（UCS Transfer Format）标准出现了，顾名思义，UTF8 就是每次 8 个位传输数据，而 UTF-16 就是每次16 个位，这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了</li>
<li>Unicode 只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案，推荐的 Unicode 编码是 UTF-8 和 UTF-16</li>
<li>图示：<br><img src="https://img-blog.csdnimg.cn/ae78604a4aec41a69ba704637cd5e27e.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="6-其他流"><a href="#6-其他流" class="headerlink" title="6.其他流"></a>6.其他流</h3><h4 id="①标准输入输出流"><a href="#①标准输入输出流" class="headerlink" title="①标准输入输出流"></a>①标准输入输出流</h4><ol>
<li>System.in 和 System.out 分别代表了系统标准的输入和输出设备</li>
<li>默认输入设备是：键盘，输出设备是：显示器</li>
<li>System.in 的类型是 InputStream</li>
<li>System.out 的类型是 PrintStream，其是 OutputStream 的子类FilterOutputStream 的子类</li>
<li>重定向：通过 System 类的 setIn，setOut 方法对默认设备进行改变 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setIn</span><span class="params">(InputStream in)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setOut</span><span class="params">(PrintStream out)</span></span><br></pre></td></tr></table></figure></li>
<li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从键盘输入字符串，要求将读取到的整行字符串转成大写输出，然后继续</span></span><br><span class="line"><span class="comment"> * 进行输入操作，直至当输入“e”或者“exit”时，退出程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">System.out.println(<span class="string">&quot;请输入信息(退出输入e或exit):&quot;</span>);</span><br><span class="line"><span class="comment">// 把&quot;标准&quot;输入流(键盘输入)这个字节流包装成字符流,再包装成缓冲流</span></span><br><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">while</span> ((s = br.readLine()) != <span class="literal">null</span>) &#123; <span class="comment">// 读取用户输入的一行数据 --&gt; 阻塞程序</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(s) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(s)) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;安全退出!!&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 将读取到的整行字符串转成大写输出</span></span><br><span class="line">		System.out.println(<span class="string">&quot;--&gt;:&quot;</span> + s.toUpperCase());</span><br><span class="line">		System.out.println(<span class="string">&quot;继续输入信息&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">			br.close(); <span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="②打印流"><a href="#②打印流" class="headerlink" title="②打印流"></a>②打印流</h4><ol>
<li>实现将基本数据类型的数据格式转化为字符串输出</li>
<li>打印流：PrintStream 和 PrintWriter<ul>
<li>提供了一系列重载的 print() 和 println() 方法，用于多种数据类型的输出</li>
<li>PrintStream 和 PrintWriter 的输出不会抛出 IOException 异常</li>
<li>PrintStream 和 PrintWriter 有自动 flush 功能</li>
<li>PrintStream 打印的所有字符都使用平台的默认字符编码转换为字节，在需要写入字符而不是写入字节的情况下，应该使用 PrintWriter 类</li>
<li>System.out 返回的是 PrintStream 的实例</li>
</ul>
</li>
<li>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;D:\\IO\\text.txt&quot;</span>));</span><br><span class="line">	<span class="comment">// 创建打印输出流,设置为自动刷新模式(写入换行符或字节 &#x27;\n&#x27; 时都会刷新输出缓冲区)</span></span><br><span class="line">	ps = <span class="keyword">new</span> <span class="title class_">PrintStream</span>(fos, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;<span class="comment">// 把标准输出流(控制台输出)改成文件</span></span><br><span class="line">		System.setOut(ps);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123; <span class="comment">// 输出ASCII字符</span></span><br><span class="line">		System.out.print((<span class="type">char</span>) i);</span><br><span class="line">		<span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>) &#123; <span class="comment">// 每50个数据一行</span></span><br><span class="line">			System.out.println(); <span class="comment">// 换行</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ps != <span class="literal">null</span>) &#123;</span><br><span class="line">		ps.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="③数据流"><a href="#③数据流" class="headerlink" title="③数据流"></a>③数据流</h4><ol>
<li><p>为了方便地操作 Java 语言的基本数据类型和 String 的数据，可以使用数据流</p>
</li>
<li><p>数据流有两个类：(用于读取和写出基本数据类型、String类的数据）</p>
<ul>
<li>DataInputStream 和 DataOutputStream</li>
<li>分别“套接”在 InputStream 和 OutputStream 子类的流上</li>
</ul>
</li>
<li><p>常用方法</p>
<table>
<thead>
<tr>
<th>DataInputStream 常用方法</th>
<th>DataOutputStream 常用方法</th>
</tr>
</thead>
<tbody><tr>
<td>byte readByte()</td>
<td>byte writeByte()</td>
</tr>
<tr>
<td>short readShort()</td>
<td>short writeShort()</td>
</tr>
<tr>
<td>int readInt()</td>
<td>int writeInt()</td>
</tr>
<tr>
<td>long readLong()</td>
<td>long writeLong()</td>
</tr>
<tr>
<td>float readFloat()</td>
<td>float writeFloat()</td>
</tr>
<tr>
<td>double readDouble()</td>
<td>double writeDouble()</td>
</tr>
<tr>
<td>char readChar()</td>
<td>char writeChar()</td>
</tr>
<tr>
<td>boolean readBoolean()</td>
<td>boolean writeBoolean()</td>
</tr>
<tr>
<td>String readUTF()</td>
<td>String writeUTF()</td>
</tr>
<tr>
<td>void readFully(byte[] b)</td>
<td>void writeFully(byte[] b)</td>
</tr>
</tbody></table>
</li>
<li><p>示例：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123; <span class="comment">// 创建连接到指定文件的数据输出流对象</span></span><br><span class="line">	dos = <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;destData.dat&quot;</span>));</span><br><span class="line">	dos.writeUTF(<span class="string">&quot;我爱北京天安门&quot;</span>); <span class="comment">// 写UTF字符串</span></span><br><span class="line">	dos.writeBoolean(<span class="literal">false</span>); <span class="comment">// 写入布尔值</span></span><br><span class="line">	dos.writeLong(<span class="number">1234567890L</span>); <span class="comment">// 写入长整数</span></span><br><span class="line">	System.out.println(<span class="string">&quot;写文件成功!&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123; <span class="comment">// 关闭流对象</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (dos != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 关闭过滤流时,会自动关闭它包装的底层节点流</span></span><br><span class="line">			dos.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *读取的顺序要和写入的顺序一致，否则会报错</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	dis = <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;destData.dat&quot;</span>));</span><br><span class="line">	<span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">	<span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line">	<span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> dis.readLong();</span><br><span class="line">	System.out.println(info);</span><br><span class="line">	System.out.println(flag);</span><br><span class="line">	System.out.println(time);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (dis != <span class="literal">null</span>) &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			dis.close();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="7-对象流"><a href="#7-对象流" class="headerlink" title="7.对象流"></a>7.对象流</h3><ol>
<li>对象流<ul>
<li>ObjectInputStream 和 OjbectOutputSteam</li>
<li>用于存储和读取基本数据类型数据或对象的处理流，它的强大之处就是可以把 Java 中的对象写入到数据源中，也能把对象从数据源中还原回来</li>
<li>序列化：用 ObjectOutputStream 类保存基本类型数据或对象的机制</li>
<li>反序列化：用 ObjectInputStream 类读取基本类型数据或对象的机制</li>
<li>ObjectOutputStream 和 ObjectInputStream 不能序列化 static 和 transient 修饰的成员变量</li>
</ul>
</li>
<li>对象的序列化<ol>
<li>对象序列化机制允许把内存中的 Java 对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点，当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象</li>
<li>序列化的好处在于可将任何实现了 Serializable 接口的对象转化为字节数据，使其在保存和传输时可被还原</li>
<li>序列化是 RMI（Remote Method Invoke – 远程方法调用）过程的参数和返回值都必须实现的机制，而 RMI 是 JavaEE 的基础，因此序列化机制是 JavaEE 平台的基础</li>
<li>如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一，否则，会抛出 NotSerializableException 异常<ul>
<li>Serializable</li>
<li>Externalizable（有需要被实现的方法）</li>
</ul>
</li>
<li>凡是实现 Serializable 接口的类都有一个表示序列化版本标识符的静态变量<ul>
<li>private static final long serialVersionUID;</li>
<li>serialVersionUID 用来表明类的不同版本间的兼容性，简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</li>
<li>如果类没有显示定义这个静态常量，它的值是 Java 运行时环境根据类的内部细节自动生成的，若类的实例变量做了修改，serialVersionUID 可能发生变化，故建议，显式声明</li>
</ul>
</li>
<li>简单来说，Java 的序列化机制是通过在运行时判断类的 serialVersionUID 来验证版本一致性的，在进行反序列化时，JVM 会把传来的字节流中的serialVersionUID 与本地相应实体类的 serialVersionUID 进行比较，如果相同就认为是一致的，可以行反序列化，否则就会出现序列化版本不一致的异常（InvalidCastException）</li>
</ol>
</li>
<li>使用对象流序列化对象<ul>
<li>若某个类实现了 Serializable 接口，该类的对象就是可序列化的<ul>
<li>创建一个 ObjectOutputStream</li>
<li>调用 ObjectOutputStream 对象的 writeObject(对象) 方法输出可序列化对象</li>
<li>注意写出一次，操作 flush() 一次</li>
</ul>
</li>
<li>反序列化<ul>
<li>创建一个 ObjectInputStream</li>
<li>调用 readObject() 方法读取流中的对象</li>
</ul>
</li>
<li>强调：如果某个类的属性不是基本数据类型或 String 类型，而是另一个引用类型，那么这个引用类型必须是可序列化的，否则拥有该类型的 Field 的类也不能序列化</li>
</ul>
</li>
<li>面试题：<br> 谈谈你对 java.io.Serializable 接口的理解，我们知道它用于序列化，是空方法接口，还有其它认识吗？<ul>
<li>实现了 Serializable 接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子，这一过程亦可通过网络进行，这意味着序列化机制能自动补偿操作系统间的差异，换句话说，可以先在 Windows 机器上创建一个对象，对其序列化，然后通过网络发给一台 Unix 机器，然后在那里准确无误地重新“装配”，不必关心数据在不同机器上如何表示，也不必关心字节的顺序或者其他任何细节</li>
<li>由于大部分作为参数的类如 String 、Integer 等都实现了 java.io.Serializable 的接口，也可以利用多态的性质，作为参数使接口更灵活</li>
</ul>
</li>
</ol>
<h3 id="8-随机存取文件流"><a href="#8-随机存取文件流" class="headerlink" title="8.随机存取文件流"></a>8.随机存取文件流</h3><ol>
<li>RandomAccessFile 声明在 java.io 包下，但直接继承于 java.lang.Object 类，并且它实现了 DataInput、DataOutput 这两个接口，也就意味着这个类既可以读也可以写</li>
<li>RandomAccessFile 类支持 “随机访问” 的方式，程序可以直接跳到文件的任意地方来读、写文件<ul>
<li>支持只访问文件的部分内容</li>
<li>可以向已存在的文件后追加内容</li>
</ul>
</li>
<li>RandomAccessFile 对象包含一个记录指针，用以标示当前读写处的位置， RandomAccessFile 类对象可以自由移动记录指针<ul>
<li>long getFilePointer()：获取文件记录指针的当前位置</li>
<li>void seek(long pos)：将文件记录指针定位到 pos 位置</li>
</ul>
</li>
<li>构造器<ul>
<li>public RandomAccessFile(File file, String mode) </li>
<li>public RandomAccessFile(String name, String mode)</li>
</ul>
</li>
<li>创建 RandomAccessFile 类实例需要指定一个 mode 参数，该参数指定 RandomAccessFile 的访问模式<ul>
<li>r：以只读方式打开</li>
<li>rw：打开以便读取和写入</li>
<li>rwd：打开以便读取和写入，同步文件内容的更新</li>
<li>rws：打开以便读取和写入，同步文件内容和元数据的更新</li>
</ul>
</li>
<li>如果模式为只读 r ，则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常， 如果模式为 rw 读写，如果文件不存在则会去创建文件，如果存在则不会创建</li>
<li>用处：<ul>
<li>我们可以用 RandomAccessFile 这个类，来实现一个多线程断点下载的功能，下载前都会建立两个临时文件，一个是与被下载文件大小相同的空文件，另一个是记录文件指针的位置文件，每次暂停的时候，都会保存上一次的指针，然后断点下载的时候，会继续从上一次的地方下载，从而实现断点下载或上传的功能</li>
</ul>
</li>
</ol>
<h3 id="9-NIO-2-中-Path、Paths、Files-类的使用"><a href="#9-NIO-2-中-Path、Paths、Files-类的使用" class="headerlink" title="9.NIO.2 中 Path、Paths、Files 类的使用"></a>9.NIO.2 中 Path、Paths、Files 类的使用</h3><ol>
<li><p>Java NIO 概述</p>
<ul>
<li>Java NIO (New IO，Non-Blocking IO)是从 Java 1.4 版本开始引入的一套新的IO API，可以替代标准的 Java IO API，NIO 与原来的 IO 有同样的作用和目的，但是使用的方式完全不同，NIO 支持面向缓冲区的(IO 是面向流的)、基于通道的 IO 操作，NIO 将以更加高效的方式进行文件的读写操作</li>
<li>Java API 中提供了两套 NIO ，一套是针对标准输入输出 NIO ，另一套就是网络编程 NIO</li>
<li>|—-java.nio.channels.Channel<ul>
<li>|—-FileChannel：处理本地文件</li>
<li>|—-SocketChannel：TCP 网络编程的客户端的 Channel</li>
<li>|—-ServerSocketChannel：TCP 网络编程的服务器端的 Channel</li>
<li>|—–DatagramChannel：UDP 网络编程中发送端和接收端的 Channel</li>
</ul>
</li>
</ul>
</li>
<li><p>NIO. 2</p>
<ul>
<li>随着 JDK 7 的发布，Java 对 NIO 进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为 NIO.2，因为 NIO 提供的一些功能，NIO 已经成为文件处理中越来越重要的部分</li>
</ul>
</li>
<li><p>Path、Paths 和 Files 核心 API</p>
<ul>
<li>早期的 Java 只提供了一个 File 类来访问文件系统，但 File 类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息</li>
<li>NIO. 2 为了弥补这种不足，引入了 Path 接口，代表一个平台无关的平台路径，描述了目录结构中文件的位置，Path 可以看成是 File 类的升级版本，实际引用的资源也可以不存在</li>
<li>在以前 IO 操作都是这样写的  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"></span><br><span class="line"><span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;index.html&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>但在 Java7 中，我们可以这样写  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.nio.file.Path;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Paths;</span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;index.html&quot;</span>);</span><br></pre></td></tr></table></figure></li>
<li>同时，NIO.2 在 java.nio.file 包下还提供了 Files、Paths 工具类，Files 包含了大量静态的工具方法来操作文件，Paths 则包含了两个返回 Path 的静态工厂方法</li>
<li>Paths 类提供的静态 get() 方法用来获取 Path 对象<ul>
<li>static Path get(String first, String … more)：用于将多个字符串串连成路径</li>
<li>static Path get(URI uri)：返回指定 uri 对应的 Path 路径</li>
</ul>
</li>
</ul>
</li>
<li><p>Path 接口</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String toString()</td>
<td>返回调用 Path 对象的字符串表示形式</td>
</tr>
<tr>
<td>boolean startsWith(String path)</td>
<td>判断是否以 path 路径开始</td>
</tr>
<tr>
<td>boolean endsWith(String path)</td>
<td>判断是否以 path 路径结束</td>
</tr>
<tr>
<td>boolean isAbsolute()</td>
<td>判断是否是绝对路径</td>
</tr>
<tr>
<td>Path getParent()</td>
<td>返回 Path 对象包含整个路径，不包含 Path 对象指定的文件路</td>
</tr>
<tr>
<td>Path getRoot()</td>
<td>返回调用 Path 对象的根路径</td>
</tr>
<tr>
<td>Path getFileName()</td>
<td>返回与调用 Path 对象关联的文件名</td>
</tr>
<tr>
<td>int getNameCount()</td>
<td>返回 Path 根目录后面元素的数量</td>
</tr>
<tr>
<td>Path getName(int idx)</td>
<td>返回指定索引位置 idx 的路径名称</td>
</tr>
<tr>
<td>Path toAbsolutePath()</td>
<td>作为绝对路径返回调用 Path 对象</td>
</tr>
<tr>
<td>Path resolve(Path p)</td>
<td>合并两个路径，返回合并后的路径对应的 Path 对象</td>
</tr>
<tr>
<td>File toFile()</td>
<td>将 Path 转化为 File 类的对象</td>
</tr>
</tbody></table>
</li>
<li><p>Files 类<br> java.nio.file.Files 用于操作文件或目录的工具类</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Path copy(Path src, Path dest, CopyOption … how)</td>
<td>文件的复制</td>
</tr>
<tr>
<td>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr)</td>
<td>创建一个目录</td>
</tr>
<tr>
<td>Path createFile(Path path, FileAttribute&lt;?&gt; … arr)</td>
<td>创建一个文件</td>
</tr>
<tr>
<td>void delete(Path path)</td>
<td>删除一个文件&#x2F;目录，如果不存在，执行报错</td>
</tr>
<tr>
<td>void deleteIfExists(Path path)</td>
<td>Path对应的文件&#x2F;目录如果存在，执行删除</td>
</tr>
<tr>
<td>Path move(Path src, Path dest, CopyOption…how)</td>
<td>将 src 移动到 dest 位置</td>
</tr>
<tr>
<td>long size(Path path)</td>
<td>返回 path 指定文件的大小</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法（用于判断）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean exists(Path path, LinkOption … opts)</td>
<td>判断文件是否存在</td>
</tr>
<tr>
<td>boolean isDirectory(Path path, LinkOption … opts)</td>
<td>判断是否是目录</td>
</tr>
<tr>
<td>boolean isRegularFile(Path path, LinkOption … opts)</td>
<td>判断是否是文件</td>
</tr>
<tr>
<td>boolean isHidden(Path path)</td>
<td>判断是否是隐藏文件</td>
</tr>
<tr>
<td>boolean isReadable(Path path)</td>
<td>判断文件是否可读</td>
</tr>
<tr>
<td>boolean isWritable(Path path)</td>
<td>判断文件是否可写</td>
</tr>
<tr>
<td>boolean notExists(Path path, LinkOption … opts)</td>
<td>判断文件是否不存在</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法（用于操作内容）</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SeekableByteChannel newByteChannel(Path path, OpenOption…how)</td>
<td>获取与指定文件的连接，how 指定打开方式</td>
</tr>
<tr>
<td>DirectoryStream&lt;Path&gt; newDirectoryStream(Path path)</td>
<td>打开 path 指定的目录</td>
</tr>
<tr>
<td>InputStream newInputStream(Path path, OpenOption…how)</td>
<td>获取 InputStream 对象</td>
</tr>
<tr>
<td>OutputStream newOutputStream(Path path, OpenOption…how)</td>
<td>获取 OutputStream 对象</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="六-多线程"><a href="#六-多线程" class="headerlink" title="六 多线程"></a>六 多线程</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/PbMCStwWpcF">第8章_多线程.pptx</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/pgLAEQkNy9w">第8章节练习_多线程.doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/h8gXzPmrVFV">Java多线程.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/DNgKMWDHqwD">Java多线程游戏开发.pdf</a></td>
</tr>
</tbody></table>
<h3 id="1-基本概念：程序、进程、线程"><a href="#1-基本概念：程序、进程、线程" class="headerlink" title="1.基本概念：程序、进程、线程"></a>1.基本概念：程序、进程、线程</h3><ol>
<li>程序(program)：是为完成特定任务，用某种语言编写的一组指令的集合，即指一段静态的代码，静态对象</li>
<li>进程(process)：是程序的一次执行过程，或是正在运行的一个程序，是一个动态的过程：有它自身的产生、存在和消亡的过程——生命周期<ul>
<li>程序是静态的，进程是动态的</li>
<li>进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
</li>
<li>线程(thread)：进程可进一步细化为线程，是一个程序内部的一条执行路径<ul>
<li>若一个进程同一时间并行执行多个线程，就是支持多线程的</li>
<li>线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小</li>
<li>一个进程中的多个线程共享相同的内存单元&#x2F;内存地址空间（方法区和堆共享） –&gt; 它们从同一堆中分配对象，可以访问相同的变量和对象，这就使得线程间通信更简便、高效，但多个线程操作共享的系统资源可能就会带来安全的隐患</li>
</ul>
</li>
<li>单核 CPU 和多核 CPU 的理解<ul>
<li>单核 CPU ，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务</li>
<li>一个 Java 应用程序 java.exe ，其实至少有三个线程：main() 主线程，gc() 垃圾回收线程，异常处理线程，如果发生异常，会影响主线程</li>
</ul>
</li>
<li>并行与并发<ul>
<li>并行：多个 CPU 同时执行多个任务</li>
<li>并发：一个 CPU （采用时间片）同时执行多个任务</li>
</ul>
</li>
</ol>
<h3 id="2-线程的创建和使用"><a href="#2-线程的创建和使用" class="headerlink" title="2.线程的创建和使用"></a>2.线程的创建和使用</h3><ol>
<li>JDK1.5 之前创建新执行线程有两种方法<ul>
<li>继承 Thread 类的方式</li>
<li>实现 Runnable 接口的方式</li>
</ul>
</li>
<li>Thread 类<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Thread()</td>
<td>创建新的 Thread 对象</td>
</tr>
<tr>
<td>public Thread(String threadname)</td>
<td>创建线程并指定线程实例名</td>
</tr>
<tr>
<td>public Thread(Runnable target)</td>
<td>指定创建线程的目标对象，它实现了 Runnable 接口中的 run 方法</td>
</tr>
<tr>
<td>public Thread(Runnable target, String name)</td>
<td>创建新的Thread对象</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void start()</td>
<td>启动当前线程，调用当前线程的 run()</td>
</tr>
<tr>
<td>void run()</td>
<td>通常需要重写 Thread 类中的此方法，将创建的线程要执行的操作声明在此方法中</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取当前线程的名字</td>
</tr>
<tr>
<td>void setName(String name)</td>
<td>设置当前线程的名字</td>
</tr>
<tr>
<td>static Thread currentThread()</td>
<td>返回当前线程，在 Thread 子类中就是 this ，通常用于主线程和 Runnable 实现类</td>
</tr>
<tr>
<td>static void yield()</td>
<td>释放当前 cpu 的执行权	①暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程	②若队列中没有同优先级的线程，忽略此方法	③让步以后，该线程可能会再次获得执行权</td>
</tr>
<tr>
<td>void join()</td>
<td>当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止</td>
</tr>
<tr>
<td>static void sleep(long millis)</td>
<td>①令当前活动线程在指定时间段内放弃对CPU控制（此时该线程是阻塞状态），使其他线程有机会被执行,时间到后重排队	②抛出 InterruptedException 异常（在继承 Thread 类的线程当中只能捕获，因为不能抛出比父类更大的异常）</td>
</tr>
<tr>
<td>void stop()</td>
<td>已过时，强制线程生命期结束，不推荐使用</td>
</tr>
<tr>
<td>boolean isAlive()</td>
<td>返回 boolean ，判断线程是否还活着</td>
</tr>
<tr>
<td>int getPriority()</td>
<td>返回线程优先值</td>
</tr>
<tr>
<td>void setPriority(int newPriority)</td>
<td>改变线程的优先级</td>
</tr>
</tbody></table>
</li>
<li>继承 Thread 类<ol>
<li>步骤：<ul>
<li>创建一个继承于 Thread 类的子类</li>
<li>重写 Thread 类的 run() –&gt; 将此线程执行的操作声明在 run() 中</li>
<li>创建 Thread 类的子类的对象</li>
<li>通过此对象调用 start()：①启动当前线程	②调用当前线程的 run()</li>
</ul>
</li>
<li>注意点：<ul>
<li>如果自己手动调用 run() 方法，那么就只是普通方法，没有启动多线程模式</li>
<li>run() 方法由 JVM 调用，什么时候调用，执行的过程控制都有操作系统的 CPU 调度决定</li>
<li>想要启动多线程，必须调用 start()</li>
<li>一个线程对象只能调用一次 start() 方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”</li>
</ul>
</li>
</ol>
</li>
<li>实现 Runnable 接口<ol>
<li>步骤：<ul>
<li>创建一个实现了 Runnable 接口的类</li>
<li>实现类去实现 Runnable 中的抽象方法：run()</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到 Thread 类的构造器中，创建 Thread 类的对象</li>
<li>通过 Thread 类的对象调用 start()：① 启动线程 ②调用当前线程的 run() –&gt; 调用了 Runnable 类型的 target 的 run()</li>
</ul>
</li>
<li>区别：<ul>
<li>继承 Thread：线程代码存放 Thread 子类 run() 方法中</li>
<li>实现 Runnable：线程代码存在接口的子类的 run() 方法</li>
</ul>
</li>
</ol>
</li>
<li>为什么推荐实现 Runnable 接口的方式<ul>
<li>实现的方式没有类的单继承性的局限性</li>
<li>实现的方式更适合来处理多个线程有共享数据的情况</li>
<li>使用同步方法的时候还需要方法为静态的（因为锁的对象为 this），如果方法为静态的，那么牵扯到方法里面的属性也需要静态的</li>
</ul>
</li>
<li>线程的优先级<ul>
<li>常用常量：（1~10）<ul>
<li>MAX_PRIORITY：10 </li>
<li>MIN _PRIORITY：1</li>
<li>NORM_PRIORITY：5</li>
</ul>
</li>
<li>说明：<ul>
<li>线程创建时继承父线程的优先级</li>
<li>低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用</li>
</ul>
</li>
</ul>
</li>
<li>线程的分类<ul>
<li>Java 中的线程分为两类：一种是守护线程，一种是用户线程</li>
<li>它们在几乎每个方面都是相同的，唯一的区别是判断 JVM 何时离开</li>
<li>守护线程是用来服务用户线程的，通过在 start() 方法前调用<br> thread.setDaemon(true) 可以把一个用户线程变成一个守护线程</li>
<li>Java 垃圾回收就是一个典型的守护线程</li>
<li>若 JVM 中都是守护线程，当前 JVM 将退出</li>
</ul>
</li>
</ol>
<h3 id="3-线程的生命周期"><a href="#3-线程的生命周期" class="headerlink" title="3.线程的生命周期"></a>3.线程的生命周期</h3><ol>
<li>JDK 中用 Thread.State 类定义了线程的几种状态<ul>
<li>新建： 当一个 Thread 类或其子类的对象被声明并创建时，新生的线程对象处于新建状态</li>
<li>就绪：处于新建状态的线程被 start() 后，将进入线程队列等待 CPU 时间片，此时它已具备了运行的条件，只是没分配到 CPU 资源</li>
<li>运行：当就绪的线程被调度并获得 CPU 资源时，便进入运行状态， run() 方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态</li>
<li>死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</li>
</ul>
</li>
<li>图示<br><img src="https://img-blog.csdnimg.cn/ee6e0991a7414dba89846bd8d1cda044.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="4-线程的同步"><a href="#4-线程的同步" class="headerlink" title="4.线程的同步"></a>4.线程的同步</h3><ol>
<li>Java 中，通过同步机制，来解决线程的安全问题</li>
<li>同步代码块<ul>
<li>代码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line">	<span class="comment">//需要被同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>说明<ul>
<li>操作共享数据的代码，即为需要被同步的代码 –&gt; 不能包含代码多了，也不能包含代码少了</li>
<li>共享数据：多个线程共同操作的变量</li>
<li>同步监视器，俗称：锁<ul>
<li>任何一个类的对象，都可以充当锁</li>
<li>多个线程必须要共用同一把锁</li>
</ul>
</li>
<li>在实现 Runnable 接口创建多线程的方式中，我们可以考虑使用 this 充当同步监视器</li>
<li>在继承 Thread 类创建多线程的方式中，慎用 this 充当同步监视器，考虑使用当前类充当同步监视器</li>
</ul>
</li>
</ul>
</li>
<li>同步方法<ul>
<li>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的</li>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明</li>
<li>同步方法的监视器<ul>
<li>非静态的同步方法，同步监视器是：this –&gt; 适用于实现 Runnable 类的线程</li>
<li>静态的同步方法，同步监视器是：当前类本身 –&gt; 适用于继承 Thread 类的线程（此时方法类的使用的变量也应该是静态的）</li>
</ul>
</li>
</ul>
</li>
<li>Lock（锁）<ul>
<li>从 JDK 5.0 开始，Java 提供了更强大的线程同步机制 –&gt; 通过显式定义同步锁对象来实现同步。同步锁使用 Lock 对象充当</li>
<li>java.util.concurrent.locks.Lock 接口是控制多个线程对共享资源进行访问的工具，锁提供了对共享资源的独占访问，每次只能有一个线程对 Lock 对象加锁，线程开始访问共享资源之前应先获得 Lock 对象</li>
<li>ReentrantLock 类实现了 Lock ，它拥有与 synchronized 相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是 ReentrantLock ，可以显式加锁、释放锁</li>
<li>代码  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestLock</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReenTrantLock</span>();</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			<span class="comment">//保证线程安全的代码;</span></span><br><span class="line">		&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">			<span class="comment">// 注意：如果同步代码有异常，要将 unlock() 写入 finally 语句块</span></span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>synchronized 与 Lock 的对比<ul>
<li>Lock 是显式锁（手动开启和关闭锁），synchronized 是隐式锁，出了作用域自动释放</li>
<li>Lock 只有代码块锁，synchronized 有代码块锁和方法锁</li>
<li>使用 Lock 锁，JVM 将花费较少的时间来调度线程，性能更好，并且具有更好的扩展性（提供更多的子类）</li>
</ul>
</li>
<li>优先使用顺序<ul>
<li>Lock –&gt; 同步代码块（已经进入了方法体，分配了相应资源）– &gt; 同步方法（在方法体之外）</li>
</ul>
</li>
<li>死锁<ul>
<li>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</li>
<li>说明<ul>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
<li>我们使用同步时，要避免出现死锁</li>
</ul>
</li>
<li>解决方法<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
</li>
</ul>
</li>
<li>释放锁的操作<ul>
<li>当前线程的同步方法、同步代码块执行结束</li>
<li>当前线程在同步代码块、同步方法中遇到 break、return 终止了该代码块、该方法的继续执行</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception ，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的 wait() 方法，当前线程暂停，并释放锁</li>
</ul>
</li>
<li>不会释放锁的操作<ul>
<li>线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁（同步监视器）<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
</li>
<li>单例模式（懒汉式）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(instance==<span class="literal">null</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">					instance=<span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="5-线程的通信"><a href="#5-线程的通信" class="headerlink" title="5.线程的通信"></a>5.线程的通信</h3><ol>
<li>方法<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void wait()</td>
<td>执行此方法，当前线程就进入阻塞状态，并释放同步监视器</td>
</tr>
<tr>
<td>void notify()</td>
<td>执行此方法，就会唤醒被 wait 的一个线程，如果有多个线程被 wait ，就唤醒优先级高的那个</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>执行此方法，就会唤醒所有被 wait 的线程</td>
</tr>
</tbody></table>
</li>
<li>这三个方法只有在 synchronized 方法或 synchronized 代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException 异常</li>
<li>因为这三个方法必须由锁对象调用，而任意对象都可以作为 synchronized 的同步锁，因此这三个方法只能在 Object 类中声明</li>
<li>wait() 方法<ul>
<li>在当前线程中调用方法： 对象名.wait()</li>
<li>使当前线程进入等待（某对象）状态 ，直到另一线程对该对象发出 notify(或 notifyAll ) 为止</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
<li>调用此方法后，当前线程将释放对象监控权 ，然后进入等待</li>
<li>在当前线程被 notify 后，要重新获得监控权，然后从断点处继续代码的执行</li>
</ul>
</li>
<li>notify() &#x2F; notifyAll()<ul>
<li>在当前线程中调用方法： 对象名.notify()</li>
<li>功能：唤醒等待该对象监控权的一个 &#x2F; 所有线程</li>
<li>调用方法的必要条件：当前线程必须具有对该对象的监控权（加锁）</li>
</ul>
</li>
<li>面试题：sleep() 和 wait() 的异同？<ul>
<li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态</li>
<li>不同点：<ul>
<li>两个方法声明的位置不同：Thread 类中声明 sleep() , Object 类中声明 wait()</li>
<li>调用的要求不同：sleep() 可以在任何需要的场景下调用，wait() 必须使用在同步代码块或同步方法中</li>
<li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep() 不会释放锁，wait() 会释放</li>
</ul>
</li>
</ul>
</li>
<li>生产者 &#x2F; 消费者问题</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProductTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Clerk</span> <span class="variable">clerk</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Clerk</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">productorThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Productor</span>(clerk));</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">consumerThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Consumer</span>(clerk));</span><br><span class="line">		productorThread.start();</span><br><span class="line">		consumerThread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clerk</span> &#123;	<span class="comment">// 售货员</span></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">product</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (product &gt;= <span class="number">20</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			product++;</span><br><span class="line">			System.out.println(<span class="string">&quot;生产者生产了第&quot;</span> + product + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">			notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">getProduct</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">this</span>.product &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				wait();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;消费者取走了第&quot;</span> +product + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">			product--;</span><br><span class="line">			notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Productor</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;	<span class="comment">// 生产者</span></span><br><span class="line">	Clerk clerk;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Productor</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;生产者开始生产产品&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep((<span class="type">int</span>) Math.random() * <span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			clerk.addProduct();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Consumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;	<span class="comment">// 消费者</span></span><br><span class="line">	Clerk clerk;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Consumer</span><span class="params">(Clerk clerk)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.clerk = clerk;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;消费者开始取走产品&quot;</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				Thread.sleep((<span class="type">int</span>) Math.random() * <span class="number">1000</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			clerk.getProduct();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-JDK5-0-新增线程创建方式"><a href="#6-JDK5-0-新增线程创建方式" class="headerlink" title="6.JDK5.0 新增线程创建方式"></a>6.JDK5.0 新增线程创建方式</h3><ol>
<li>实现 Callable 接口<ol>
<li>步骤<ul>
<li>创建一个实现 Callable 的实现类</li>
<li>实现 call() 方法，将此线程需要执行的操作声明在 call() 中</li>
<li>创建 Callable 接口实现类的对象</li>
<li>将此 Callable 接口实现类的对象作为传递到 FutureTask 构造器中，创建 FutureTask 的对象</li>
<li>将 FutureTask 的对象作为参数传递到 Thread 类的构造器中，创建 Thread 对象，并调用 start()</li>
<li>获取 Callable 中 call() 方法的返回值<ul>
<li>get() 返回值即为 FutureTask 构造器参数 Callable 实现类重写的 call() 的返回值</li>
</ul>
</li>
</ul>
</li>
<li>与使用 Runnable 相比， Callable 功能更强大些<ul>
<li>相比 run() 方法，可以有返回值</li>
<li>方法可以抛出异常</li>
<li>支持泛型的返回值</li>
<li>需要借助 FutureTask 类，比如获取返回结果</li>
</ul>
</li>
<li>Future 接口<ul>
<li>可以对具体 Runnable、Callable 任务的执行结果进行取消、查询是否完成、获取结果等</li>
<li>FutrueTask 是 Futrue 接口的唯一的实现类</li>
<li>FutureTask 同时实现了 Runnable, Future 接口。它既可以作为 Runnable 被线程执行，又可以作为 Future 得到 Callable 的返回值</li>
</ul>
</li>
</ol>
</li>
<li>线程池<ol>
<li>步骤<ul>
<li>提供指定线程数量的线程池</li>
<li>执行指定的线程的操作，需要提供实现 Runnable 接口或 Callable 接口实现类的对象</li>
<li>关闭连接池</li>
</ul>
</li>
<li>好处<ul>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
</li>
<li>JDK 5.0 起提供了线程池相关API：ExecutorService 和 Executors</li>
<li>ExecutorService：真正的线程池接口，常见子类 ThreadPoolExecutor<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void execute(Runnable command)</td>
<td>执行任务 &#x2F; 命令，没有返回值，一般用来执行 Runnable</td>
</tr>
<tr>
<td>&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</td>
<td>执行任务，有返回值，一般又来执行 Callable</td>
</tr>
<tr>
<td>void shutdown()</td>
<td>关闭连接池</td>
</tr>
</tbody></table>
</li>
<li>Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static ExecutorService newCachedThreadPool</td>
<td>创建一个可根据需要创建新线程的线程池</td>
</tr>
<tr>
<td>static ExecutorService newFixedThreadPool(int nThreads)</td>
<td>创建一个可重用固定线程数的线程池</td>
</tr>
<tr>
<td>static ExecutorService newSingleThreadExecutor()</td>
<td>创建一个只有一个线程的线程池</td>
</tr>
<tr>
<td>static ScheduledExecutorService newScheduledThreadPool(int corePoolSize)</td>
<td>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<h2 id="七-网络编程"><a href="#七-网络编程" class="headerlink" title="七 网络编程"></a>七 网络编程</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/KfrvxH6bDxF">第14章_网络编程.pptx</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/Zi8VtqKmEWj">Java网络编程.pdf</a></td>
</tr>
</tbody></table>
<h3 id="1-网络编程概述"><a href="#1-网络编程概述" class="headerlink" title="1.网络编程概述"></a>1.网络编程概述</h3><ol>
<li>网络通信协议<ul>
<li>OSI 参考模型：模型过于理想化，未能在因特网上进行广泛推广</li>
<li>TCP&#x2F;IP 参考模型(或 TCP&#x2F;IP 协议)：事实上的国际标准</li>
<li>通信协议分层的思想<ul>
<li>在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式</li>
<li>即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展</li>
</ul>
</li>
<li>图示<br><img src="https://img-blog.csdnimg.cn/71062abe4f344a39a2815c755ea3e8f8.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>IP<ul>
<li>唯一的标识 Internet 上的计算机（通信实体）</li>
<li>本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost</li>
<li>IP 地址分类方式 1：IPV4 和 IPV6<ul>
<li>IPV4：4 个字节组成，4 个 0-255，大概 42 亿，30 亿都在北美，亚洲 4 亿，2011 年初已经用尽，以点分十进制表示，如 192.168.0.1</li>
<li>IPV6：128 位（16 个字节），写成 8 个无符号整数，每个整数用四个十六进制位表示，数之间用冒号（:）分开，如：3ffe:3201:1401:1280:c8ff:fe4d:db39:1984</li>
</ul>
</li>
<li>IP 地址分类方式 2：公网地址（万维网使用）和私有地址（局域网使用）</li>
</ul>
</li>
<li>端口号<ul>
<li>标识正在计算机上运行的进程（程序）</li>
<li>不同的进程有不同的端口号</li>
<li>被规定为一个 16 位的整数 0~65535</li>
<li>端口分类<ul>
<li>公认端口：0~1023，被预先定义的服务通信占用（如：HTTP 占用端口 80 ，FTP 占用端口 21 ，Telnet 占用端口 23 ）</li>
<li>注册端口：1024~49151，分配给用户进程或应用程序（如：Tomcat 占用端口 8080 ，MySQL 占用端口 3306 ，Oracle 占用端口 1521 等）</li>
<li>动态 &#x2F; 私有端口：49152~65535</li>
</ul>
</li>
<li>端口号与 IP 地址的组合得出一个网络套接字：Socket</li>
</ul>
</li>
<li>InetAddress 类<ul>
<li>Internet 上的主机有两种方式表示地址<ul>
<li>域名(hostName)：<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a></li>
<li>IP 地址(hostAddress)：183.232.231.172</li>
</ul>
</li>
<li>InetAddress 类主要表示 IP 地址，有两个子类<ul>
<li>Inet4Address</li>
<li>Inet6Address</li>
</ul>
</li>
<li>InetAddress 类 对 象 含 有 一 个 Internet 主 机 地 址 的 域 名 和 IP 地 址（<a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a> 和 183.232.231.172）</li>
<li>域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成 IP 地址，这样才能和主机建立连接 –&gt; 域名解析<ul>
<li>先找本机 hosts（C:\Windows\System32\drivers\etc\hosts），是否有输入的域名地址，没有的话，再通过 DNS 服务器，找主机</li>
</ul>
</li>
<li>InetAddress 类没有提供公共的构造器，而是提供静态方法来获取 InetAddress 实例<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static InetAddress getLocalHost()</td>
<td>直接获取拥有本地 IP 地址的 InetAddress 对象</td>
</tr>
<tr>
<td>static InetAddress getByName(String host)</td>
<td>参数可以为域名或者 IP</td>
</tr>
</tbody></table>
</li>
<li>方法<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>String getHostAddress()</td>
<td>返回 IP 地址字符串</td>
</tr>
<tr>
<td>String getHostName()</td>
<td>获取此 IP 地址的主机名</td>
</tr>
<tr>
<td>boolean isReachable(int timeout)</td>
<td>测试是否可以达到该地址</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>TCP&#x2F;IP 协议簇<ul>
<li>传输层协议中有两个非常重要的协议<ul>
<li>传输控制协议 TCP（Transmission Control Protocol）</li>
<li>用户数据报协议 UDP（User Datagram Protocol）</li>
</ul>
</li>
<li>TCP&#x2F;IP 以其两个主要协议：传输控制协议（TCP）和网络互联协议（IP）而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议</li>
<li>IP（Internet Protocol）协议是网络层的主要协议，支持网间互连的数据通信</li>
<li>TCP&#x2F;IP 协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP 层、传输层和应用层</li>
</ul>
</li>
<li>TCP 协议<ul>
<li>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道</li>
<li>传输前，采用“三次握手”方式，点对点通信，是可靠的</li>
<li>TCP 协议进行通信的两个应用进程：客户端、服务端</li>
<li>在连接中可进行大数据量的传输</li>
<li>传输完毕，需释放已建立的连接，效率低</li>
<li>三次握手图示：<br><img src="https://img-blog.csdnimg.cn/6566ff24e6a54932be842ae60b56606c.png" alt="在这里插入图片描述"></li>
<li>四次挥手图示：<br><img src="https://img-blog.csdnimg.cn/88c248a54b3c4610a6ff291584ee216f.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>UDP 协议<ul>
<li>将数据、源、目的封装成数据包，不需要建立连接</li>
<li>每个数据报的大小限制在 64K 内</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li>
<li>可以广播发送</li>
<li>发送数据结束时无需释放资源，开销小，速度快</li>
</ul>
</li>
<li>Socket<ul>
<li>利用套接字（Socket）开发网络应用程序早已被广泛的采用，以至于成为事实上的标准</li>
<li>网络上具有唯一标识的 IP 地址和端口号组合在一起才能构成唯一能识别的标识符套接字</li>
<li>通信的两端都要有 Socket ，是两台机器间通信的端点</li>
<li>网络通信其实就是 Socket 间的通信</li>
<li>Socket 允许程序把网络连接当成一个流，数据在两个 Socket 间通过 IO 传输</li>
<li>一般主动发起通信的应用程序属客户端，等待通信请求的为服务端</li>
<li>Socket 分类<ul>
<li>流套接字（stream socket）：使用 TCP 提供可依赖的字节流服务</li>
<li>数据报套接字（datagram socket）：使用 UDP 提供“尽力而为”的数据报服务</li>
</ul>
</li>
<li>常用构造器和常用方法：<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public Socket(InetAddress address,int port)</td>
<td>创建一个流套接字并将其连接到指定 IP 地址的指定端口号</td>
</tr>
<tr>
<td>public Socket(String host,int port)</td>
<td>创建一个流套接字并将其连接到指定主机上的指定端口号</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream getInputStream()</td>
<td>返回此套接字的输入流，可以用于接收网络消息</td>
</tr>
<tr>
<td>OutputStream getOutputStream()</td>
<td>返回此套接字的输出流。可以用于发送网络消息</td>
</tr>
<tr>
<td>InetAddress getInetAddress()</td>
<td>此套接字连接到的远程 IP 地址；如果套接字是未连接的，则返回 null</td>
</tr>
<tr>
<td>InetAddress getLocalAddress()</td>
<td>获取套接字绑定的本地地址， 即本端的IP地址</td>
</tr>
<tr>
<td>int getPort()</td>
<td>此套接字连接到的远程端口号，如果尚未连接套接字，则返回 0</td>
</tr>
<tr>
<td>int getLocalPort()</td>
<td>返回此套接字绑定到的本地端口， 如果尚未绑定套接字，则返回 -1，即本端的端口号</td>
</tr>
<tr>
<td>void close()</td>
<td>关闭此套接字。套接字被关闭后，便不可在以后的网络连接中使用（即无法重新连接或重新绑定），需要创建新的套接字对象。，关闭此套接字也将会关闭该套接字的 InputStream 和OutputStream</td>
</tr>
<tr>
<td>void shutdownInput()</td>
<td>如果在套接字上调用 shutdownInput() 后从套接字输入流读取内容，则流将返回 EOF（文件结束符）， 即不能在从此套接字的输入流中接收任何数据</td>
</tr>
<tr>
<td>void shutdownOutput()</td>
<td>禁用此套接字的输出流，对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列， 如果在套接字上调用 shutdownOutput() 后写入套接字输出流，则该流将抛出 IOException ，即不能通过此套接字的输出流发送任何数据（会在流末尾写入一个“流的末尾”标记，对方才能读到 -1，否则对方的读取方法会一直堵塞）</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ol>
<h3 id="2-TCP-网络编程"><a href="#2-TCP-网络编程" class="headerlink" title="2.TCP 网络编程"></a>2.TCP 网络编程</h3><ol>
<li>通信模型<br><img src="https://img-blog.csdnimg.cn/277d6de04feb4a5daf15dd6f7bf78865.png" alt="在这里插入图片描述"></li>
<li>服务器 ServerSocket 的工作过程<ul>
<li>调用 ServerSocket(int port) ：创建一个服务器端套接字，并绑定到指定端口上，用于监听客户端的请求</li>
<li>调用 accept()：监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字对象</li>
<li>调用该 Socket 类对象的 getOutputStream() 和 getInputStream ()：获取输出流和输入流，开始网络数据的发送和接收</li>
<li>关闭 ServerSocket 和 Socket 对象：客户端访问结束，关闭通信套接字</li>
</ul>
</li>
<li>服务器建立 ServerSocket 对象<ul>
<li>ServerSocket 对象负责等待客户端请求建立套接字连接，也就是说，服务器必须事先建立一个等待客户请求建立套接字连接的 ServerSocket 对象</li>
<li>所谓“接收”客户的套接字请求，就是 accept() 方法会返回一个 Socket 对象</li>
</ul>
</li>
<li>客户端 Socket 的工作过程<ul>
<li>创建 Socket：根据指定服务端的 IP 地址或端口号构造 Socket 类对象，若服务器端响应，则建立客户端到服务器的通信线路，若连接失败，会出现异常</li>
<li>打开连接到 Socket 的输入&#x2F;出流： 使用 getInputStream() 方法获得输入流，使用 getOutputStream() 方法获得输出流，进行数据传输</li>
<li>按照一定的协议对 Socket 进行读&#x2F;写操作：通过输入流读取服务器放入线路的信息（但不能读取自己放入线路的信息），通过输出流将信息写入线程</li>
<li>关闭 Socket：断开客户端到服务器的连接，释放线路</li>
</ul>
</li>
<li>客户端创建 Socket 对象<ul>
<li>客户端程序可以使用 Socket 类创建对象，创建的同时会自动向服务器方发起连接<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Socket(String host,int port)throws UnknownHostException,IOException</td>
<td>向服务器（域名是 host ，端口号为 port ）发起 TCP 连接，若成功，则创建 Socket 对象，否则抛出异常</td>
</tr>
<tr>
<td>Socket(InetAddress address,int port)throws IOException</td>
<td>根据 InetAddress 对象所表示的 IP 地址以及端口号 port 发起连接</td>
</tr>
</tbody></table>
</li>
<li>客户端建立 socketAtClient 对象的过程就是向服务器发出套接字连接请求</li>
</ul>
</li>
</ol>
<h3 id="3-UDP-网络编程"><a href="#3-UDP-网络编程" class="headerlink" title="3.UDP 网络编程"></a>3.UDP 网络编程</h3><ol>
<li>UDP 网络通信<ul>
<li>类 DatagramSocket 和 DatagramPacket 实现了基于 UDP 协议网络程序</li>
<li>UDP 数据报通过数据报套接字 DatagramSocket 发送和接收，系统不保证 UDP 数据报一定能够安全送到目的地，也不能确定什么时候可以抵达</li>
<li>DatagramPacket 对象封装了 UDP 数据报，在数据报中包含了发送端的 IP 地址和端口号以及接收端的 IP 地址和端口号 </li>
<li>UDP 协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接，如同发快递包裹一样</li>
</ul>
</li>
<li>步骤<ul>
<li>DatagramSocket 与 DatagramPacket</li>
<li>建立发送端，接收端</li>
<li>建立数据包</li>
<li>调用 Socket 的发送、接收方法</li>
<li>关闭 Socket</li>
</ul>
</li>
<li>发送端与接收端是两个独立的运行程序</li>
<li>DatagramSocket 类<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramSocket()</td>
<td>一般由客户端创建，不需要指定 IP 和端口号，因为是在 DatagramPacket 中指定，该对象只负责发送</td>
</tr>
<tr>
<td>public DatagramSocket(int port)</td>
<td>创建数据报套接字并将其绑定到本地主机上的指定端口，套接字将被绑定到通配符地址，IP 地址由内核来选择</td>
</tr>
<tr>
<td>public DatagramSocket(int port,InetAddress laddr)</td>
<td>创建数据报套接字，将其绑定到指定的本地地址，本地端口必须在 0 到 65535 之间（包括两者），如果 IP 地址为 0.0.0.0，套接字将被绑定到通配符地址，IP 地址由内核选择</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>void close()</td>
<td>关闭此数据报套接字</td>
</tr>
<tr>
<td>void send(DatagramPacket p)</td>
<td>从此套接字发送数据报包，DatagramPacket 包含的信息指示：将要发送的数据、其长度、远程主机的 IP 地址和远程主机的端口号</td>
</tr>
<tr>
<td>void receive(DatagramPacket p)</td>
<td>从此套接字接收数据报包，当此方法返回时，DatagramPacket 的缓冲区填充了接收的数据，数据报包也包含发送方的 IP 地址和发送方机器上的端口号。，此方法在接收到数据报前一直阻塞，数据报包对象的 length 字段包含所接收信息的长度，如果信息比包的长度长，该信息将被截短</td>
</tr>
<tr>
<td>InetAddress getLocalAddress()</td>
<td>获取套接字绑定的本地地址</td>
</tr>
<tr>
<td>int getLocalPort()</td>
<td>返回此套接字绑定的本地主机上的端口号</td>
</tr>
<tr>
<td>InetAddress getInetAddress()</td>
<td>返回此套接字连接的地址，如果套接字未连接，则返回 null</td>
</tr>
<tr>
<td>int getPort()</td>
<td>返回此套接字的端口，如果套接字未连接，则返回 -1</td>
</tr>
</tbody></table>
</li>
<li>DatagramPacket 类<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public DatagramPacket(byte[] buf,int length)</td>
<td>构造 DatagramPacket，用来接收长度为  length 的数据包，length 参数必须小于等于 buf.length</td>
</tr>
<tr>
<td>public DatagramPacket(byte[] buf,int length,InetAddress address,int port)</td>
<td>构造数据报包，用来将长度为 length 的包发送到指定主机上的指定端口号，length 参数必须小于等于 buf.length</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>InetAddress getAddress()</td>
<td>返回某台机器的 IP 地址，此数据报将要发往该机器或者是从该机器接收到的</td>
</tr>
<tr>
<td>int getPort()</td>
<td>返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的</td>
</tr>
<tr>
<td>byte[] getData()</td>
<td>返回数据缓冲区，接收到的或将要发送的数据从缓冲区中的偏移量 offset 处开始，持续 length 长度</td>
</tr>
<tr>
<td>int getLength()</td>
<td>返回将要发送或接收到的数据的长度</td>
</tr>
</tbody></table>
</li>
<li>代码 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 发送端</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line">	<span class="type">byte</span>[] by = <span class="string">&quot;hello,atguigu.com&quot;</span>.getBytes();</span><br><span class="line">	<span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(by, <span class="number">0</span>, by.length,</span><br><span class="line">	InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">10000</span>);</span><br><span class="line">	ds.send(dp);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ds != <span class="literal">null</span>)&#123;</span><br><span class="line">		ds.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 接收端</span></span><br><span class="line"><span class="comment">* 在接收端，要指定监听的端口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">DatagramSocket</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	ds = <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">10000</span>);</span><br><span class="line">	<span class="type">byte</span>[] by = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">	<span class="type">DatagramPacket</span> <span class="variable">dp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(by, by.length);</span><br><span class="line">	ds.receive(dp);</span><br><span class="line">	<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(dp.getData(), <span class="number">0</span>, dp.getLength());</span><br><span class="line">	System.out.println(str + <span class="string">&quot;--&quot;</span> + dp.getAddress());</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (ds != <span class="literal">null</span>)&#123;</span><br><span class="line">		ds.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-URL-编程"><a href="#4-URL-编程" class="headerlink" title="4.URL 编程"></a>4.URL 编程</h3><ol>
<li>URL<ul>
<li>URL(Uniform Resource Locator)：统一资源定位符，它表示 Internet 上某一资源的地址</li>
<li>它是一种具体的 URI ，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源</li>
<li>通过 URL 我们可以访问 Internet 上的各种网络资源，比如最常见的 www，ftp 站点，浏览器通过解析给定的 URL 可以在网络上查找相应的文件或其他资源</li>
<li>URL 的基本结构由 5 部分组成：&lt;传输协议&gt;:&#x2F;&#x2F;&lt;主机名&gt;:&lt;端口号&gt;&#x2F;&lt;文件名&gt;#片段名?参数列表<ul>
<li>示例：<a target="_blank" rel="noopener" href="http://192.168.1.100:8080/helloworld/index.jsp#?usernae=shkstart&amp;password=123">http://192.168.1.100:8080/helloworld/index.jsp#?usernae=shkstart&amp;password=123</a></li>
<li>#片段名：即锚点，例如看小说，直接定位到章节</li>
<li>参数列表格式：参数名&#x3D;参数值&amp;参数名&#x3D;参数值….</li>
</ul>
</li>
</ul>
</li>
<li>URL 类<ul>
<li>为了表示URL，java.net 中实现了类 URL</li>
<li>URL 类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用 try-catch 语句进行捕获<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><font color="red">public URL (String spec)</font></td>
<td>通过一个表示 URL 地址的字符串可以构造一个 URL 对象</td>
<td>URL url &#x3D; new URL (“<a target="_blank" rel="noopener" href="http://www/">http://www</a>. baidu.com&#x2F;“);</td>
</tr>
<tr>
<td><font color="red">public URL(URL context, String spec)</font></td>
<td>通过基 URL 和相对 URL 构造一个 URL 对象</td>
<td>URL url&#x3D; new URL(url, “download.html”)</td>
</tr>
<tr>
<td>public URL(String protocol, String host, String file)</td>
<td></td>
<td>URL url &#x3D; new URL(“http”,”<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a>, “download. html”);</td>
</tr>
<tr>
<td>public URL(String protocol, String host, int port, String file)</td>
<td></td>
<td>URL url&#x3D; new URL(“http”, “<a target="_blank" rel="noopener" href="http://www.baidu.com&quot;/">www.baidu.com&quot;</a>, 80, “download.html”);</td>
</tr>
</tbody></table>
</li>
<li>一个 URL 对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public String getProtocol()</td>
<td>获取该 URL 的协议名</td>
</tr>
<tr>
<td>public String getHost()</td>
<td>获取该 URL 的主机名</td>
</tr>
<tr>
<td>public String getPort()</td>
<td>获取该 URL 的端口号</td>
</tr>
<tr>
<td>public String getPath()</td>
<td>获取该 URL 的文件路径</td>
</tr>
<tr>
<td>public String getFile()</td>
<td>获取该 URL 的文件名</td>
</tr>
<tr>
<td>public String getQuery()</td>
<td>获取该 URL 的查询名</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>针对 HTTP 协议的 URLConnection 类<ul>
<li>URL 的方法 openStream()：能从网络上读取数据</li>
<li>若希望输出数据，例如向服务器端的 CGI （公共网关接口-Common Gateway Interface-的简称，是用户浏览器和服务器端的应用程序进行连接的接口）程序发送一些数据，则必须先与 URL 建立连接，然后才能对其进行读写，此时需要使用 URLConnection</li>
<li>URLConnection：表示到 URL 所引用的远程对象的连接，当与一个 URL 建立连接时，首先要在一个 URL 对象上通过方法 openConnection() 生成对应的 URLConnection 对象，如果连接过程失败，将产生 IOException</li>
<li>通过 URLConnection 对象获取的输入流和输出流，即可以与现有的 CGI 程序进行交互<table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>InputStream getInputStream( ) throws IOException</td>
</tr>
<tr>
<td>OutputSteram getOutputStream( ) throws IOException</td>
</tr>
<tr>
<td>Object getContent( ) throws IOException</td>
</tr>
<tr>
<td>int getContentLength( )</td>
</tr>
<tr>
<td>String getContentType( )</td>
</tr>
<tr>
<td>long getDate( )</td>
</tr>
<tr>
<td>long getLastModified( )</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>URI、URL 和 URN 的区别<ul>
<li>URI（uniform resource identifier）：统一资源标识符，用来唯一的标识一个资源</li>
<li>URL（uniform resource locator）：统一资源定位符，它是一种具体的 URI ，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源</li>
<li>URN（uniform resource name）：统一资源命名，是通过名字来标识资源，比如 mailto:<a href="mailto:&#106;&#97;&#118;&#97;&#45;&#x6e;&#x65;&#x74;&#64;&#106;&#x61;&#x76;&#x61;&#x2e;&#x73;&#117;&#x6e;&#46;&#99;&#x6f;&#109;">&#106;&#97;&#118;&#97;&#45;&#x6e;&#x65;&#x74;&#64;&#106;&#x61;&#x76;&#x61;&#x2e;&#x73;&#117;&#x6e;&#46;&#99;&#x6f;&#109;</a></li>
<li>总结<ul>
<li>也就是说，URI 是以一种抽象的，高层次概念定义统一资源标识，而 URL 和 URN 则是具体的资源标识的方式，URL 和 URN 都是一种 URI</li>
<li>在 Java 的 URI 中，一个 URI 实例可以代表绝对的，也可以是相对的，只要它符合 URI 的语法规则</li>
<li>而 URL 类则不仅符合语义，还包含了定位该资源的信息，因此它不能是相对的</li>
</ul>
</li>
</ul>
</li>
<li>InetAddress 对象包含的两个字段：主机名(String) 和 IP 地址(int)</li>
</ol>
<h2 id="八-JDBC"><a href="#八-JDBC" class="headerlink" title="八 JDBC"></a>八 JDBC</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/uWhsuKnbDwN">JDBC_1.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/RsgpHkGr6WH">JDBC_2.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/3bLi8QyPABn">JDBC核心技术.exe</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/grZcEt6H7XN">JDBC（下）.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/ehxmSQZe2d2">JDBC接口.pdf</a></td>
</tr>
</tbody></table>
<h2 id="九-反射"><a href="#九-反射" class="headerlink" title="九 反射"></a>九 反射</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/ALFTd5yzpzw">反射.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/WMm2rt7Pahz">反射(1).pdf</a></td>
</tr>
</tbody></table>
<h3 id="1-Java-反射机制概述"><a href="#1-Java-反射机制概述" class="headerlink" title="1.Java 反射机制概述"></a>1.Java 反射机制概述</h3><ol>
<li>Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法</li>
<li>加载完类之后，在堆内存的方法区中就产生了一个 Class 类型的对象（一个类只有一个 Class 对象），这个对象就包含了完整的类的结构信息，我们可以通过这个对象看到类的结构，这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</li>
<li>关于 java.lang.Class 类的理解<ul>
<li>类的加载过程<ul>
<li>程序经过 javac.exe 命令以后，会生成一个或多个字节码文件（.class 结尾），接着我们使用 java.exe 命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中，此过程就称为类的加载，加载到内存中的类，我们就称为运行时类，此运行时类，就作为 Class 的一个实例</li>
</ul>
</li>
<li>换句话说，Class 的实例就对应着一个运行时类</li>
<li>加载到内存中的运行时类，会缓存一定的时间，在此时间之内，我们可以通过不同的方式来获取此运行时类</li>
</ul>
</li>
<li>Class 类的常用方法<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>static Class forName(String name)</td>
<td>返回指定类名 name 的 Class 对象</td>
</tr>
<tr>
<td>T newInstance()</td>
<td>调用缺省构造函数，返回该 Class 对象的一个实例</td>
</tr>
<tr>
<td>String getName()</td>
<td>返回此 Class 对象所表示的实体（类、接口、数组类、基本类型或 void）名称</td>
</tr>
<tr>
<td>native Class&lt;? super T&gt; getSuperclass()</td>
<td>返回当前 Class 对象的父类的 Class 对象</td>
</tr>
<tr>
<td>Class&lt;?&gt;[ ] getInterfaces</td>
<td>获取当前 Class 对象的接口</td>
</tr>
<tr>
<td>ClassLoader getClassLoader()</td>
<td>返回该类的类加载器</td>
</tr>
<tr>
<td>native Class&lt;? super T&gt; getSuperclass</td>
<td>返回表示此 Class 所表示的实体的超类的 Class</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[ ] getConstructors()</td>
<td>返回一个包含某些 Constructor 对象的数组</td>
</tr>
<tr>
<td>Field[ ] getDeclaredFields()</td>
<td>返回 Field 对象的一个数组</td>
</tr>
<tr>
<td>Method getMethod(String name, Class&lt;?&gt;… parameterTypes)</td>
<td>返回一个 Method 对象，此对象的形参类型为 paramType</td>
</tr>
</tbody></table>
</li>
<li>获取 Class 类的实例<ul>
<li>方式一<ul>
<li>前提：若已知具体的类，通过类的 class 属性获取，该方法最为安全可靠，程序性能最高</li>
<li>示例：Class clazz &#x3D; String.class;</li>
</ul>
</li>
<li>方式二<ul>
<li>前提：已知某个类的实例，调用该实例的 getClass() 方法获取 Class 对象</li>
<li>示例：Class clazz &#x3D; 对象名.getClass();</li>
</ul>
</li>
<li>方式三<ul>
<li>已知一个类的全类名，且该类在类路径下，可通过 Class 类的静态方法 forName() 获取，可能抛出 ClassNotFoundException</li>
<li>示例：Class clazz &#x3D; Class.forName(“java.lang.String”);</li>
</ul>
</li>
<li>方式四<ul>
<li>使用类的加载器：ClassLoader</li>
<li>示例：Class clazz&#x3D;this.getClass().getClassLoader().loadClass(“类的全类名”);</li>
</ul>
</li>
</ul>
</li>
<li>可以有 Class 对象的类型<ul>
<li>class</li>
<li>interface</li>
<li>enum</li>
<li>annotation</li>
<li>数组（只要数组的元素类型与维度一样，就是同一个 Class）</li>
<li>基本数据类型</li>
<li>void</li>
</ul>
</li>
</ol>
<h3 id="2-类加载器-ClassLoader"><a href="#2-类加载器-ClassLoader" class="headerlink" title="2.类加载器 ClassLoader"></a>2.类加载器 ClassLoader</h3><ol>
<li>类的加载过程<ul>
<li>类的加载：将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象，此过程由类加载器完成<ul>
<li>将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口（即引用地址），所有需要访问和使用类数据只能通过这个 Class 对象，这个加载的过程需要类加载器参与</li>
</ul>
</li>
<li>类的链接<ul>
<li>验证：确保加载的类信息符合 JVM 规范，例如：以 cafe 开头，没有安全方面的问题</li>
<li>准备：正式为类变量（static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配</li>
<li>解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程</li>
</ul>
</li>
<li>类的初始化<ul>
<li>执行类构造器 <clinit>() 方法的过程，类构造器 <clinit>() 方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的（类构造器是构造类信息的，不是构造该类对象的构造器）</li>
<li>当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化</li>
<li>虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确加锁和同步</li>
</ul>
</li>
</ul>
</li>
<li>什么时候会发生类初始化<ul>
<li>类的主动引用（一定会发生类的初始化）<ul>
<li>当虚拟机启动，先初始化 main() 方法所在的类</li>
<li>new 一个类的对象</li>
<li>调用类的静态成员（除了 final 常量）和静态方法</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用</li>
<li>当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类</li>
</ul>
</li>
<li>类的被动引用（不会发生类的初始化）<ul>
<li>当访问一个静态域时，只有真正声明这个域的类才会被初始化（当通过子类引用父类的静态变量，不会导致子类初始化）</li>
<li>通过数组定义类引用，不会触发此类的初始化</li>
<li>引用常量不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）</li>
</ul>
</li>
<li>示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassLoadingTest</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;main所在的类&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">// 主动引用：一定会导致 A 和 Father 的初始化</span></span><br><span class="line">		<span class="comment">// A a = new A();</span></span><br><span class="line">		<span class="comment">// System.out.println(A.m);</span></span><br><span class="line">		<span class="comment">// Class.forName(&quot;com.A&quot;);</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 被动引用</span></span><br><span class="line">		A[] array = <span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">5</span>];	<span class="comment">// 不会导致 A 和 Father 的初始化</span></span><br><span class="line">		<span class="comment">// System.out.println(A.b);// 只会初始化 Father</span></span><br><span class="line">		<span class="comment">// System.out.println(A.M);// 不会导致 A 和 Father 的初始化</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;子类被加载&quot;</span>);</span><br><span class="line">		m = <span class="number">300</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Father</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;父类被加载&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>类加载器的作用<ul>
<li>类加载的作用：将 class 文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区中类数据的访问入口</li>
<li>类缓存：标准的 JavaSE 类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间，不过 JVM 垃圾回收机制可以回收这些 Class 对象</li>
<li>图示<br><img src="https://img-blog.csdnimg.cn/5f855484c4cd457f844a9cc10c9b1dbc.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>类加载器的类型<ul>
<li>引导类加载器：用 C++ 编写的，是 JVM 自带的类加载器，负责 Java 平台核心库，用来装载核心类库，该加载器无法直接获取</li>
<li>扩展类加载器：负责 jre&#x2F;lib&#x2F;ext 目录下的 jar 包或 –D java.ext.dirs 指定目录下的 jar 包装入工作库</li>
<li>系统类加载器：负责 java –classpath 或 –D java.class.path 所指的目录下的类与 jar 包装入工作 ，是最常用的加载器</li>
<li>示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.获取一个系统类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">systemClassLoader</span> <span class="operator">=</span> ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="comment">// sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">System.out.println(systemClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.获取系统类加载器的父类加载器，即扩展类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">extensionClassLoader</span> <span class="operator">=</span> systemClassLoader.getParent();</span><br><span class="line"><span class="comment">// sun.misc.Launcher$ExtClassLoader@14ae5a5</span></span><br><span class="line">System.out.println(extensionClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取扩展类加载器的父类加载器，即引导类加载器</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">bootClassLoader</span> <span class="operator">=</span> extensionClassLoader.getParent();</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line">System.out.println(bootClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.测试当前类由哪个类加载器进行加载</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">currentClassLoader</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;test.Test&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(currentClassLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.测试JDK提供的Object类由哪个类加载器加载</span></span><br><span class="line">bootClassLoader =Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getClassLoader();</span><br><span class="line">System.out.println(bootClassLoader );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.关于类加载器的一个主要方法：getResourceAsStream(String str):获取类路径下的指定文件的输入流</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">	<span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 此时的文件默认在当前的 module 下</span></span><br><span class="line">	<span class="comment">// 读取配置文件的方式一：</span></span><br><span class="line">	<span class="comment">// FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line">	<span class="comment">// pros.load(fis);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置文件默认识别为：当前 module 的 src 下</span></span><br><span class="line">	<span class="comment">// 读取配置文件的方式二：使用 ClassLoader</span></span><br><span class="line">	<span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> Test.class.getClassLoader();</span><br><span class="line">	<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc.properties&quot;</span>);</span><br><span class="line">	pros.load(is);</span><br><span class="line">	</span><br><span class="line">	<span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">	<span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">	System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>图示<br><img src="https://img-blog.csdnimg.cn/d0d5756f797d40158f9e3f0dafdcc0cd.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ol>
<h3 id="3-创建对象与获取完整结构"><a href="#3-创建对象与获取完整结构" class="headerlink" title="3.创建对象与获取完整结构"></a>3.创建对象与获取完整结构</h3><ol>
<li>创建运行时类的对象<ul>
<li>newInstance()：调用此方法，创建对应的运行时类的对象，内部调用了运行时类的空参的构造器</li>
<li>要想此方法正常的创建运行时类的对象，要求：<ul>
<li>运行时类必须提供空参的构造器</li>
<li>空参的构造器的访问权限得够。通常，设置为public</li>
</ul>
</li>
<li>在 javabean 中要求提供一个 public 的空参构造器，原因：<ul>
<li>便于通过反射，创建运行时类的对象</li>
<li>便于子类继承此运行时类时，默认调用 super() 时，保证父类有此构造器</li>
</ul>
</li>
</ul>
</li>
<li>使用有参构造器创建对象<ul>
<li>通过 Class 类的 getDeclaredConstructor(Class … parameterTypes) 取得本类的指定形参类型的构造器</li>
<li>向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数</li>
<li>通过 Constructor 实例化对象</li>
<li>示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.根据全类名获取对应的Class对象</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;pojo.Person&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.调用指定参数结构的构造器，生成Constructor的实例</span></span><br><span class="line"><span class="type">Constructor</span> <span class="variable">con</span> <span class="operator">=</span> clazz.getConstructor(String.class,Integer.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.通过Constructor的实例创建对应类的对象，并初始化类属性</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> (Person) con.newInstance(<span class="string">&quot;Peter&quot;</span>,<span class="number">20</span>);</span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>获取运行时类的完整结构<table>
<thead>
<tr>
<th>获取属性（字段）的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Field[ ] getFields()</td>
<td>获取当前运行时类及其父类中声明为 public 访问权限的属性</td>
</tr>
<tr>
<td>Field[ ] getDeclaredFields()</td>
<td>获取当前运行时类中声明的所有属性（不包含父类中声明的属性）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取属性的权限修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getType()</td>
<td>获取属性的类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取属性名</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>获取方法的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Method[ ] getMethods()</td>
<td>获取当前运行时类及其所有父类中声明为 public 权限的方法</td>
</tr>
<tr>
<td>Method[ ] getDeclaredMethods()</td>
<td>获取当前运行时类中声明的所有方法（不包含父类中声明的方法）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>Annotation[ ] getAnnotations()</td>
<td>获取方法声明的注解</td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取方法的权限修饰符</td>
</tr>
<tr>
<td>Class&lt;?&gt; getReturnType()</td>
<td>获取方法的返回值类型</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取方法的方法名</td>
</tr>
<tr>
<td>Class&lt;?&gt;[ ] getParameterTypes()</td>
<td>获取方法的形参列表</td>
</tr>
<tr>
<td>Class&lt;?&gt;[ ] getExceptionTypes()</td>
<td>获取方法的抛出的异常的类型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>获取构造器的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor&lt;?&gt;[ ] getConstructors()</td>
<td>获取当前运行时类中声明为 public 的构造器</td>
</tr>
<tr>
<td>Constructor&lt;?&gt;[ ] getDeclaredConstructors()</td>
<td>获取当前运行时类中声明的所有的构造器</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>int getModifiers()</td>
<td>获取构造器的权限修饰符</td>
</tr>
<tr>
<td>String getName()</td>
<td>获取构造器的名称</td>
</tr>
<tr>
<td>Class&lt;?&gt;[] getParameterTypes()</td>
<td>获取构造器的参数的类型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>获取父类的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>native Class&lt;? super T&gt; getSuperclass()</td>
<td>获取运行时类的父类</td>
</tr>
<tr>
<td>Type getGenericSuperclass()</td>
<td>获取运行时类的带泛型的父类的泛型（需要强转为 ParameterizedType，才有 getActualTypeArguments 方法）</td>
</tr>
<tr>
<td>Type[ ] getActualTypeArguments()</td>
<td>获取泛型类型</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>获取接口的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Class&lt;?&gt;[ ] getInterfaces()</td>
<td>获取运行时类实现的所有接口</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>获取注解的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Annotation[] getAnnotations()</td>
<td>获取运行时类声明的注解</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>获取运行类所在包的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Package getPackage()</td>
<td>获取运行类所在类的包</td>
</tr>
</tbody></table>
</li>
<li>调用指定方法<ul>
<li>通过 Class 类的 getMethod(String name,Class…parameterTypes) 方法取得一个 Method 对象，并设置此方法操作时所需要的参数类型</li>
<li>之后使用 Object invoke(Object obj, Object[] args) 进行调用，并向方法中传递要设置的 obj 对象的参数信息</li>
</ul>
</li>
<li>调用指定属性<ul>
<li>Field getField(String name)：返回此 Class 对象表示的类或接口的指定的 public 的 Field</li>
<li>Field getDeclaredField(String name)：返回此 Class 对象表示的类或接口的指定的 Field</li>
<li>在 Field 中<ul>
<li>Object get(Object obj)：取得指定对象 obj 上此 Field 的属性内容</li>
<li>void set(Object obj,Object value) 设置指定对象 obj 上此 Field 的属性内容</li>
</ul>
</li>
</ul>
</li>
<li>关于 Object invoke(Object obj, Object … args)<ul>
<li>Object 对应原方法的返回值，若原方法无返回值，此时返回 null</li>
<li>若原方法若为静态方法，此时形参 Object obj 可为 null</li>
<li>若原方法形参列表为空，则 Object[] args 为 null</li>
<li>若原方法声明为 private，则需要在调用此 invoke() 方法前，显式调用方法对象的 setAccessible(true) 方法，将可访问 private 的方法</li>
</ul>
</li>
<li>关于 setAccessible()<ul>
<li>Method 和 Field、Constructo r对象都有 setAccessible() 方法</li>
<li>setAccessible() 启动和禁用访问安全检查的开关</li>
<li>参数值为 true 则指示反射的对象在使用时应该取消 Java 语言访问检查<ul>
<li>提高反射的效率：如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为 true</li>
<li>使得原本无法访问的私有成员也可以访问</li>
</ul>
</li>
<li>参数值为 false 则指示反射的对象应该实施 Java 语言访问检查</li>
</ul>
</li>
</ol>
<h3 id="4-动态代理"><a href="#4-动态代理" class="headerlink" title="4.动态代理"></a>4.动态代理</h3><ol>
<li>相关 API<ul>
<li>Proxy 类：专门完成代理的操作类，是所有动态代理类的父类，通过此类为一个或多个接口动态地生成实现类</li>
<li>提供用于创建动态代理类和动态代理对象的静态方法<ul>
<li>static Class<?> getProxyClass(ClassLoader loader, Class<?>… interfaces)：创建一个动态代理类所对应的 Class 对象</li>
<li>static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[ ]  interfaces,InvocationHandler h)：直接创建一个动态代理对象<ul>
<li>loader：类加载器</li>
<li>interfaces：得到被代理类实现的全部接口</li>
<li>h：得到 InvocationHandler 接口的实现类实例</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>动态代理示例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// proxyInstance：代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要想实现动态代理，需要解决的问题？</span></span><br><span class="line"><span class="comment"> * 问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象</span></span><br><span class="line"><span class="comment"> * 问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">// 调用此方法，返回一个代理类的对象，解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span>&#123;	<span class="comment">// obj：被代理类的对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line">        <span class="comment">// 此方法为自定义的，并不是官方的方法</span></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;	<span class="comment">// 需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当我们通过代理类的对象，调用方法 a 时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">// 将被代理类要执行的方法 a 的功能就声明在 invoke() 中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    	<span class="comment">// 模拟加上去的通用方法，并不是必须</span></span><br><span class="line">    	<span class="type">HumanUtil</span> <span class="variable">util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanUtil</span>();</span><br><span class="line">       	util.method1();</span><br><span class="line">		<span class="comment">// System.out.println(&quot;通用方法一&quot;);</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj,args);</span><br><span class="line"></span><br><span class="line">		util.method2();</span><br><span class="line">        <span class="comment">// System.out.println(&quot;通用方法二&quot;);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是通用方法（可以不需要）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanUtil</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法一====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法二====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>动态代理与 AOP（Aspect Orient Programming)<ul>
<li>使用 Proxy 生成一个动态代理时，往往并不会凭空产生一个动态代理，这样没有太大的意义，通常都是为指定的目标对象生成动态代理</li>
<li>这种动态代理在 AOP 中被称为 AOP 代理，AOP 代理可代替目标对象，AOP 代理包含了目标对象的全部方法</li>
<li>但 AOP 代理中的方法与目标对象的方法存在差异：AOP 代理里的方法可以在执行目标方法之前、之后插入一些通用处理</li>
</ul>
</li>
</ol>
<h2 id="十-枚举类与注解"><a href="#十-枚举类与注解" class="headerlink" title="十 枚举类与注解"></a>十 枚举类与注解</h2><h3 id="1-枚举类的使用"><a href="#1-枚举类的使用" class="headerlink" title="1.枚举类的使用"></a>1.枚举类的使用</h3><ol>
<li>枚举类的使用<ul>
<li>枚举类的理解：类的对象只有有限个，确定的，我们称此类为枚举类</li>
<li>当需要定义一组常量时，强烈建议使用枚举类</li>
<li>如果枚举类中只有一个对象，则可以作为单例模式的实现方式</li>
</ul>
</li>
<li>如何定义枚举类<ul>
<li>方式一：JDK1.5 之前，自定义枚举类</li>
<li>方式二：JDK1.5，可以使用 enum 关键字定义枚举类</li>
</ul>
</li>
<li>自定义枚举类<ol>
<li><p>步骤</p>
<ul>
<li>声明枚举类对象的属性：private final 修饰（也可没有）</li>
<li>私有化类的构造器（并给对象属性赋值）</li>
<li>提供当前枚举类的多个对象：public static final 修饰</li>
<li>其他诉求1：获取枚举类对象的属性</li>
<li>其他诉求2：提供 toString()</li>
</ul>
</li>
<li><p>枚举类的属性</p>
<ul>
<li>枚举类对象的属性不应允许被改动，所以应该使用 private final 修饰</li>
<li>枚举类的使用 private final 修饰的属性应该在构造器中为其赋值</li>
<li>若枚举类显式的定义了带参数的构造器，则在列出枚举值时也必须对应的传入参数</li>
</ul>
</li>
<li><p>示例</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASONNAME;<span class="comment">//季节的名称</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String SEASONDESC;<span class="comment">//季节的描述</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.SEASONNAME = seasonName;</span><br><span class="line">		<span class="built_in">this</span>.SEASONDESC = seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>, <span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>, <span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>, <span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>, <span class="string">&quot;白雪皑皑&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  		 * 后面为其他诉求</span></span><br><span class="line"><span class="comment">  		 */</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">     			<span class="keyword">return</span> seasonName;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">      		<span class="keyword">return</span> seasonDesc;</span><br><span class="line">  		&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>使用 enum 定义枚举类<ol>
<li>步骤<ul>
<li>提供当前枚举类的对象，多个对象之间用 “,” 隔开，末尾对象 “;” 结束</li>
<li>声明 Season 对象的属性：private final 修饰</li>
<li>私有化类的构造器,并给对象属性赋值</li>
<li>其他诉求1：获取枚举类对象的属性</li>
<li>其他诉求2：提供 toString()</li>
</ul>
</li>
<li>使用说明<ul>
<li>使用 enum 定义的枚举类默认继承了 java.lang.Enum 类，因此不能再继承其他类</li>
<li>枚举类的构造器只能使用 private 权限修饰符</li>
<li>枚举类的所有实例必须在枚举类中显式列出（, 分隔 ; 结尾），列出的实例系统会自动添加 public static final 修饰</li>
<li>必须在枚举类的第一行声明枚举类对象</li>
</ul>
</li>
<li>JDK 1.5 中可以在 switch 表达式中使用 Enum 定义的枚举类的对象作为表达式，case 子句可以直接使用枚举值的名字, 无需添加枚举类作为限定</li>
<li>示例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">SeasonEnum</span> &#123;</span><br><span class="line">	SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春风又绿江南岸&quot;</span>),</span><br><span class="line">	SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;映日荷花别样红&quot;</span>),</span><br><span class="line">	AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋水共长天一色&quot;</span>),</span><br><span class="line">	WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;窗含西岭千秋雪&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">SeasonEnum</span><span class="params">(String seasonName, String seasonDesc)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">		<span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> seasonName;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> seasonDesc;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>Enum 类的主要方法<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>values()</td>
<td>返回枚举类型的对象数组，该方法可以很方便地遍历所有的枚举值</td>
</tr>
<tr>
<td>valueOf(String str)</td>
<td>可以把一个字符串转为对应的枚举类对象，要求字符串必须是枚举类对象的“名字”，如不是，会有运行时异常：IllegalArgumentException</td>
</tr>
<tr>
<td>String toString()</td>
<td>返回当前枚举类对象常量的名称</td>
</tr>
<tr>
<td>final boolean equals(Object other)</td>
<td>在枚举类型中可以直接使用“=&#x3D;”来比较两个枚举类常量是否相等，Enum 提供的这个 equals() 方法，也是直接使用“&#x3D;=”实现的，它的存在是为了在 Set、List 和 Map 中使用，注意，equals() 是不可变的</td>
</tr>
<tr>
<td>final int hashCode()</td>
<td>Enum 实现了 hashCode() 来和 equals() 保持一致，它也是不可变的</td>
</tr>
<tr>
<td>final Class<E> getDeclaringClass()</td>
<td>得到枚举类常量所属枚举类型的 Class 对象，可以用它来判断两个枚举类常量是否属于同一个枚举类型</td>
</tr>
<tr>
<td>final String name()</td>
<td>得到当前枚举常量的名称，建议优先使用 toString()</td>
</tr>
<tr>
<td>final int ordinal</td>
<td>得到当前枚举常量的次序</td>
</tr>
<tr>
<td>final int compareTo(E o)</td>
<td>枚举类型实现了 Comparable 接口，这样可以比较两个枚举常量的大小（按照声明的顺序排列）</td>
</tr>
<tr>
<td>final Object clone()</td>
<td>枚举类不能被 clone，为了防止子类实现克隆方法，Enum 实现了一个仅抛出 CloneNotSupportedException 异常的不变 clone()</td>
</tr>
</tbody></table>
</li>
<li>枚举类实现接口<ul>
<li>和普通 Java 类一样，枚举类可以实现一个或多个接口</li>
<li>示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">Info</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     *若需要每个枚举值在调用实现的接口方法呈现出不同的行为方式, </span></span><br><span class="line"><span class="comment">     *则可以让每个枚举值分别来实现该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天 show()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;夏天 show()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天 show()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;冬天 show()&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">        <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> seasonDesc;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 若每个枚举值在调用实现的接口方法呈现相同的行为方式，</span></span><br><span class="line"><span class="comment">     * 则只要统一实现该方法即可</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">    @Override</span></span><br><span class="line"><span class="comment">    public void show() &#123;</span></span><br><span class="line"><span class="comment">        System.out.println(&quot;这是一个季节&quot;);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="2-注解"><a href="#2-注解" class="headerlink" title="2.注解"></a>2.注解</h3><ol>
<li>注解的概述<ul>
<li>从 JDK1.5 开始，Java 增加了对元数据(MetaData) 的支持, 也就是 Annotation(注解)</li>
<li>注解其实就是代码里的特殊标记，这些标记可以在编译、类加载、 运行时被读取， 并执行相应的处理，通过使用注解, 程序员可以在不改变原有逻辑的情况下, 在源文件中嵌入一些补充信息，代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署</li>
<li>注解可以像修饰符一样被使用，可用于修饰包、类、构造器、方法、成员变量、参数、局部变量的声明，这些信息被保存在 Annotation 的 “name&#x3D;value” 对中</li>
<li>在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等，在 JavaEE&#x2F;Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 JavaEE 旧版中所遗留的繁冗代码和 XML 配置等</li>
<li>未来的开发模式都是基于注解的，JPA 是基于注解的，Spring2.5 以上都是基于注解的，Hibernate3.x 以后也是基于注解的，现在的 Struts2 有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架 &#x3D; 注解 + 反射 + 设计模式</li>
</ul>
</li>
<li>注解的使用示例<ul>
<li>生成文档相关的注解</li>
<li>在编译时进行格式检查（JDK 内置的三个基本注解）<ul>
<li>@Override：限定重写父类方法，该注解只能用于方法</li>
<li>@Deprecated：用于表示所修饰的元素（类, 方法等）已过时，通常是因为所修饰的结构危险或存在更好的选择</li>
<li>@SuppressWarnings：抑制编译器警告</li>
</ul>
</li>
<li>跟踪代码依赖性，实现替代配置文件功能<ul>
<li>示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Servlet3.0提供了注解(annotation),使得不再需要在web.xml文件中进行Servlet的部署</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebServlet(&quot;/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123; &#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">		doGet(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">	&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;servlet-class&gt;com.servlet.LoginServlet&lt;/servlet-class&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br><span class="line">&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;LoginServlet&lt;/servlet-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;/login&lt;/url-pattern&gt;</span><br><span class="line">&lt;/servlet-mapping&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  spring框架中关于“事务”的管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Transactional(propagation=Propagation.REQUIRES_NEW,isolation=Isolation.READ_COMMITTED,readOnly=false,timeout=3)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">buyBook</span><span class="params">(String username, String isbn)</span> &#123;</span><br><span class="line">	<span class="comment">// 1.查询书的单价</span></span><br><span class="line">	<span class="type">int</span> <span class="variable">price</span> <span class="operator">=</span> bookShopDao.findBookPriceByIsbn(isbn);</span><br><span class="line">	<span class="comment">// 2. 更新库存</span></span><br><span class="line">	bookShopDao.updateBookStock(isbn);</span><br><span class="line">	<span class="comment">// 3. 更新用户的余额</span></span><br><span class="line">	bookShopDao.updateUserAccount(username, price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- 配置事务属性 --&gt;</span><br><span class="line">&lt;tx:advice transaction-manager=<span class="string">&quot;dataSourceTransactionManager&quot;</span> id=<span class="string">&quot;txAdvice&quot;</span>&gt;</span><br><span class="line">	&lt;tx:attributes&gt;</span><br><span class="line">	&lt;!-- 配置每个方法使用的事务属性 --&gt;</span><br><span class="line">	&lt;tx:method name=<span class="string">&quot;buyBook&quot;</span> propagation=<span class="string">&quot;REQUIRES_NEW&quot;</span></span><br><span class="line">		isolation=<span class="string">&quot;READ_COMMITTED&quot;</span> read-only=<span class="string">&quot;false&quot;</span> timeout=<span class="string">&quot;3&quot;</span> /&gt;</span><br><span class="line">	&lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>自定义注解<ol>
<li>概述<ul>
<li>定义新的注解类型使用 @interface 关键字</li>
<li>自定义注解自动继承了 java.lang.annotation.Annotation 接口</li>
<li>注解的成员变量在注解定义中以无参数方法的形式来声明，其方法名和返回值定义了该成员的名字和类型，我们称为配置参数，类型只能是八种基本数据类型、String 类型、Class 类型、enum 类型、Annotation 类型、及以上所有类型的数组</li>
<li>可以在定义注解的成员变量时为其指定初始值，指定成员变量的初始值可使用 default 关键字</li>
<li>如果只有一个参数成员，建议使用参数名为 value</li>
<li>如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值，格式是“参数名 &#x3D; 参数值”，如果只有一个参数成员，且名称为 value，可以省略 “value&#x3D;”</li>
<li>没有成员定义的 Annotation 称为标记，包含成员变量的 Annotation 称为元数据 Annotation</li>
<li>注意：自定义注解必须配上注解的信息处理流程才有意义</li>
</ul>
</li>
<li>步骤（参照 @SuppressWarnings 定义）<ul>
<li>注解声明为：@interface</li>
<li>内部定义成员，通常使用 value 表示</li>
<li>可以指定成员的默认值，使用 default 定义</li>
</ul>
</li>
<li>如果自定义注解没有成员，表明是一个标识作用</li>
<li>如果注解有成员，在使用注解时，需要指明成员的值</li>
<li>自定义注解通过都会指明两个元注解：Retention、Target</li>
</ol>
</li>
<li>JDK 中提供的 4 种元注解<ol>
<li>元注解：对现有的注解进行解释说明的注解</li>
<li>@Retention：用于指定该注解的生命周期，包含一个 RetentionPolicy 类型的成员变量，使用时必须为该 value 成员变量指定值<table>
<thead>
<tr>
<th>元注解可取值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>RetentionPolicy.SOURCE</td>
<td>在源文件中有效（即源文件保留），编译器直接丢弃这种策略的注释</td>
</tr>
<tr>
<td>RetentionPolicy.CLASS</td>
<td>在 class 文件中有效（即 class 保留），当运行 Java 程序时, JVM 不会保留注解， 这是默认值</td>
</tr>
<tr>
<td>RetentionPolicy.RUNTIME</td>
<td>在运行时有效（即运行时保留），当运行 Java 程序时, JVM 会保留注释，程序可以通过反射获取该注释</td>
</tr>
</tbody></table>
</li>
<li>@Target：用于指定被修饰的注解能用于修饰哪些程序元素， 包含一个名为 value 的成员变量<table>
<thead>
<tr>
<th>元注解可取值(ElementType)</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LOCAL_VARIABLE</td>
<td>用于描述局部变量</td>
</tr>
<tr>
<td>METHOD</td>
<td>用于描述方法</td>
</tr>
<tr>
<td>CONSTRUCTOR</td>
<td>用于描述构造器</td>
</tr>
<tr>
<td>FIELD</td>
<td>用于描述域</td>
</tr>
<tr>
<td>TYPE</td>
<td>用于描述类、接口（包括注解类型）或 enum 声明</td>
</tr>
<tr>
<td>PACKAGE</td>
<td>用于描述包</td>
</tr>
<tr>
<td>PARAMETER</td>
<td>用于描述参数</td>
</tr>
</tbody></table>
</li>
<li>@Documented：用于指定被该元注解修饰的注解类将被 javadoc 工具提取成文档，默认情况下，javadoc 是不包括注解的<ul>
<li>定义为 Documented 的注解必须设置 Retention 值为 RUNTIME</li>
</ul>
</li>
<li>@Inherited：被它修饰的注解将具有继承性，如果某个类使用了被该元注解修饰的注解, 则其子类将自动具有该注解<ul>
<li>如果把标有该元注解的自定义的注解标注在类级别上，子类则可以继承父类类级别的注解</li>
<li>实际应用中，使用较少</li>
</ul>
</li>
</ol>
</li>
<li>利用反射获取注解信息<ul>
<li>JDK1.5 在 java.lang.reflect 包下新增了 AnnotatedElement 接口, 该接口代表程序中可以接受注解的程序元素</li>
<li>当一个注解类型被定义为运行时注解后，该注解才是运行时可见，当 class 文件被载入时保存在 class 文件中的注解才会被虚拟机读取</li>
<li>程序可以调用 AnnotatedElement 对象的如下方法来访问注解信息<table>
<thead>
<tr>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</td>
</tr>
<tr>
<td>Annotation[ ] getAnnotations()</td>
</tr>
<tr>
<td>Annotation[ ] getDeclaredAnnotations()</td>
</tr>
<tr>
<td>default boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>JDK1.8 中注解的新特性<ul>
<li>此外，反射也得到了加强，在 Java1.8 中能够得到方法参数的名称，这会简化标注在方法参数上的注解</li>
<li>可重复的注解  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK1.8 之前的写法</span></span><br><span class="line"><span class="comment">// @MyAnnotations(&#123;@MyAnnotation(value=&quot;h&quot;),@MyAnnotation(value=&quot;hh&quot;)&#125;)</span></span><br><span class="line"><span class="comment">// JDK1.8 之后的写法</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;hi&quot;)</span></span><br><span class="line"><span class="meta">@MyAnnotation(value=&quot;abc&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="comment">// JDK1.8 以后靠这个</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotations &#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// JDK1.8 以前靠这个</span></span><br><span class="line">    MyAnnotation[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>类型注解<ul>
<li>JDK1.8 之后，关于元注解 @Target 的参数类型 ElementType 枚举值多了两个：TYPE_PARAMETER 和 TYPE_USE</li>
<li>在 Java1.8 之前，注解只能是在声明的地方所使用，Java1.8 开始，注解可以应用在任何地方<ul>
<li>ElementType.TYPE_PARAMETER：表示该注解能写在类型变量的声明语句中（如：泛型声明）</li>
<li>ElementType.TYPE_USE：表示该注解能写在使用类型的任何语句中</li>
</ul>
</li>
<li>示例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 ElementType.TYPE_PARAMETER</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE_PARAMETER&#125;)</span></span><br><span class="line"><span class="meta">@interface</span> TypeDefine&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestTypeDefine</span>&lt;<span class="meta">@TypeDefine()</span> U&gt; &#123;</span><br><span class="line">	<span class="keyword">private</span> U u;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> &lt;<span class="meta">@TypeDefine()</span> T&gt; <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试 ElementType.TYPE_USE</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(ElementType.TYPE_USE)</span></span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnnotationTest</span>&lt;U&gt; &#123;</span><br><span class="line">	<span class="meta">@MyAnnotation</span></span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		AnnotationTest&lt;<span class="meta">@MyAnnotation</span> String&gt; t = <span class="literal">null</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="meta">@MyAnnotation</span> <span class="type">int</span>) <span class="number">2L</span>;</span><br><span class="line">		<span class="meta">@MyAnnotation</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;<span class="meta">@MyAnnotation</span> T&gt; <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span> &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="meta">@MyAnnotation</span> String arg)</span> <span class="keyword">throws</span> <span class="meta">@MyAnnotation</span> Exception &#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="十一-Java8-的其它新特性"><a href="#十一-Java8-的其它新特性" class="headerlink" title="十一 Java8 的其它新特性"></a>十一 Java8 的其它新特性</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/zeNhgoB4SuA">第16章_Java8 的其它新特性.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/ruhBgyLUWiW">Java8 新特性.bmp</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/vTjiCJX7h6Q">Java8 的新并行 API.pdf</a></td>
</tr>
</tbody></table>
<h3 id="1-Java8-新特性简介"><a href="#1-Java8-新特性简介" class="headerlink" title="1.Java8 新特性简介"></a>1.Java8 新特性简介</h3><ol>
<li>图示<br> <img src="https://img-blog.csdnimg.cn/cc08986431624afc84e43c7228ef76f2.png" alt="在这里插入图片描述"></li>
<li>特点<ul>
<li>速度更快</li>
<li>代码更少（增加了新的语法：Lambda 表达式）</li>
<li>强大的 Stream API</li>
<li>便于并行</li>
<li>最大化减少空指针异常：Optional</li>
<li>Nashorn 引擎，允许在 JVM 上运行 JS 应用</li>
</ul>
</li>
<li>并行流与串行流<ul>
<li>并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流，相比较串行的流，并行的流可以很大程度上提高程序的执行效率</li>
<li>Java8 中将并行进行了优化，我们可以很容易的对数据进行并行操作</li>
<li>Stream API 可以声明性地通过 parallel() 与 sequential() 在并行流与顺序流之间进行切换</li>
</ul>
</li>
</ol>
<h3 id="2-Lambda-表达式"><a href="#2-Lambda-表达式" class="headerlink" title="2.Lambda 表达式"></a>2.Lambda 表达式</h3><ol>
<li>为什么使用 Lambda 表达式<ul>
<li>Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递），使用它可以写出更简洁、更灵活的代码，作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升</li>
</ul>
</li>
<li>语法<ul>
<li>在Java8 语言中引入的一种新的语法元素和操作符，这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作符或箭头操作符，它将 Lambda 分为两个部分：<ul>
<li>左侧：指定了 Lambda 表达式需要的参数列表</li>
<li>右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即 Lambda 表达式要执行的功能（其实就是重写的抽象方法的方法体）</li>
</ul>
</li>
<li>语法格式一：无参，无返回值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1=()-&gt;&#123;System.out.println(<span class="string">&quot;Hello Lambdal!&quot;</span>);&#125;;</span><br></pre></td></tr></table></figure></li>
<li>语法格式二：Lambda 需要一个参数，但是没有返回值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con=(String str)-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure></li>
<li>语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断”  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con=(str)-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure></li>
<li>语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;String&gt; con=str-&gt;&#123;System.out.println(str);&#125;;</span><br></pre></td></tr></table></figure></li>
<li>语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com=(x,y)-&gt;&#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;实现函数式接口方法！&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> Integer.compare(x,y);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com=(x,y)-&gt;Integer.compara(x,y);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>语法总结<ul>
<li>左边：lambda 形参列表的参数类型可以省略（类型推断），如果 lambda 形参列表只有一个参数，其一对 () 也可以省略</li>
<li>右边：lambda 体应该使用一对 { } 包裹，如果 lambda 体只有一条执行语句（可能是 return 语句），省略这一对 { } 和 return 关键字</li>
</ul>
</li>
<li>Lambda 表达式的本质：作为函数式接口的实例</li>
<li>如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口，我们可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口</li>
<li>以前用匿名实现类表示的现在都可以用Lambda表达式来写</li>
<li>类型推断<ul>
<li>Lambda 表达式中的参数类型都是由编译器推断得出的，Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型，Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的，这就是所谓的“类型推断”</li>
</ul>
</li>
</ol>
<h3 id="3-函数式（Functional）接口"><a href="#3-函数式（Functional）接口" class="headerlink" title="3.函数式（Functional）接口"></a>3.函数式（Functional）接口</h3><ol>
<li>什么是函数式接口<ul>
<li>只包含一个抽象方法的接口，称为函数式接口</li>
<li>可以通过 Lambda 表达式来创建该接口的对象（若 Lambda 表达式抛出一个受检异常（即：非运行时异常），那么该异常需要在目标接口的抽象方法上进行声明）</li>
<li>可以在一个接口上使用 @FunctionalInterface 注解，这样做可以检查它是否是一个函数式接口，同时 javadoc 也会包含一条声明，说明这个接口是一个函数式接口</li>
<li>在 java.util.function 包下定义了Java8 的丰富的函数式接口</li>
</ul>
</li>
<li>如何理解函数式接口<ul>
<li>Java 从诞生日起就是一直倡导“一切皆对象”，在 Java 里面面向对象（OOP）编程是一切，但是随着 python、scala 等语言的兴起和新技术的挑战，Java 不得不做出调整以便支持更加广泛的技术要求，也即<font color="blue"> java 不但可以支持 OOP 还可以支持 OOF（面向函数编程）</font></li>
<li>在函数式编程语言当中，函数被当做一等公民对待，在将函数作为一等公民的编程语言中，Lambda 表达式的类型是函数，但是在 Java8 中，有所不同，在 Java8 中，Lambda 表达式是对象，而不是函数，它们必须依附于一类特别的对象类型——<font color="blue">函数式接口</font></li>
<li>简单的说，在 Java8 中，<font color="blue">Lambda 表达式就是一个函数式接口的实例</font>，这就是 Lambda 表达式和函数式接口的关系，也就是说，只要一个对象是函数式接口的实例，那么该对象就可以用 Lambda 表达式来表示</li>
<li><font color="blue">所以以前用匿名实现类表示的现在都可以用 Lambda 表达式来写</font></li>
</ul>
</li>
<li>Java 内置四大核心函数式接口<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>Consumer&lt;T&gt;<br />消费型接口</td>
<td>T</td>
<td>void</td>
<td>对类型为 T 的对象应用操作，包含方法：void accept(T t)</td>
</tr>
<tr>
<td>Supplier&lt;T&gt;<br />供给型接口</td>
<td>无</td>
<td>T</td>
<td>返回类型为 T 的对象，包含方法：T get()</td>
</tr>
<tr>
<td>Function&lt;T, R&gt;<br />函数型接口</td>
<td>T</td>
<td>R</td>
<td>对类型为 T 的对象应用操作，并返回结果，结果是 R 类型的对象，包含方法：R apply(T t)</td>
</tr>
<tr>
<td>Predicate&lt;T&gt;<br />断定型接口</td>
<td>T</td>
<td>boolean</td>
<td>确定类型为 T 的对象是否满足某约束，并返回 boolean 值，包含方法：boolean test(T t)</td>
</tr>
</tbody></table>
</li>
<li>其他接口<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>BiFunction&lt;T, U, R&gt;</td>
<td>T, U</td>
<td>R</td>
<td>对类型为 T, U 参数应用操作，返回 R 类型的结果，包含方法为： R apply(T t, U u)</td>
</tr>
<tr>
<td>UnaryOperator&lt;T&gt;<br />（Function子接口）</td>
<td>T</td>
<td>T</td>
<td>对类型为 T 的对象进行一元运算，并返回 T 类型的结果，包含方法为：T apply(T t)</td>
</tr>
<tr>
<td>BinaryOperator&lt;T&gt;<br />（BiFunction 子接口）</td>
<td>T, T</td>
<td>T</td>
<td>对类型为 T 的对象进行二元运算，并返回 T 类型的结果，包含方法为： T apply(T t1, T t2);</td>
</tr>
<tr>
<td>BiConsumer&lt;T, U&gt;</td>
<td>T, U</td>
<td>void</td>
<td>对类型为 T, U 参数应用操作，包含方法为： void accept(T t, U u)</td>
</tr>
<tr>
<td>BiPredicate&lt;T,U&gt;</td>
<td>T,U</td>
<td>boolean</td>
<td>包含方法为： boolean test(T t,U u)</td>
</tr>
<tr>
<td>ToIntFunction&lt;T&gt;<br />ToLongFunction&lt;T&gt;<br />ToDoubleFunction&lt;T&gt;</td>
<td>T</td>
<td>int<br />long<br />double</td>
<td>分别计算 int、long、double 值的函数</td>
</tr>
<tr>
<td>IntFunction&lt;R&gt;<br />LongFunction&lt;R&gt;<br />DoubleFunction&lt;R&gt;</td>
<td>int<br />long<br />double</td>
<td>R</td>
<td>参数分别为 int、long、double 类型的函数</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="4-方法引用与构造器引用"><a href="#4-方法引用与构造器引用" class="headerlink" title="4.方法引用与构造器引用"></a>4.方法引用与构造器引用</h3><ol>
<li>方法引用（Method References）<ol>
<li>使用情境：当要传递给 Lambda 体的操作，已经有实现的方法了，可以使用方法引用</li>
<li>方法引用可以看做是 Lambda 表达式深层次的表达，换句话说，方法引用就是 Lambda 表达式，也就是函数式接口的一个实例，通过方法的名字来指向一个方法，可以认为是 Lambda 表达式的一个语法糖</li>
<li>使用格式：类(或对象) :: 方法名</li>
<li>具体分为如下的三种情况<ul>
<li>对象 :: 非静态方法</li>
<li>对象 :: 非静态方法</li>
<li>类 :: 非静态方法</li>
</ul>
</li>
<li>要求<ul>
<li>要求接口中的抽象方法的形参列表和返回值类型与方法引用的方法的形参列表和返回值类型相同（针对于前两种情况）</li>
</ul>
</li>
<li>示例<ul>
<li>情况一：对象 :: 实例方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Consumer 中的 void accept(T t)</span></span><br><span class="line"><span class="comment"> * PrintStream 中的 void println(T t)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	Consumer&lt;String&gt; con1 = str -&gt; System.out.println(str);</span><br><span class="line">	con1.accept(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">PrintStream</span> <span class="variable">ps</span> <span class="operator">=</span> System.out;</span><br><span class="line">	Consumer&lt;String&gt; con2 = ps::println;</span><br><span class="line">	con2.accept(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 中的 T get()</span></span><br><span class="line"><span class="comment"> * Employee 中的 String getName()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Employee</span> <span class="variable">emp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Supplier&lt;String&gt; sup1 = () -&gt; emp.getName();</span><br><span class="line">	System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	Supplier&lt;String&gt; sup2 = emp::getName;</span><br><span class="line">	System.out.println(sup2.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>情况二：类 :: 静态方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparator 中的 int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment"> * Integer 中的 int compare(T t1,T t2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	Comparator&lt;Integer&gt; com1 = (t1,t2) -&gt; Integer.compare(t1,t2);</span><br><span class="line">	System.out.println(com1.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Comparator&lt;Integer&gt; com2 = Integer::compare;</span><br><span class="line">	System.out.println(com2.compare(<span class="number">12</span>,<span class="number">21</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment"> * Math 中的 Long round(Double d)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	Function&lt;Double,Long&gt; func = <span class="keyword">new</span> <span class="title class_">Function</span>&lt;Double, Long&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="keyword">public</span> Long <span class="title function_">apply</span><span class="params">(Double d)</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> Math.round(d);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Function&lt;Double,Long&gt; func1 = d -&gt; Math.round(d);</span><br><span class="line">	System.out.println(func1.apply(<span class="number">12.3</span>));</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Function&lt;Double,Long&gt; func2 = Math::round;</span><br><span class="line">	System.out.println(func2.apply(<span class="number">12.3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>情况三：类 :: 实例方法（当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数（或无参数）时：ClassName::methodName）（有难度）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Comparator 中的 int comapre(T t1,T t2)</span></span><br><span class="line"><span class="comment"> * String 中的 int t1.compareTo(t2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	Comparator&lt;String&gt; com1 = (s1,s2) -&gt; s1.compareTo(s2);</span><br><span class="line">	System.out.println(com1.compare(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Comparator&lt;String&gt; com2 = String :: compareTo;</span><br><span class="line">	System.out.println(com2.compare(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abd&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BiPredicate 中的 boolean test(T t1, T t2)</span></span><br><span class="line"><span class="comment"> * String 中的 boolean t1.equals(t2)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	BiPredicate&lt;String,String&gt; pre1 = (s1,s2) -&gt; s1.equals(s2);</span><br><span class="line">	System.out.println(pre1.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	BiPredicate&lt;String,String&gt; pre2 = String :: equals;</span><br><span class="line">	System.out.println(pre2.test(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;abc&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment"> * Employee 中的 String getName()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="number">1001</span>, <span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Function&lt;Employee,String&gt; func1 = e -&gt; e.getName();</span><br><span class="line">	System.out.println(func1.apply(employee));</span><br><span class="line"></span><br><span class="line">	System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Function&lt;Employee,String&gt; func2 = Employee::getName;</span><br><span class="line">	System.out.println(func2.apply(employee));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
</li>
<li>构造器引用<ol>
<li>格式：ClassName::new</li>
<li>与函数式接口相结合，自动与函数式接口中方法兼容</li>
<li>可以把构造器引用赋值给定义的方法<ul>
<li>函数式接口的抽象方法的形参列表和构造器的形参列表一致</li>
<li>抽象方法的返回值类型即为构造器所属的类的类型</li>
</ul>
</li>
<li>示例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Supplier 中的 T get()</span></span><br><span class="line"><span class="comment"> * Employee 的空参构造器：Employee()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    Supplier&lt;Employee&gt; sup = <span class="keyword">new</span> <span class="title class_">Supplier</span>&lt;Employee&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Employee <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt;  sup1 = () -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>();</span><br><span class="line">    System.out.println(sup1.get());</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Supplier&lt;Employee&gt;  sup2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">    System.out.println(sup2.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment"> * Employee 的构造器：Employee(int id)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    Function&lt;Integer,Employee&gt; func1 = id -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id);</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> func1.apply(<span class="number">1001</span>);</span><br><span class="line">    System.out.println(employee);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">    <span class="type">Employee</span> <span class="variable">employee1</span> <span class="operator">=</span> func2.apply(<span class="number">1002</span>);</span><br><span class="line">    System.out.println(employee1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * BiFunction 中的 R apply(T t,U u)</span></span><br><span class="line"><span class="comment"> * Employee 的构造器：Employee(int id,String name)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">     BiFunction&lt;Integer,String,Employee&gt; func1 = (id,name) -&gt; <span class="keyword">new</span> <span class="title class_">Employee</span>(id,name);</span><br><span class="line">     System.out.println(func1.apply(<span class="number">1001</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">     BiFunction&lt;Integer,String,Employee&gt; func2 = Employee :: <span class="keyword">new</span>;</span><br><span class="line">     System.out.println(func2.apply(<span class="number">1002</span>,<span class="string">&quot;Tom&quot;</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>数组引用<ol>
<li>格式：type[ ] :: new</li>
<li>把数组看做是一个特殊的类，写法与构造器引用一致</li>
<li>示例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Function 中的 R apply(T t)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    Function&lt;Integer,String[]&gt; func1 = length -&gt; <span class="keyword">new</span> <span class="title class_">String</span>[length];</span><br><span class="line">    String[] arr1 = func1.apply(<span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*******************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Function&lt;Integer,String[]&gt; func2 = String[] :: <span class="keyword">new</span>;</span><br><span class="line">    String[] arr2 = func2.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="5-强大的-Stream-API"><a href="#5-强大的-Stream-API" class="headerlink" title="5.强大的 Stream API"></a>5.强大的 Stream API</h3><ol>
<li>Stream API 说明<ul>
<li>Java8 中有两大最为重要的改变，第一个是 Lambda 表达式，另外一个则是 Stream API</li>
<li>关系型数据库（Mysql、Oracle）可以在数据库层面处理数据，而非关系型数据库（MongDB、Redis）的数据就需要 Java 层面去处理</li>
<li>Stream 和 Collection 集合的区别<ul>
<li>Stream 关注的是对数据的运算，与 CPU 打交道</li>
<li>Collection 关注的是数据的存储，与内存打交道</li>
</ul>
</li>
</ul>
</li>
<li>注意点<ul>
<li>Stream 自己不会存储元素</li>
<li>Stream 不会改变源对象，相反，他们会返回一个持有结果的新 Stream</li>
<li>Stream 操作是延迟执行的，这意味着他们会等到需要结果的时候才执行</li>
</ul>
</li>
<li>Stream 执行流程<ul>
<li>Stream 的实例化<ul>
<li>一个数据源（如：集合、数组），获取一个流</li>
</ul>
</li>
<li>中间操作<ul>
<li>一系列的中间操作，对数据源的数据进行处理（过滤、映射、…）</li>
</ul>
</li>
<li>终止操作<ul>
<li>一旦执行终止操作，就执行中间操作链，并产生结果，之后，不会再被使用</li>
<li>图示<br><img src="https://img-blog.csdnimg.cn/4e4692d058f64b52ab543b061549eb57.png" alt="在这里插入图片描述"></li>
</ul>
</li>
</ul>
</li>
<li>Stream 的实例化<ul>
<li>创建 Stream 方式一：通过集合  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 中的 Collection 接口被扩展，提供了两个获取流的方法</span></span><br><span class="line"><span class="comment"> * 		default Stream&lt;E&gt; stream() : 返回一个顺序流</span></span><br><span class="line"><span class="comment"> * 		default Stream&lt;E&gt; parallelStream() : 返回一个并行流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; stream = list.stream();</span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; parallelStream = list.parallelStream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建 Stream 方式二：通过数组  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Java8 中的 Arrays 的静态方法 stream() 可以获取数组流</span></span><br><span class="line"><span class="comment"> * 		static &lt;T&gt; Stream&lt;T&gt; stream(T[] array): 返回一个流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="type">IntStream</span> <span class="variable">stream</span> <span class="operator">=</span> Arrays.stream(arr);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>创建 Stream 方式三：通过 Stream 的 of()  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以调用 Stream 类静态方法 of(), 通过显示值创建一个流，它可以接收任意数量的参数</span></span><br><span class="line"><span class="comment"> * 		public static&lt;T&gt; Stream&lt;T&gt; of(T... values) : 返回一个流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建 Stream 方式四：创建无限流  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以使用静态方法 Stream.iterate() 和 Stream.generate()，创建无限流</span></span><br><span class="line"><span class="comment"> * 		迭代</span></span><br><span class="line"><span class="comment"> * 			public static&lt;T&gt; Stream&lt;T&gt; iterate(final T seed, final UnaryOperator&lt;T&gt; f) </span></span><br><span class="line"><span class="comment"> * 		生成</span></span><br><span class="line"><span class="comment"> * 			public static&lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s) </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 遍历前 10 个偶数</span></span><br><span class="line">    Stream.iterate(<span class="number">0</span>, t -&gt; t + <span class="number">2</span>).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 10 个随机数</span></span><br><span class="line">    Stream.generate(Math::random).limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>Stream 的中间操作<ul>
<li>说明<ul>
<li>多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理，而在终止操作时一次性全部处理，称为“惰性求值”</li>
</ul>
</li>
<li>筛选与切片<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</td>
<td>接收 Lambda ， 从流中排除某些元素</td>
</tr>
<tr>
<td>Stream&lt;T&gt; limit(long maxSize)</td>
<td>截断流，使其元素不超过给定数量</td>
</tr>
<tr>
<td>Stream&lt;T&gt; skip(long n)</td>
<td>跳过元素，返回一个扔掉了前 n 个元素的流，若流中元素不足 n 个，则返回一个空流，与 limit(n) 互补</td>
</tr>
<tr>
<td>Stream&lt;T&gt; distinct()</td>
<td>筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个包含多个 Employee 对象的集合，该方法为自定义</span></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// filter(Predicate p)——接收 Lambda ， 从流中排除某些元素</span></span><br><span class="line">    <span class="comment">// 查询员工表中薪资大于 7000 的员工信息</span></span><br><span class="line">    list.stream().filter(e -&gt; e.getSalary() &gt;<span class="number">7000</span>).forEach(System.out::println);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// limit(n)——截断流，使其元素不超过给定数量。</span></span><br><span class="line">    list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip(n) —— 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流，与 limit(n) 互补</span></span><br><span class="line">    list.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// distinct()——筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素</span></span><br><span class="line">    list.stream().distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>映射<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><font color="red"><R> Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</font></td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素</td>
</tr>
<tr>
<td><font color="red"><R> Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper)</font></td>
<td>接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</td>
</tr>
<tr>
<td>DoubleStream mapToDouble(ToDoubleFunction&lt;? super T&gt; mapper)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream</td>
</tr>
<tr>
<td>IntStream mapToInt(ToIntFunction&lt;? super T&gt; mapper)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream</td>
</tr>
<tr>
<td>LongStream mapToLong(ToLongFunction&lt;? super T&gt; mapper)</td>
<td>接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream</td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// map(Function f)——接收一个函数作为参数，将元素转换成其他形式或提取信息，该函数会被应用到每个元素上，并将其映射成一个新的元素</span></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;dd&quot;</span>);</span><br><span class="line">    list.stream().map(str -&gt; str.toUpperCase()).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个包含多个 Employee 对象的集合，该方法为自定义</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习1：获取员工姓名长度大于 3 的员工的姓名</span></span><br><span class="line">    employees.stream().map(Employee::getName).filter(name -&gt; name.length() &gt;<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 练习2：对比 map 与 flatMap(Function f) 的区别，为此定义了 fromStringToStream 函数来使一维集合转为二维集合（StreamAPITest 为该类的名称）</span></span><br><span class="line">    Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream().map(StreamAPITest::fromStringToStream);</span><br><span class="line">    streamStream.forEach(s -&gt;&#123;</span><br><span class="line">        s.forEach(System.out::println);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// flatMap(Function f)——接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流</span></span><br><span class="line">    Stream&lt;Character&gt; characterStream = list.stream().flatMap(StreamAPITest::fromStringToStream);</span><br><span class="line">    characterStream.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串中的多个字符构成的集合转换为对应的 Stream 的实例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Stream&lt;Character&gt; <span class="title function_">fromStringToStream</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Character c : str.toCharArray())&#123;</span><br><span class="line">        list.add(c);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">return</span> list.stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>排序<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Stream&lt;T&gt; sorted()</td>
<td>产生一个新流，其中按自然顺序排序</td>
</tr>
<tr>
<td>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</td>
<td>产生一个新流，其中按比较器顺序排序</td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// sorted()——自然排序</span></span><br><span class="line">    List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">43</span>, <span class="number">65</span>, <span class="number">34</span>, <span class="number">87</span>, <span class="number">0</span>, -<span class="number">98</span>, <span class="number">7</span>);</span><br><span class="line">    list.stream().sorted().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个包含多个 Employee 对象的集合，该方法为自定义</span></span><br><span class="line">    List&lt;Employee&gt; employees = EmployeeData.getEmployees();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sorted(Comparator com)——定制排序</span></span><br><span class="line">    employees.stream().sorted( (e1,e2) -&gt; &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">ageValue</span> <span class="operator">=</span> Integer.compare(e1.getAge(),e2.getAge());</span><br><span class="line">       <span class="keyword">if</span>(ageValue != <span class="number">0</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> ageValue;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span> -Double.compare(e1.getSalary(),e2.getSalary());</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li>Stream 的终止操作<ul>
<li>说明<ul>
<li>终端操作会从流的流水线生成结果，其结果可以是任何不是流的值，例如：List、Integer，甚至是 void</li>
<li>流进行了终止操作后，不能再次使用</li>
</ul>
</li>
<li>匹配与查找<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean allMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>检查是否匹配所有元素</td>
</tr>
<tr>
<td>boolean anyMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>检查是否至少匹配一个元素</td>
</tr>
<tr>
<td>boolean noneMatch(Predicate&lt;? super T&gt; predicate)</td>
<td>检查是否没有匹配所有元素</td>
</tr>
<tr>
<td>Optional&lt;T&gt; findFirst()</td>
<td>返回第一个元素</td>
</tr>
<tr>
<td>Optional&lt;T&gt; findAny()</td>
<td>返回当前流中的任意元素</td>
</tr>
<tr>
<td>long count()</td>
<td>返回流中元素总数</td>
</tr>
<tr>
<td>Optional&lt;T&gt; max(Comparator&lt;? super T&gt; comparator)</td>
<td>返回流中最大值</td>
</tr>
<tr>
<td>Optional&lt;T&gt; min(Comparator&lt;? super T&gt; comparator)</td>
<td>返回流中最小值</td>
</tr>
<tr>
<td>void forEach(Consumer&lt;? super T&gt; action)</td>
<td>内部迭代（使用 Collection 接口需要用户去做迭代，称为外部迭代，相反，Stream API 使用内部迭代——它帮你把迭代做了）</td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个包含多个 Employee 对象的集合，该方法为自定义</span></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allMatch(Predicate p)——检查是否匹配所有元素</span></span><br><span class="line">    <span class="comment">// 练习：是否所有的员工的年龄都大于 18</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">allMatch</span> <span class="operator">=</span> list.stream().allMatch(e -&gt; e.getAge() &gt; <span class="number">18</span>);</span><br><span class="line">    System.out.println(allMatch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// anyMatch(Predicate p)——检查是否至少匹配一个元素</span></span><br><span class="line">    <span class="comment">// 练习：是否存在员工的工资大于 10000</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">anyMatch</span> <span class="operator">=</span> list.stream().anyMatch(e -&gt; e.getSalary() &gt; <span class="number">10000</span>);</span><br><span class="line">    System.out.println(anyMatch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// noneMatch(Predicate p)——检查是否没有匹配的元素</span></span><br><span class="line">    <span class="comment">// 练习：是否存在员工姓“雷”</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">noneMatch</span> <span class="operator">=</span> list.stream().noneMatch(e -&gt; e.getName().startsWith(<span class="string">&quot;雷&quot;</span>));</span><br><span class="line">    System.out.println(noneMatch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// findFirst——返回第一个元素</span></span><br><span class="line">    Optional&lt;Employee&gt; findFirst = list.stream().findFirst();</span><br><span class="line">    System.out.println(findFirst);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// findAny——返回当前流中的任意元素</span></span><br><span class="line">    Optional&lt;Employee&gt; findAny = list.parallelStream().findAny();</span><br><span class="line">    System.out.println(findAny);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// count——返回流中元素的总个数</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> list.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">5000</span>).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// max(Comparator c)——返回流中最大值</span></span><br><span class="line">    <span class="comment">// 练习：返回最高的工资</span></span><br><span class="line">    Optional&lt;Double&gt; maxSalary = list.stream().map(e -&gt; e.getSalary()).max(Double::compare);</span><br><span class="line">    System.out.println(maxSalary);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// min(Comparator c)——返回流中最小值</span></span><br><span class="line">    <span class="comment">// 练习：返回最低工资的员工</span></span><br><span class="line">    Optional&lt;Employee&gt; minEmployee = list.stream().min((e1, e2) -&gt; Double.compare(e1.getSalary(), e2.getSalary()));</span><br><span class="line">    System.out.println(minEmployee);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// forEach(Consumer c)——内部迭代</span></span><br><span class="line">    list.stream().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用集合的遍历操作</span></span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>归约（map 和 reduce 的连接通常称为 map-reduce 模式，因 Google 用它来进行网络搜索而出名）<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</td>
<td>可以将流中元素反复结合起来，得到一个值，返回 T</td>
</tr>
<tr>
<td>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</td>
<td>可以将流中元素反复结合起来，得到一个值，返回 Optional&lt;T&gt;</td>
</tr>
<tr>
<td><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// reduce(T identity, BinaryOperator)——可以将流中元素反复结合起来，得到一个值，返回 T</span></span><br><span class="line">    <span class="comment">// 练习1：计算 1-10 的自然数的和</span></span><br><span class="line">    List&lt;Integer&gt; nums = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> nums.stream().reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取一个包含多个 Employee 对象的集合，该方法为自定义</span></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// reduce(BinaryOperator) ——可以将流中元素反复结合起来，得到一个值，返回 Optional&lt;T&gt;</span></span><br><span class="line">    <span class="comment">// 练习2：计算公司所有员工工资的总和</span></span><br><span class="line">    Stream&lt;Double&gt; salaryStream = list.stream().map(Employee::getSalary);</span><br><span class="line">    <span class="comment">// Optional&lt;Double&gt; sumMoney = salaryStream.reduce(Double::sum);</span></span><br><span class="line">    Optional&lt;Double&gt; sumMoney = salaryStream.reduce((d1,d2) -&gt; d1 + d2);</span><br><span class="line">    System.out.println(sumMoney.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
</tbody></table>
</li>
<li>收集<table>
<thead>
<tr>
<th>方法</th>
<th>欧明</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector)</td>
<td>将流转换为其他形式。接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法</td>
</tr>
</tbody></table>
<ul>
<li>Collector 接口中方法的实现决定了如何对流执行收集的操作（如收集到 List、Set、Map）</li>
<li>Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 获取一个包含多个 Employee 对象的集合，该方法为自定义</span></span><br><span class="line">    List&lt;Employee&gt; list = EmployeeData.getEmployees();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect(Collector c)——将流转换为其他形式，接收一个 Collector 接口的实现，用于给 Stream 中元素做汇总的方法</span></span><br><span class="line">    <span class="comment">// 练习1：查找工资大于6000的员工，结果返回为一个List或Set</span></span><br><span class="line">    List&lt;Employee&gt; employeeList = list.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toList());</span><br><span class="line">    employeeList.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Set&lt;Employee&gt; employeeSet = list.stream().filter(e -&gt; e.getSalary() &gt; <span class="number">6000</span>).collect(Collectors.toSet());</span><br><span class="line">    employeeSet.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>Collectors 类<table>
<thead>
<tr>
<th>方法（均为静态方法）</th>
<th>返回类型</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><font color="red">toList</font></td>
<td>List&lt;T&gt;</td>
<td>List&lt;Employee&gt; emps&#x3D; list.stream().collect(Collectors.toList());</td>
<td>把流中元素收集到 List</td>
</tr>
<tr>
<td><font color="red">toSet</font></td>
<td>Set&lt;T&gt;</td>
<td>Set&lt;Employee&gt; emps&#x3D; list.stream().collect(Collectors.toSet());</td>
<td>把流中元素收集到 Set</td>
</tr>
<tr>
<td><font color="red">toCollection</font></td>
<td>Collection&lt;T&gt;</td>
<td>Collection&lt;Employee&gt; emps &#x3D;list.stream().collect(Collectors.toCollection(ArrayList::new));</td>
<td>把流中元素收集到创建的集合</td>
</tr>
<tr>
<td>counting</td>
<td>Long</td>
<td>long count &#x3D; list.stream().collect(Collectors.counting());</td>
<td>计算流中元素的个数</td>
</tr>
<tr>
<td>summingInt</td>
<td>Integer</td>
<td>int total&#x3D;list.stream().collect(Collectors.summingInt(Employee::getSalary));</td>
<td>对流中元素的整数属性求和</td>
</tr>
<tr>
<td>averagingInt</td>
<td>Double</td>
<td>double avg &#x3D; list.stream().collect(Collectors.averagingInt(Employee::getSalary));</td>
<td>计算流中元素 Integer 属性的平均值</td>
</tr>
<tr>
<td>summarizingInt</td>
<td>IntSummaryStatistics</td>
<td>int SummaryStatisticsiss&#x3D; list.stream().collect(Collectors.summarizingInt(Employee::getSalary));</td>
<td>收集流中 Integer 属性的统计值，如：平均值</td>
</tr>
<tr>
<td>joining</td>
<td>String</td>
<td>String str&#x3D; list.stream().map(Employee::getName).collect(Collectors.joining());</td>
<td>连接流中每个字符串</td>
</tr>
<tr>
<td>maxBy</td>
<td>Optional&lt;T&gt;</td>
<td>Optional&lt;Emp&gt; max&#x3D; list.stream().collect(Collectors.maxBy(comparingInt(Employee::getSalary)));</td>
<td>根据比较器选择最大值</td>
</tr>
<tr>
<td>minBy</td>
<td>Optional&lt;T&gt;</td>
<td>Optional&lt;Emp&gt; min &#x3D; list.stream().collect(Collectors.minBy(comparingInt(Employee::getSalary)));</td>
<td>根据比较器选择最小值</td>
</tr>
<tr>
<td>reducing</td>
<td>归约产生的类型</td>
<td>int total&#x3D;list.stream().collect(Collectors.reducing(0, Employee::getSalar, Integer::sum));</td>
<td>从一个作为累加器的初始值开始，利用 BinaryOperator 与流中元素逐个结合，从而归约成单个值</td>
</tr>
<tr>
<td>collectingAndThen</td>
<td>转换函数返回的类型</td>
<td>int how&#x3D; list.stream().collect(Collectors.collectingAndThen(Collectors.toList(), List::size));</td>
<td>包裹另一个收集器，对其结果转换函数</td>
</tr>
<tr>
<td>groupingBy</td>
<td>Map&lt;K, List&lt;T&gt;&gt;</td>
<td>Map&lt;Emp.Status, List&lt;Emp&gt;&gt; map&#x3D; list.stream().collect(Collectors.groupingBy(Employee::getStatus));</td>
<td></td>
</tr>
<tr>
<td>partitioningBy</td>
<td>Map&lt;Boolean, List&lt;T&gt;&gt;</td>
<td>Map&lt;Boolean,List&lt;Emp&gt;&gt; vd &#x3D; list.stream().collect(Collectors.partitioningBy(Employee::getManage));</td>
<td>根据 true 或 false 进行分区</td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="6-Optional-类"><a href="#6-Optional-类" class="headerlink" title="6.Optional 类"></a>6.Optional 类</h3><ol>
<li>作用：为了在程序中避免出现空指针异常而创建的</li>
<li>Optional<T> 类（java.util.Optional）是一个容器类，它可以保存类型T的值，代表这个值存在，或者仅仅保存 null ，表示这个值不存在，原来用 null 表示一个值不存在，现在 Optional 可以更好的表达这个概念，并且可以避免空指针异常</li>
<li>在 Javadoc 描述如下：这是一个可以为 null 的容器对象，如果值存在则 isPresent() 方法会返回 true ，调用 get() 方法会返回该对象</li>
<li>Optional 类提供很多有用的方法，这样我们就不用显式进行空值检测</li>
<li>创建 Optional 类对象<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Optional.of(T t)</td>
<td>创建一个 Optional 实例，<font color="blue">t 必须非空</font></td>
</tr>
<tr>
<td><font color="red">Optional.ofNullable(T t)</font></td>
<td><font color="blue">t 可以为 nul</font></td>
</tr>
<tr>
<td>Optional.empty()</td>
<td>创建一个空的 Optional 实例</td>
</tr>
</tbody></table>
</li>
<li>判断 Optional 容器中是否包含对象<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>boolean isPresent()</td>
<td>判断是否包含对象</td>
</tr>
<tr>
<td>void ifPresent(Consumer&lt;? super T&gt; consumer)</td>
<td>如果有值，就执行 Consumer 接口的实现代码，并且该值会作为参数传给它</td>
</tr>
</tbody></table>
</li>
<li>获取 Optional 容器的对象<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>T get()</td>
<td>如果调用对象包含值，返回该值，否则抛异常</td>
</tr>
<tr>
<td><font color="red">T orElse(T other) </font></td>
<td>如果单前的 Optional 内部封装的 t 是非空的，则返回内部的 t，如果内部的 t 是空的，则返回 orElse() 方法中的参数 t1</td>
</tr>
<tr>
<td>T orElseGet(Supplier&lt;? extends T&gt; other)</td>
<td>如果有值则将其返回，否则返回由 Supplier 接口实现提供的对象</td>
</tr>
<tr>
<td>T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</td>
<td>如果有值则将其返回，否则抛出由 Supplier 接口实现提供的异常</td>
</tr>
</tbody></table>
</li>
<li>示例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gil 对象是一个 JavaBean 对象，属性为 String name</span></span><br><span class="line"><span class="comment"> * Boy 对象是一个 JavaBean 对象，属性为 Girl girlFriend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用 Optional 类的 getGirlName()</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getGirlName2</span><span class="params">(Boy boy)</span>&#123;</span><br><span class="line">     Optional&lt;Boy&gt; boyOptional = Optional.ofNullable(boy);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 此时的 boyNotNull 一定非空</span></span><br><span class="line">     <span class="type">Boy</span> <span class="variable">boyNotNull</span> <span class="operator">=</span> boyOptional.orElse(<span class="keyword">new</span> <span class="title class_">Boy</span>(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;迪丽热巴&quot;</span>)));</span><br><span class="line"></span><br><span class="line">     <span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> boyNotNull .getGirl();</span><br><span class="line">     Optional&lt;Girl&gt; girlOptional = Optional.ofNullable(girl);</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 此时的 girlNotNull 一定非空</span></span><br><span class="line">     <span class="type">Girl</span> <span class="variable">girlNotNull</span> <span class="operator">=</span> girlOptional.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;古力娜扎&quot;</span>));</span><br><span class="line">     <span class="keyword">return</span> girlNotNull.getName();</span><br><span class="line"> &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">	Optional&lt;Girl&gt; girl= Optional.ofNullable(boy.getGrilFriend());</span><br><span class="line">	<span class="comment">// 如果 Girl 对象存在，就打印 Girl 对象的信息</span></span><br><span class="line">	girl.ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">Boy</span> <span class="variable">boy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Boy</span>();</span><br><span class="line">	Optional&lt;Girl&gt; opt = Optional.ofNullable(boy.getGrilFriend());</span><br><span class="line">	<span class="comment">// 如果有 Girl 对象就返回 Girl 对象，否则创建另外一个 Girl 对象</span></span><br><span class="line">	<span class="type">Girl</span> <span class="variable">girl</span> <span class="operator">=</span> opt.orElse(<span class="keyword">new</span> <span class="title class_">Girl</span>(<span class="string">&quot;嫦娥&quot;</span>));</span><br><span class="line">	System.out.println(<span class="string">&quot;他的女朋友是：&quot;</span> + girl.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Employee 是一个 JavaBean 对象，其有两个属性</span></span><br><span class="line"><span class="comment"> * 		姓名：String name</span></span><br><span class="line"><span class="comment"> * 		工资：Double salary</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">	<span class="comment">//判断opt中员工对象是否满足条件，如果满足就保留，否则返回空</span></span><br><span class="line">	Optional&lt;Employee&gt; emp = opt.filter(e -&gt; e.getSalary()&gt;<span class="number">10000</span>);</span><br><span class="line">	System.out.println(emp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">	Optional&lt;Employee&gt; opt = Optional.of(<span class="keyword">new</span> <span class="title class_">Employee</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">8888</span>));</span><br><span class="line">	<span class="comment">//如果 opt 中员工对象不为空，就涨薪10%</span></span><br><span class="line">	Optional&lt;Employee&gt; emp = opt.map(e -&gt;&#123;</span><br><span class="line">		e.setSalary(e.getSalary()%<span class="number">1.1</span>);</span><br><span class="line">		<span class="keyword">return</span> e;</span><br><span class="line">	&#125;);</span><br><span class="line">	System.out.println(emp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2023/02/25/Java%20%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2023/02/25/Java%20%E9%AB%98%E7%BA%A7%E9%83%A8%E5%88%86/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
