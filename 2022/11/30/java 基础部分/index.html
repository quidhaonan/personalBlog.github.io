<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Liu Mingyang's personal blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >Java 基础部分</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a><center>Java</center></h1><p>@[TOC]</p>
<h2 id="一-语言环境与开发工具"><a href="#一-语言环境与开发工具" class="headerlink" title="一 语言环境与开发工具"></a>一 语言环境与开发工具</h2><h3 id="1-了解-Java-的语言背景"><a href="#1-了解-Java-的语言背景" class="headerlink" title="1.了解 Java 的语言背景"></a>1.了解 Java 的语言背景</h3><ol>
<li>Java（ 1995年诞生，James Cosling ）</li>
<li>三个版本：<ul>
<li>JavaSE（标准版本）</li>
<li>JavaEE（企业版本）</li>
<li>JavaME（微型版本）</li>
</ul>
</li>
<li>Java 语言特点：跨平台性<ul>
<li>编写一个程序，只需要一次的编译，就能够在各大平台运行。（一次编译，到处运行）</li>
</ul>
</li>
</ol>
<h3 id="2-掌握搭建-Java-开发环境"><a href="#2-掌握搭建-Java-开发环境" class="headerlink" title="2.掌握搭建 Java 开发环境"></a>2.掌握搭建 Java 开发环境</h3><p><img src="https://img-blog.csdnimg.cn/e797852b98304dc1a051c129374bb004.png" alt="在这里插入图片描述"></p>
<ol>
<li>Java 的源程序：xx.java<ul>
<li>编译：可以用 javac.exe 来编译（安装了 JDK 以后就会有 javac 这个程序）</li>
<li>执行：可以用 java.exe 来编译（安装了 JDK 以后就会有 java 这个程序）</li>
</ul>
</li>
<li>Java 开发环境<ul>
<li>记事本+JDK</li>
<li>idea &#x2F; eclipse &#x2F; myeclipse</li>
</ul>
</li>
<li>安装 JDK<ul>
<li>找到 JDK 的安装文件<br> <img src="https://img-blog.csdnimg.cn/034d158d33c443ba9bc4a804ccd4ada8.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>配置环境变量<br><img src="https://img-blog.csdnimg.cn/43af6c6959a841ff8e16fa92592188e4.png" alt="在这里插入图片描述"><br> 需要在电脑的任意目录都能够找到 javac.exe 这个程序，只能通过配置环境变量来实现<ul>
<li>path：记录了我们 windows 能够处理的程序的路径<br> <img src="https://img-blog.csdnimg.cn/f83d9a904a624799a21e50d30d68c404.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>JAD 软件：可以将 xxx.class -&gt; xx.java</li>
</ol>
<h3 id="3-了解-Java-程序结构，并能够开发-Java-程序"><a href="#3-了解-Java-程序结构，并能够开发-Java-程序" class="headerlink" title="3.了解 Java 程序结构，并能够开发 Java 程序"></a>3.了解 Java 程序结构，并能够开发 Java 程序</h3><h3 id="4-掌握-JDK，JRE，JVM-等常用概念"><a href="#4-掌握-JDK，JRE，JVM-等常用概念" class="headerlink" title="4.掌握 JDK，JRE，JVM 等常用概念"></a>4.掌握 JDK，JRE，JVM 等常用概念</h3><ol>
<li>JDK：java development took kit（ Java 开发工具包 ），安装以后可以用来开发 Java 程序，还可以执行 Java 程序</li>
<li>JRE：Java 的运行环境（里面包含有 JVM ）</li>
</ol>
<h2 id="二-变量，数据类型和运算符"><a href="#二-变量，数据类型和运算符" class="headerlink" title="二 变量，数据类型和运算符"></a>二 变量，数据类型和运算符</h2><h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1.变量"></a>1.变量</h3><ol>
<li>3.14（常量）</li>
<li>x：变量 x+y&#x3D;20，x-y&#x3D;10<br> x+y&#x3D;20,x&#x3D;1,2,3,4,5,6,7,8,9…，y&#x3D;19,18,17,16…</li>
<li>计算机中的变量<ul>
<li>数据存放到计算机中，就是需要一个存储的空间（磁盘（具备持久性），内存（临时的））</li>
<li>变量：就会计算中的内存的一个区域，作用就是为了存放临时数据</li>
<li>变量名：通过变量名去找内存区域</li>
<li>变量类型</li>
</ul>
</li>
</ol>
<h3 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2.数据类型"></a>2.数据类型</h3><p>8种基本的数据类型</p>
<table>
<thead>
<tr>
<th>数据类型名</th>
<th>长度</th>
<th>范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1 byte（8个二进制位）</td>
<td>-158~127</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>2 byte</td>
<td>-32768~32767</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>4 byte</td>
<td>-2,147,483,648~2,147,483,647</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>8 byte</td>
<td></td>
<td>0</td>
</tr>
<tr>
<td>float</td>
<td>4 byte</td>
<td>2^128</td>
<td>0.0f</td>
</tr>
<tr>
<td>double</td>
<td>8 byte</td>
<td>2^1024</td>
<td>0.0d</td>
</tr>
<tr>
<td>char</td>
<td>2 byte</td>
<td></td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>boolean</td>
<td>1 byte</td>
<td></td>
<td>false</td>
</tr>
</tbody></table>
<ol>
<li>整数类型：byte &gt; short &gt; int &gt; long<ul>
<li>l &#x2F; L 表示 long 类型</li>
</ul>
</li>
<li>浮点类型（小数类型）<ul>
<li>float </li>
<li>double</li>
</ul>
</li>
<li>字符类型<ul>
<li><p>char</p>
<pre><code>  计算机是无法表示字符的
  人们就是发明了一种字符和数字的对应关系
  65 -&gt; A
  66 -&gt; B
  97 -&gt; a
  从而形成一种编码，最早的编码就是 ASCII 编码
  因为 ASCII 编码存放不了中文，就出现了 GBK，GB2312，UTF-8 等编码，能够存放中文，以及阿拉伯文等世界上的各种语言
</code></pre>
</li>
</ul>
</li>
<li>布尔类型<ul>
<li>boolean<ul>
<li>true&#x2F;false：真&#x2F;假</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3.运算符"></a>3.运算符</h3><ol>
<li>赋值运算符<ul>
<li>&#x3D; , +&#x3D; , -&#x3D; , *&#x3D; , &#x2F;&#x3D; , %&#x3D;</li>
</ul>
</li>
<li>算术运算符<ul>
<li><p>+ , - , * , &#x2F; , % , ++ , –</p>
<pre><code>  i++;
  ++i;
  
  当单独使用的时候，++i，i++：都等同于 i=i+1
  
  当组合使用的时候：
      int i=12;
      int c=i++;
      首先执行赋值操作，将 i 的值赋值给 c ，然后执行 i++
      c：12
      
      int i=12;
      int c=++i;
      首先执行 ++ 操作，然后执行赋值操作
      c：13
</code></pre>
</li>
</ul>
</li>
<li>关系运算符<ul>
<li>&gt; , &lt; , &#x3D;&#x3D; , &gt;&#x3D; , &lt;&#x3D; , !&#x3D;<br>  返回的结果只有 true&#x2F;false</li>
</ul>
</li>
<li>逻辑运算符<ul>
<li>&amp;&amp; , || , !</li>
</ul>
</li>
<li>位运算符<ul>
<li>&gt;&gt; , &lt;&lt; , &amp; , | , ^ , ~<ul>
<li>&gt;&gt; , &lt;&lt; ：可以对一个数进行乘除法，使用移位，绕过了 jvm 的乘法指令，速度快（先将一个数转化为二进制，然后进行移动）</li>
<li>&amp; ：按位与<br>  同为 1 ，则结果为 1</li>
<li>| ：按位或<br>  只要有一个 1 ，则结果为 1</li>
<li>^ ：按位异或<br>  同则为 0 ，不同则为 1</li>
<li>~ ：按位取反</li>
</ul>
</li>
</ul>
</li>
<li>三元运算符<br> 判断条件?表达式1:表达式2;</li>
</ol>
<h3 id="4-程序逻辑"><a href="#4-程序逻辑" class="headerlink" title="4.程序逻辑"></a>4.程序逻辑</h3><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/UGc9xpTjWLL">Java基础语法（讲课笔记）.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/BjANQksqQmw">第四章 程序入门之复杂选择结构.pptx</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/BAf77z7uoVJ">第五章 程序入门之循环结构（一）.pptx</a></td>
</tr>
</tbody></table>
<ol>
<li>顺序结构</li>
<li>分支结构<ul>
<li>单独分支<ul>
<li>if…else</li>
</ul>
</li>
<li>多分支<ul>
<li>if…else if…else if…else</li>
</ul>
</li>
<li>switch…case<ul>
<li>switch(变量)<br>  变量：int,short,byte,char,String,枚举类型( enum )</li>
</ul>
</li>
</ul>
</li>
<li>循环结构<ul>
<li>循环的含义：重复地完成固定的事情</li>
<li>循环的四要素：<ul>
<li>初始化条件</li>
<li>循环条件——&gt;是 boolean 类型</li>
<li>循环体</li>
<li>迭代条件</li>
</ul>
</li>
<li>循环的基本结构<ul>
<li><p>for 循环</p>
<pre><code>  for(int i=0;i&lt;10;i++)&#123;
      循环体;
  &#125;
  
  i：循环变量
  i++：迭代条件
  i 的作用：控制循环体执行的次数
</code></pre>
</li>
<li><p>while 循环</p>
</li>
<li><p>do…while 循环</p>
</li>
<li><p>for…each 循环（处理数组的）</p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="三-Java-方法（函数）"><a href="#三-Java-方法（函数）" class="headerlink" title="三 Java 方法（函数）"></a>三 Java 方法（函数）</h2><ol>
<li><p>方法介绍</p>
<ul>
<li>方法=&#x3D;函数&#x3D;&#x3D;一个功能  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;字符串&quot;</span>);	<span class="comment">// 能够输出一个字符串的值在控制台上</span></span><br><span class="line"><span class="type">int</span> n=random.nextInt(<span class="number">10</span>);	<span class="comment">// 能够产生一个 10 以内的随机数，还能将这个随机数返回给 n 变量</span></span><br></pre></td></tr></table></figure></li>
<li>一个方法&#x3D;&#x3D;一个功能  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这也是一个方法==函数</span></span><br><span class="line"><span class="comment">// 这个方法是系统的默认方法，当程序运行的时候自动的会去调用这个方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>当程序需要实现一个项目的时候，系统的功能就比较多。此时需要将系统按照功能模块进行划分，每个小功能就可以编写为一个方法</li>
</ul>
</li>
<li><p>方法定义</p>
<pre><code> 修饰符( public static ) 返回类型(void,int...) 方法名(参数)&#123;
     方法体;
 &#125;
</code></pre>
</li>
<li><p>方法调用</p>
<ul>
<li>在别的方法中书写方法的名称就可以调用了。例如：方法名();</li>
</ul>
</li>
<li><p>方法的参数</p>
</li>
<li><p>方法的返回值</p>
</li>
<li><p>递归调用</p>
<ul>
<li>自己调用自己</li>
</ul>
</li>
</ol>
<h2 id="四-Java-数组"><a href="#四-Java-数组" class="headerlink" title="四 Java 数组"></a>四 Java 数组</h2><h3 id="1-数组的作用"><a href="#1-数组的作用" class="headerlink" title="1.数组的作用"></a>1.数组的作用</h3><ol>
<li>当我们需要定义多个相同类型的变量的时候，常规定义就有问题，很难定义，即使你定义了，也很难操作</li>
<li>我们可以使用数组来解决，数组就是一个连续的内存空间</li>
</ol>
<h3 id="2-数组的定义"><a href="#2-数组的定义" class="headerlink" title="2.数组的定义"></a>2.数组的定义</h3><p><img src="https://img-blog.csdnimg.cn/f23434d38e0641aba3bbdf661718a542.png" alt="在这里插入图片描述"></p>
<ol>
<li><p>声明数组</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] a;</span><br></pre></td></tr></table></figure></li>
<li><p>分配空间</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];	<span class="comment">// 占 40 byte</span></span><br></pre></td></tr></table></figure></li>
<li><p>向数组的元素赋值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>]=<span class="number">100</span>;</span><br><span class="line">a[<span class="number">1</span>]=<span class="number">200</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>对数组中的元素做一些操作</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[<span class="number">0</span>]=a[<span class="number">0</span>]%<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>数组中的常用定义方法</p>
<pre><code> 变量名[] 数组名=new 变量名[数组的长度];
 
 int[] arr=new int[10];
 int[] arr=new int[]&#123;1,2,3,4,5&#125;;
 int[] arr=&#123;1,2,3,4,5&#125;;
 
 String[] menus=&#123;
     &quot;1.用户管理&quot;,
     &quot;2.产品管理&quot;,
     &quot;3.订单管理&quot;
 &#125;;
 
 int[] arr2;
 arr2=new int[5];
</code></pre>
</li>
<li><p>数组的内存分配图<br> <img src="https://img-blog.csdnimg.cn/adf6f5c837064da681760f6a3107ac35.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<h3 id="3-数组的常用算法"><a href="#3-数组的常用算法" class="headerlink" title="3.数组的常用算法"></a>3.数组的常用算法</h3><ol>
<li><p>遍历</p>
<ul>
<li><p>使用循环将数组的每个元素都访问一次</p>
</li>
<li><p>增强 for 循环：for…each</p>
<pre><code>  for(数组的类型 临时变量名 : 数组名)&#123;
      操作临时变量名;
  &#125;
</code></pre>
</li>
</ul>
</li>
<li><p>求最值</p>
</li>
<li><p>插入（在一个已经有序的数组中插入一个元素，仍然保持数组的有序性）</p>
</li>
<li><p>删除</p>
</li>
<li><p>查找</p>
<ul>
<li>顺序查找</li>
<li>二分查找</li>
</ul>
</li>
<li><p>排序</p>
<table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_48636891/article/details/127904093">八大排序算法</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/RQx3FRZWRTG">数据结构与算法分析 Java语言描述（原书第3版）</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/ELCQpupH2PB">附录：排序算法</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/iRQAJPdv8WG">Java数组3</a></td>
</tr>
</tbody></table>
</li>
</ol>
<h3 id="4-Java-多维数组"><a href="#4-Java-多维数组" class="headerlink" title="4.Java 多维数组"></a>4.Java 多维数组</h3><ol>
<li><p>二维数组</p>
<ul>
<li>了解二维数组的使用场景<ul>
<li>游戏中的地图</li>
<li>数学计算（矩阵）</li>
</ul>
</li>
<li>掌握二维数组的定义</li>
<li>掌握二维数组的遍历</li>
<li>常见的算法<ul>
<li>杨辉三角</li>
<li>鞍点</li>
</ul>
</li>
</ul>
</li>
<li><p>二维数组的定义</p>
<pre><code> int[][] arr=new int[5][6]; 
 
 第一个中括号表示的是行
 第二个中括号表示的是列
 
 数组的默认值：0
</code></pre>
<p> 静态定义二维数组</p>
<pre><code> int[][] arr=new int[][]&#123;
                 &#123;1&#125;,
                 &#123;1,2&#125;,
                 &#123;1,2,3&#125;,
                 &#123;1,2,3,4&#125;,
                 &#123;1,2,3,4,5&#125;
 &#125;;

 int[][] arr=new int[5][];
 System.out.println(arr.length);	// 5
 
 // 这种定义是非法的
 int[][] arr=new int[][5];
 System.out.println(arr.length);	// 前面编译错误
 
</code></pre>
<p> <img src="https://img-blog.csdnimg.cn/943e59acb8014f01a68185795a36faa1.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<h2 id="五-Java-面向对象"><a href="#五-Java-面向对象" class="headerlink" title="五 Java 面向对象"></a>五 Java 面向对象</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/fo6NnDUHP2L">oop.doc</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/dzJ4uaJtWMX">类和对象.ppt</a></td>
</tr>
</tbody></table>
<h3 id="1-Java-面向对象基础"><a href="#1-Java-面向对象基础" class="headerlink" title="1.Java 面向对象基础"></a>1.Java 面向对象基础</h3><ol>
<li>面向对象编程思想<br>  编程思维<ul>
<li><p>面向过程编程</p>
<ol>
<li>解决一个问题：将一个大问题分解为若干的小的问题</li>
<li>编程解决一个问题：将一个大问题分解为若干的小的问题，把每个小问题写成一个个的函数<br> <img src="https://img-blog.csdnimg.cn/a478376545314c6bb12828140b9976ad.png" alt="在这里插入图片描述"></li>
</ol>
</li>
<li><p>面向对象编程</p>
<ol>
<li>只需要修改应当修改的地方（可维护性）</li>
<li>可扩展性（代码可以随时的扩展新的功能）</li>
<li>可移植性</li>
<li>灵活性好</li>
</ol>
</li>
<li><p>现代软件的特点就是需求是随时变化的（回答为什么需要面向对象编程时可以往这里靠）</p>
</li>
<li><p>oop( object oriented program )中：开闭原则（ OCP ）（对于扩展开放，对于修改关闭）</p>
</li>
</ul>
</li>
<li>类<ol>
<li>面向对象编程的基本步骤：<ul>
<li>找对象</li>
<li>确定对象的属性</li>
<li>确定对象的行为</li>
<li>确定对象之间如何交互</li>
</ul>
</li>
<li>具有相同属性和行为的一类对象组成了一个类别，一个类</li>
<li>类就是一个模具</li>
<li>类：就是一种自定义的数据类型</li>
<li>类的组成部分<ul>
<li>属性</li>
<li>方法（行为）</li>
</ul>
</li>
</ol>
</li>
<li>对象<br> 对象的内存分析图<br> <img src="https://img-blog.csdnimg.cn/d6670e89a9f546e0819253bcc240644f.png" alt="在这里插入图片描述"><br>对象：类的具体化</li>
</ol>
<h3 id="2-面向对象编程"><a href="#2-面向对象编程" class="headerlink" title="2.面向对象编程"></a>2.面向对象编程</h3><ol>
<li><p>构造函数（方法）（重点）Constructor</p>
<ol>
<li>什么是构造方法<br> 构造方法是没有返回类型的方法，方法名与类名相同</li>
<li>有什么用<br> 构造方法不能被主动调用，只能被动的调用<br> 构造方法是 new 对象() 的时候自动调用的<br> 适合于做一些对象的初始化工作</li>
<li>如何编写<br> 构造方法如果你没有编写，那么编译器会为类自动加上一个默认的构造方法（没有参数的）<br> new 类名()<br> 当你编写了一个构造方法以后，那个默认的就没有了</li>
<li>在哪里会使用<br> 当为一个类写多个构造方法的时候，就形成了重载（ overload ）</li>
</ol>
</li>
<li><p>引用类型</p>
<pre><code> 基本的数据类型：都是在栈中分配的内存
 int a;
 double b;

 对象类型：在堆中会分配一个空间，然后用栈中的变量去指向
 所有的对象类型都是引用类型
 Student st=new Student();
</code></pre>
</li>
<li><p>方法的重载（ overload ）</p>
</li>
<li><p>对象数组</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将多个对象放入到数组中，目的是为了方便操作（遍历，搜索，排序，查找）</span></span><br><span class="line">Student[] arr=<span class="keyword">new</span> <span class="title class_">Student</span>[<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p> 数组中存放的是对象的地址，不是整个对象<br><img src="https://img-blog.csdnimg.cn/9611159a8ca344c49365bc4bb8b6daef.png" alt="在这里插入图片描述"></p>
</li>
<li><p>注意点</p>
<ul>
<li>“this(形参列表)” 必须声明在类的构造器的首行</li>
<li>在类的一个构造器中，最多只能声明一个 “this(形参列表)”</li>
<li>构造器中不能通过”this(形参列表)”的方式调用自己</li>
<li>如果一个类中声明了n个构造器，则最多有 n-1 个构造器中使用了 “this(形参列表)”</li>
<li>如果子类和父类中出现了同名的属性，那么我们如果在子类中调用父类中同名的属性的话，必须使用 “super.” 的方式；说明：子类的属性不会覆盖父类中同名属性。在堆空间中，两个属性都会存在</li>
<li>在子类的构造器的首行，显示的使用“super(形参列表)”的方式，调用父类指定的构造器</li>
<li>在子类的构造器的首行，要么使用 “this(形参列表)” ,要么使用 “super(形参列表)”，不能同时出现</li>
<li>在子类构造器的首行，既没显式的使用 “this(形参列表)”，也没显式的使用 “super(形参列表)”，那么默认提供的是：“super()”</li>
<li>在子类的多个构造器中，至少一个构造器的首行使用了 “super(形参列表)”</li>
</ul>
</li>
</ol>
<h3 id="3-面向对象之重载与封装"><a href="#3-面向对象之重载与封装" class="headerlink" title="3.面向对象之重载与封装"></a>3.面向对象之重载与封装</h3><ol>
<li><p>重载 overload<br> 在类中定义方法的时候，需要定义多个同名的方法，参数不同<br> 参数不同：</p>
<ol>
<li><p>参数的类型不同</p>
</li>
<li><p>参数的顺序不同</p>
</li>
<li><p>参数的个数不同</p>
<pre><code> 当我们编写代码的时候，发现很多方法功能类似但是参数不一致，这时候就可以使用重载了
 
 重载：实现了一种多态的效果（是一种静态的多态）
 
 注意：返回类型不构成重载的必要条件（下面两个构成重载）
     public void cook(Chicken chicken)&#123;
         
     &#125;
     public int cook(Water water)&#123;
     
     &#125;
</code></pre>
</li>
</ol>
</li>
<li><p>封装<br> 面向对象编程有三个重要的特征：</p>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<p> 封装：将一些属性，行为包在一个类中，形成了一种封装</p>
<pre><code> class Temp&#123;
     属性
     
     构造方法
     
     方法
 &#125;
 
 public void sendEmail(Message message)&#123;
 
 &#125;
 Message&#123;
     发送者，接收者，消息标题，消息的正文，发送时间，发送的 ip 地址
 &#125;
</code></pre>
<p> 封装的第二个层次：封装可以实现消息的隐藏和保护</p>
<ul>
<li>修饰符<ul>
<li>private<br>  修饰我们的成员以后，只有类自身可以访问，别的类是不能访问私有成员的，从而实现了消息的隐藏<br>  然后提供一个公有的 setter 方法，用于对这个私有的成员赋值，从而达到保护的效果</li>
<li>public<br>  方法公有</li>
</ul>
</li>
</ul>
</li>
<li><p>属性默认值<br> 类产生对象的时候，类中的那些属性是有默认值的<br><img src="https://img-blog.csdnimg.cn/7de8d8bafbcc43a9ba88161d9cb72452.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/ec7c189fc8ff415981635cc6dd48cda1.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>初始值</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>0</td>
</tr>
<tr>
<td>short</td>
<td>0</td>
</tr>
<tr>
<td>int</td>
<td>0</td>
</tr>
<tr>
<td>long</td>
<td>0L</td>
</tr>
<tr>
<td>float</td>
<td>0.0F</td>
</tr>
<tr>
<td>double</td>
<td>0.0D</td>
</tr>
<tr>
<td>boolean</td>
<td>false</td>
</tr>
<tr>
<td>char</td>
<td>‘’</td>
</tr>
<tr>
<td>String</td>
<td>null</td>
</tr>
</tbody></table>
<h3 id="4-面向对象之继承"><a href="#4-面向对象之继承" class="headerlink" title="4.面向对象之继承"></a>4.面向对象之继承</h3><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/7WWXRMdS1ie">Java面向对象之继承..pdf</a></td>
</tr>
</tbody></table>
<ol>
<li>注意点<ul>
<li>不管父类中的属性或方法的权限为何，子类都可以获取到，但是由于封装性的影响，可能在子类中不能直接调用父类中权限较小的属性或方法</li>
</ul>
</li>
</ol>
<h3 id="5-面向对象之多态"><a href="#5-面向对象之多态" class="headerlink" title="5.面向对象之多态"></a>5.面向对象之多态</h3><ol>
<li>重写（ override ）和多态<ul>
<li>重载：实现了静态的多态<br>  一个类中有多个同名方法</li>
<li>重写：<ul>
<li>必须有继承</li>
<li>子类将父类继承过来的方法重新编写</li>
<li>用父类变量指向子类的对象</li>
<li>父类变量调用方法的时候就是多态了</li>
</ul>
</li>
</ul>
</li>
<li>多态需要满足的3个条件<ol>
<li>有继承</li>
<li>有重写</li>
<li>父类变量指向子类的对象</li>
</ol>
</li>
<li>简单工厂设计模式<br> <img src="https://img-blog.csdnimg.cn/70c61ff405524ae89788ea6aeb38e6f3.png" alt="在这里插入图片描述"><ul>
<li>设计模式：遇到一些问题，前辈提供了一套比较好的解决方案，从而形成了一种固定的模式、套路（类似于棋谱）</li>
<li>GOF( gang of four )四人组：写了一本书，软件的可复用的一本书中介绍了这些模式，23种</li>
<li>简单工厂：解决了对象的创建问题，如果你的项目中遇到了同一类对象经常在改变的时候就可以使用<br>  解决对象的创建问题，当需要频繁的切换几种固定类型的对象的时候，需要用到简单工厂</li>
</ul>
</li>
<li>重写的注意点<ul>
<li>重写方法必须和被重写方法具有相同的方法名称、参数列表</li>
<li>重写方法使用的访问权限不能小于被重写方法的访问权限</li>
<li>重写的方法的返回值类型不能大于被重写的方法的返回值类型</li>
<li>父类方法的返回值类型是类型A,子类重写父类方法，返回值类型可以是类型A或类型A的子类.不能是类型A的父类</li>
<li>子类方法抛出的异常不能大于父类被重写方法的异常</li>
<li>子类与父类中同名同参数的方法必须同时声明为 static 的(不是重写)，或者同时声明为非 static 的（即为重写）</li>
</ul>
</li>
<li>多态的注意点<ul>
<li>由于子类的对象赋给了父类的引用，所以在编译时，只能调用父类声明的结构：属性和方法</li>
<li>在内存结构中存在子类特有的属性和方法，我们考虑向下转型才能调用子类特有的属性和方法</li>
</ul>
</li>
</ol>
<h2 id="六-Java面向对象高级"><a href="#六-Java面向对象高级" class="headerlink" title="六 Java面向对象高级"></a>六 Java面向对象高级</h2><table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/bWevVGFvEEU">Java 之23种设计模式解析.pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/bJJFYeB4bKn">大话设计模式(带目录完整版).pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/BgJLTw6s7uH">深入浅出设计模式(中文版).pdf</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/yeoGcPHGLBw">盛#男.exe</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/L7R6hD3DqXA">第6章_面向对象编程(下).pptx</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/XKnaKh9DEqf">阿里巴巴Java开发手册终极版v1.3.0.pdf</a></td>
</tr>
</tbody></table>
<h3 id="1-访问控制"><a href="#1-访问控制" class="headerlink" title="1.访问控制"></a>1.访问控制</h3><p>private、默认、protected、public</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类的内部</th>
<th>类的外部（同包）</th>
<th>包外子类</th>
<th>类的外部（不同包）</th>
</tr>
</thead>
<tbody><tr>
<td>private</td>
<td>√</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>default</td>
<td>√</td>
<td>√</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>protected</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>×</td>
</tr>
<tr>
<td>public</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
</tbody></table>
<ol>
<li>default 和 protected 的区别：<ul>
<li>包外子类：protected 可以访问，default 是不可以的</li>
</ul>
</li>
<li>最佳实践<ul>
<li>private 用于属性</li>
<li>public 用于方法</li>
</ul>
</li>
</ol>
<h3 id="2-static-关键字详解"><a href="#2-static-关键字详解" class="headerlink" title="2.static 关键字详解"></a>2.static 关键字详解</h3><ol>
<li>static 可以用于：<ol>
<li><p>方法（类方法）</p>
<pre><code> public static void show()&#123;&#125;

 当我们不需要使用对象来调用的时候就用静态方法

 一些工具类会使用静态方法，例如 Math 类中的所有方法都是静态的

 静态方法通过类名调用，不需要使用对象去调用

 static 的方法中没有 this，也没有 super

 static 的方法只能访问静态的成员


 public static void main(String[] args)&#123;

 &#125;
 为什么 main 需要写成静态的

 main 方法是由主线程来调用的，此刻并没有产生任何的 Java 对象，不通过对象调用方法就只能是静态的
 String[] args：表示是命令行参数，有程序启动的时候来传递
</code></pre>
<p> <img src="https://img-blog.csdnimg.cn/9451e515abd34eca90ad11fa430ed007.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/41cb60a2d335471fb3fc0f2863c3a83c.png" alt="在这里插入图片描述"><br>    2. 属性（类属性）</p>
<pre><code>        该属性是对这个类的所有对象共享的，只能通过类去访问，目的是为了多个对象共享同一个数据
    
        静态成员不需要对象可以访问（可以使用对象访问，. 的时候不会提示出来，
        但是可以使用 对象.属性 强行调用（静态方法同理），只不过会有警告）
    
        使用案例：
            1.在线人数
            2.统计总人数
3. 静态代码段（块）
    用于做一些类的初始化工作
    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">	<span class="comment">// Java 代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
4. 内部类
</code></pre>
<ol start="2">
<li>static 关键字的作用<br> 设计模式：<ul>
<li>简单工厂：simplefactory</li>
<li>单例模式：singleton<br>  描述：一个类有且只有一个对象，这个事情是类的设计者的责任，而不是使用者的责任（为了系统的性能需求，我们规定一个类只许有一个对象）</li>
</ul>
</li>
<li>单例模式完成步骤<ul>
<li>构造方法私有化</li>
<li>提供一个静态方法用于获取这个类的实例 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式（存在线程安全问题）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> Monitor instance;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">private</span> <span class="title function_">Monitor</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> Monitor <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">       	<span class="keyword">if</span>(instance==<span class="literal">null</span>) instance=<span class="keyword">new</span> <span class="title class_">Monitor</span>();</span><br><span class="line">       	<span class="keyword">return</span> instance;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Monitor</span> &#123;</span><br><span class="line">   	<span class="keyword">private</span> <span class="keyword">static</span> Monitor instance=<span class="keyword">new</span> <span class="title class_">Monitor</span>();</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">private</span> <span class="title function_">Monitor</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="keyword">public</span> <span class="keyword">static</span> Monitor <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">       	<span class="keyword">return</span> instance;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意点<ul>
<li>静态的方法只能调用静态的属性和方法；非静态的方法可以调用静态的方法和属性也可以调用非静态的方法和属性</li>
<li>实例变量：随着对象的创建而产生，分配在堆空间中</li>
<li>静态变量：随着类的加载而产生的，分配在方法区</li>
</ul>
</li>
</ol>
<h3 id="3-类的组成部分以及执行的顺序"><a href="#3-类的组成部分以及执行的顺序" class="headerlink" title="3.类的组成部分以及执行的顺序"></a>3.类的组成部分以及执行的顺序</h3><ol>
<li>类的组成部分：<ol>
<li>属性</li>
<li>方法</li>
<li>构造方法</li>
<li>静态属性（类属性）</li>
<li>静态方法（类方法）</li>
<li>代码块</li>
<li>静态代码块</li>
</ol>
</li>
<li>执行顺序<br> <img src="https://img-blog.csdnimg.cn/2ef82e7e712d4c789d0f2960e0349623.png" alt="在这里插入图片描述"><ul>
<li>第一梯队：静态属性 and 静态代码块</li>
<li>第二梯队：属性 and 代码块</li>
<li>第三梯队：构造方法</li>
</ul>
</li>
<li>继承后的执行先后顺序<ul>
<li>静态部分排名第一（父类子类一起加载，也存在先父类后子类）</li>
<li>代码块（父类）</li>
<li>构造器（父类）</li>
<li>代码块（子类）</li>
<li>构造器（子类）</li>
</ul>
</li>
<li>注意点<ul>
<li>在子类对象整个实例化过程中，只创建了唯一的一个对象，即为当前的子类对象</li>
</ul>
</li>
</ol>
<h3 id="4-final-关键字以及-Java-中的包-package"><a href="#4-final-关键字以及-Java-中的包-package" class="headerlink" title="4.final 关键字以及 Java 中的包 package"></a>4.final 关键字以及 Java 中的包 package</h3><ol>
<li>final 关键字<ul>
<li><p>修饰属性：最终属性，不能被修改，常量</p>
<pre><code>  常量是不能被修改的量，所以一般会定义为静态的
  命名一般为大写
  static final
</code></pre>
</li>
<li><p>修饰方法：最终方法，不能被重写的方法</p>
</li>
<li><p>修饰类：最终类，不可以被继承</p>
<pre><code>  final class A&#123;&#125;

  class B extends A&#123;&#125;	// 报错

  String,Math都是最终类
</code></pre>
</li>
</ul>
</li>
<li>Java 中的包 package<ul>
<li><p>package：作用就是为了整理代码</p>
</li>
<li><p>一个包就是一个文件夹<br>  com.xc.dao.User.java</p>
<pre><code>  com
          xc
              dao
</code></pre>
</li>
<li><p>打包</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.xc.dao;	<span class="comment">// 位于代码的第一行</span></span><br></pre></td></tr></table></figure></li>
<li><p>导入包：当你要使用的类和你不在一个包下的时候，就需要导入<br>  import 包名.类名;<br>  import 包名.*;</p>
<ul>
<li>idea 快捷键：Alt+Enter</li>
</ul>
</li>
<li><p>包的命名</p>
<pre><code>  公司域名的反写，小写字母
  
  www.chinaedu.com
  
  com.chinaedu.taobao.dao
</code></pre>
</li>
</ul>
</li>
<li>注意点<ul>
<li>使用 final 修饰属性，可以考虑的赋值的位置：①显示初始化 ②代码块中初始化 ③构造器中</li>
</ul>
</li>
</ol>
<h3 id="5-Java-抽象类"><a href="#5-Java-抽象类" class="headerlink" title="5.Java 抽象类"></a>5.Java 抽象类</h3><ol>
<li>阿里巴巴编码规范<br> 可以在 idea 中安装一个插件，检查命名是否规范<br><img src="https://img-blog.csdnimg.cn/e789179f1e1549bfbb2615de91f89a8e.png" alt="在这里插入图片描述"></li>
<li>抽象类<ol>
<li>抽象类：很抽象的类，例如现实中很多食物的总结</li>
<li>抽象类和普通类相比，区别在于抽象类不能 new ，类中可以包含抽象的方法 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>
 含有抽象方法的类就是抽象类（抽象类中不一定含有抽象方法，但是有抽象方法的类一定是抽象类）</li>
<li>抽象类的作用：<ul>
<li>定义了一个抽象方法，用于约束子类的行为</li>
<li>定义常规方法，为子类提供继承的方便，为了减少所有的子类都要去编写这个方法</li>
<li>抽象类一般用于和别的模块作为对接的桥梁（低耦合，松耦合）</li>
<li>子类和抽象类是一种 is-a 的关系（有继承关系）</li>
</ul>
</li>
</ol>
</li>
<li>模板方法的设计模式（ TemplateMethod ）<ul>
<li>当功能内部一部分是确定的，一部分实现是不确定的，这时可以 把不确定的部分暴露出去，让子类去实现</li>
<li>换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了，但是某些部分可以抽象出来，供不同子类实现，这就是一种模板模式  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TimeTemplate</span>&#123;</span><br><span class="line">	<span class="comment">// 防止子类修改</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="type">long</span> <span class="title function_">getTime</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">// 获取系统的当前时间</span></span><br><span class="line">		<span class="type">long</span> begin=System.currentTimeMillis();</span><br><span class="line">		code();</span><br><span class="line">		<span class="type">long</span> end=System.currentTimeMillis();</span><br><span class="line">		System.out.println(<span class="string">&quot;用时：&quot;</span>+(end-begin)+<span class="string">&quot;ms&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> end-begin;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意点<ul>
<li>前提：抽象性使用的前提是类的继承性</li>
<li>abstract 关键字不能用来修饰：属性、构造器，abstract 关键字不能与 final，private，static 共用</li>
<li>抽象方法没有方法体，所有此方法一定不能被调用</li>
<li>抽象类中也有构造器，但是，抽象类中的构造器不能实例化，是为了让子类继承时调用</li>
</ul>
</li>
</ol>
<h3 id="6-Java-接口"><a href="#6-Java-接口" class="headerlink" title="6.Java 接口"></a>6.Java 接口</h3><ol>
<li>什么叫接口<ul>
<li>USB接口，typec接口</li>
</ul>
</li>
<li>接口的定义 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> interface 接口名&#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">hide</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口就是一种能力的体现</li>
</ul>
</li>
<li>面向接口编程</li>
<li>抽象类和接口的区别<ul>
<li>接口是一种特殊的抽象类</li>
<li>接口体现的是一种能力（一个接口表示一种能力，抽象类体现的是事物的本质）</li>
<li>接口是可以多重实现的，一个类可以实现多个接口（表达的意思是具有多种的能力）</li>
</ul>
</li>
<li>访问修饰符的省略<ul>
<li>属性：省略 public static final<ul>
<li>public：使接口的实现类可以使用该常量</li>
<li>static：接口不涉及和任何具体实例相关的细节，因此接口没有构造方法，不能被实例化，没有实例变量，只有静态变量（ static 修饰就表示它属于类的，随着类的加载而存在的，当 JVM 把字节码加载进 JVM 的时候，static 修饰的成员已经在内存中存在了，如果是非 static 的话，就表示属于对象的，只有建立对象时才有它，而接口是不能建立对象的，所以接口的常量必须定义为 static ）</li>
<li>final：接口中不可以定义变量，即定义的变量前都要加上 final 修饰，使之成为常量，且必须赋初始值（ final 修饰就是保证接口定义的常量不能被实现类去修改，如果没有 final 的话，由子类随意去修改的话，接口建立这个常量就没有意义了）</li>
</ul>
</li>
<li>方法<ul>
<li>普通方法：省略 public abstract ，一般写为：void show();</li>
<li>默认方法：省略 public ，一般写为：default void show(){ &#x2F;&#x2F; 代码体 }</li>
<li>静态方法：省略 public ，一般写为：static void show(){ &#x2F;&#x2F; 代码体 }</li>
</ul>
</li>
<li>类：省略 abstract（ interface 本身都是抽象的，加不加都一样）</li>
</ul>
</li>
<li>注意点<ul>
<li>接口中只能定义常量和抽象方法—–&gt;JDK7.0及以前（JDK8.0接口中引入默认方法、静态方法）</li>
<li>接口中不能声明构造器，接口是不可以直接实例化的</li>
<li>如果类实现的接口和继承的父类中，定义了同名同参数的方法，那么子类在没重写此方法的情况下，默认调用的是父类中声明的方法。。—“类优先”原则</li>
<li>如果实现类实现了多个接口，接口中定义了同名同参数的方法。那么此时对于实现类来讲，会出现接口冲突问题—–&gt;要求实现类必须重写接口中的方法</li>
</ul>
</li>
</ol>
<h3 id="7-Java-内部类"><a href="#7-Java-内部类" class="headerlink" title="7.Java 内部类"></a>7.Java 内部类</h3><ol>
<li>内部类的作用<ul>
<li>没有内部类的情况下：重新写一个类来实现两个类的传参问题</li>
<li>有内部类的情况下：类中再写一个类，内部类可以访问外部类的属性，不需要特地传参</li>
</ul>
</li>
<li>内部类的分类<ul>
<li>普通内部类<br>  在一个类中编写一个类，里面的类称为内部类，外部的类称为外部类<br>  编译后的结果：<br>  <img src="https://img-blog.csdnimg.cn/aa2b707733dd44da8b9656a24d11f215.png" alt="在这里插入图片描述"><br>  内部类属性访问：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 *内部类</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	 <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">	 	<span class="type">int</span> i=<span class="number">20</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">			<span class="type">int</span> i=<span class="number">30</span>;</span><br><span class="line">			System.out.println(i);	<span class="comment">// 30</span></span><br><span class="line">			System.out.println(<span class="built_in">this</span>.i);	<span class="comment">// 20</span></span><br><span class="line">			<span class="comment">// 此 Outer 是外部类的类名</span></span><br><span class="line">			System.out.println(Outer.<span class="built_in">this</span>.i);	<span class="comment">// 10</span></span><br><span class="line">		&#125;</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  如何生成对象：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在别的类生成</span></span><br><span class="line"><span class="comment"> *其中main 方法中也需要这样，是因为 main 方法是静态的，</span></span><br><span class="line"><span class="comment"> *看不到非静态的内部类，如果内部类是静态的就可以看到</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">creatInner</span><span class="params">()</span>&#123;</span><br><span class="line">	Outer outer=<span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">	<span class="comment">// 创建里面的对象</span></span><br><span class="line">	Inner inner=outer.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">	<span class="comment">// 或者一步到位</span></span><br><span class="line">	Inner inner=<span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *在外部类的方法中生成</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">creatInner</span><span class="params">()</span>&#123;</span><br><span class="line"> 	Inner inner=<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>方法内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Outer</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 *方法中的内部类</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">			<span class="type">int</span> i=<span class="number">10</span>;</span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">				System.out.println(<span class="built_in">this</span>.i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		Inner inner=<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">		inner.show();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		Outer outer=<span class="keyword">new</span> <span class="title class_">Outer</span>();</span><br><span class="line">		outer.sayHello();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>匿名内部类  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">btn.addActionListener(<span class="keyword">new</span> <span class="title class_">ActionListener</span>()&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actionPerformed</span><span class="params">(ActionEvent e)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;点击&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>用在事件处理方面使用比较广泛</p>
<pre><code>  new 接口()&#123;
      接口的方法()&#123;
      
      &#125;
  &#125;
  
  本质上是在 new 一个类的对象，只是这个类是没有名字的
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>注意点<ul>
<li>内部类可以被 final ，abstract 关键字修饰</li>
</ul>
</li>
</ol>
<h3 id="8-Java-祖宗类-Object-类和单元测试"><a href="#8-Java-祖宗类-Object-类和单元测试" class="headerlink" title="8.Java 祖宗类 Object 类和单元测试"></a>8.Java 祖宗类 Object 类和单元测试</h3><ol>
<li><p>Object 类</p>
<ul>
<li>处于 java.lang 包下面</li>
<li>Object 类的方法：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span>&#123;</span><br><span class="line">	<span class="comment">// 判断是否相等</span></span><br><span class="line">	<span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span>	&#123; <span class="keyword">return</span> ( <span class="built_in">this</span> == obj); &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用于克隆对象</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用于输出的</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> getClass().getName()+<span class="string">&quot;@&quot;</span>+Integer.toHexString(hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 多线程以后才会使用的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> temeout,<span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">		<span class="comment">// 代码</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException&#123;</span><br><span class="line">		wait(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 用来在垃圾收集之前执行的代码</span></span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <img src="https://img-blog.csdnimg.cn/8219f1d5f5d944dcb35f03b9566ed264.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li><p>重点方法</p>
<ul>
<li><p>equals()</p>
<pre><code>  用来判断两个对象是否相等：
      基本数据类型的比较可以使用 == 来判断
      对象的比较使用 == 根本比较不出来，比较的结果永远是 false
  
  两个对象如果需要比较，用 equals 来比较
  如果我们依然使用祖宗的 equals 方法，那么得到的结论依然是错误的
  
  如果真的需要比较两个对象是否相等，我们需要将祖宗的方法进行重写
</code></pre>
</li>
<li><p>toString()</p>
<pre><code>  该方法用于描述一个对象
  
  System.out.println(student);
  打印一个对象的时候，调用这个对象的 toString() 方法
</code></pre>
</li>
<li><p>clone()</p>
<ul>
<li>浅克隆（浅拷贝）<ul>
<li>重写 clone() 方法</li>
<li>实现 Cloneable 接口（这是一个标记接口，没有任何的方法）</li>
</ul>
</li>
<li>深克隆（深拷贝）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException&#123;</span><br><span class="line">	<span class="comment">// 克隆第一级</span></span><br><span class="line">	Car car=(Car) <span class="built_in">super</span>.clone();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 克隆第二级</span></span><br><span class="line">	Girl girl=(Girl) car.girl.clone();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将新克隆的对象赋值</span></span><br><span class="line">	car.girl=gril;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> car;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>后面建立模块<br> <img src="https://img-blog.csdnimg.cn/275a89e98d174c2eb90938088c01dcda.png" alt="在这里插入图片描述"></p>
</li>
<li><p>单元测试</p>
<ul>
<li>junit：是一个三方组件</li>
</ul>
</li>
</ol>
<h2 id="七-异常处理"><a href="#七-异常处理" class="headerlink" title="七 异常处理"></a>七 异常处理</h2><h3 id="1-什么是异常"><a href="#1-什么是异常" class="headerlink" title="1.什么是异常"></a>1.什么是异常</h3><ul>
<li>程序运行过程中出现的错误，一些非正常情况导致程序出现的错误，称为异常，程序如果不处理异常，程序就非常的不健壮，很容易崩溃</li>
</ul>
<h3 id="2-异常为什么要处理"><a href="#2-异常为什么要处理" class="headerlink" title="2.异常为什么要处理"></a>2.异常为什么要处理</h3><ul>
<li>异常如果不处理，那么会导致程序终止</li>
<li>处理异常：是为了让程序更加健壮</li>
</ul>
<h3 id="3-异常的分类"><a href="#3-异常的分类" class="headerlink" title="3.异常的分类"></a>3.异常的分类</h3><ul>
<li>ArithmeticException：算数异常 &#x2F;by zero</li>
<li>ArrayIndexOutOfBoundsException：数组下标越界</li>
<li>NullPointerException：空指针异常</li>
<li>InputMismatchException：输入不匹配异常</li>
<li>OutOfMemoryError：超出了内存错误</li>
<li>…<br>  <img src="https://img-blog.csdnimg.cn/e5730f5950164cebaa593a206b464dd9.png" alt="在这里插入图片描述"></li>
</ul>
<table>
<thead>
<tr>
<th>异常</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Execption</td>
<td>异常层次结构的根类</td>
</tr>
<tr>
<td>RuntimeException</td>
<td>许多 java.lang 异常的基类</td>
</tr>
<tr>
<td>ArithmeticException</td>
<td>算数异常，如：除数为0</td>
</tr>
<tr>
<td>IllegalArgumentException</td>
<td>方法接收到非法参数</td>
</tr>
<tr>
<td>ArrayIndexOutOfBoundsException</td>
<td>数组下标越界</td>
</tr>
<tr>
<td>NullPointerException</td>
<td>访问空引用</td>
</tr>
<tr>
<td>ClassNotFoundException</td>
<td>不能加载所需的类</td>
</tr>
<tr>
<td>NumberFormatException</td>
<td>字符串转换数字失败</td>
</tr>
<tr>
<td>IOException</td>
<td>I&#x2F;O 异常的根类</td>
</tr>
<tr>
<td>FileNotFoundException</td>
<td>找不到文件</td>
</tr>
<tr>
<td>EOFException</td>
<td>文件结束</td>
</tr>
</tbody></table>
<h3 id="4-如何处理异常"><a href="#4-如何处理异常" class="headerlink" title="4.如何处理异常"></a>4.如何处理异常</h3><table>
<thead>
<tr>
<th>单词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>try</td>
<td>监视，考验，审问</td>
</tr>
<tr>
<td>catch</td>
<td>捕捉，捕获</td>
</tr>
<tr>
<td>finally</td>
<td>最后，终于，不可更改地</td>
</tr>
<tr>
<td>throw</td>
<td>抛出，扔</td>
</tr>
<tr>
<td>throws</td>
<td>抛出，扔</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 把可能发生异常的代码放在 try 部分，当发生异常以后，</span></span><br><span class="line"><span class="comment"> * 会触发 catch 部   分</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">try</span>&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;<span class="keyword">catch</span>(异常对象)&#123;</span><br><span class="line"> </span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 当 try 语句中如果发生多种类型的异常，我们在捕获的时候</span></span><br><span class="line"><span class="comment">  * 为了精准的显示错误信息，所以会出现多个 catch 部分</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * 放多个 catch 的时候不要将父类、高级别的异常类放在上面的位置</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;<span class="keyword">catch</span>&#123;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * finally：最终部分，不论前面发生了什么，finally 部分的</span></span><br><span class="line"><span class="comment">   * 代码都会执行（只要进入了 try，除非 System.exit(0)，</span></span><br><span class="line"><span class="comment">   * 否则都不能阻止 finally 的执行，不考虑 try 前被</span></span><br><span class="line"><span class="comment">   * return 了）</span></span><br><span class="line"><span class="comment">   * </span></span><br><span class="line"><span class="comment">   * 应用场景：</span></span><br><span class="line"><span class="comment">   * 		1.一般用于资源的释放</span></span><br><span class="line"><span class="comment">   * 		2.数据库的连接</span></span><br><span class="line"><span class="comment">   * 		3.文件的句柄</span></span><br><span class="line"><span class="comment">   * 		4.窗口的句柄</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">try</span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;<span class="keyword">catch</span>()&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-自定义异常"><a href="#5-自定义异常" class="headerlink" title="5.自定义异常"></a>5.自定义异常</h3><ol>
<li>throw：主动的抛出异常<ul>
<li>throw 异常对象：执行以后，后面的代码就不会执行了</li>
</ul>
</li>
<li>throws：声明某个方法可能会丢出异常<br> <img src="https://img-blog.csdnimg.cn/a720b2287e4f49ec9c2bd8376f8f80a8.png" alt="在这里插入图片描述"></li>
<li>检查异常和非检查异常的区别<ul>
<li>检查异常( checked exception )：必须捕获或者抛出的异常，这些异常都是继承自 Exception</li>
<li>非检查异常( unchecked exception )：运行时可以不用捕获或者抛出的异常，由虚拟机来负责抛出（运行时异常，一般继承自 RuntimeException）<br> <img src="https://img-blog.csdnimg.cn/f89fc9f6dbb54aa4bf373f540471a9dd.png" alt="在这里插入图片描述"></li>
</ul>
</li>
<li>自定义异常<ul>
<li>继承异常类，一般为：Exception ，RuntimeException</li>
<li>写构造方法，一般为带参数的构造方法  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyExecption</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2022/11/30/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2022/11/30/Java%20%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
