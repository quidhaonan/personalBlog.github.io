<!DOCTYPE HTML>
<html>

<head>
	<link rel="bookmark"  type="image/x-icon"  href="/img/logo_miccall.png"/>
	<link rel="shortcut icon" href="/img/logo_miccall.png">
	
			    <title>
    Liu Mingyang's personal blog
    </title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <link rel="stylesheet" href="/css/mic_main.css" />
    <link rel="stylesheet" href="/css/dropdownMenu.css" />
    <meta name="keywords" content="miccall" />
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css" />
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
<meta name="generator" content="Hexo 6.3.0"></head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css" />
<link rel="stylesheet" href="/css/typo.css" />
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">MICCALL</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special" >
            <ul class="menu links" >
			<!-- Homepage  主页  --> 
			<li >
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/about/" title="简历">
		                简历
		            </a>
		        </li>
		        
		        <li>
		            <a href="/group/" title="团队">
		                团队
		            </a>
		        </li>
		        
		        <li>
		            <a href="/gallery/" title="图库">
		                图库
		            </a>
		        </li>
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
                    <li>
                        <a title="github" href="https://github.com/miccall" target="_blank" rel="noopener">
                            <i class="icon fa fa-github"></i>
                        </a>
                    </li>
                    
                    <li>
                        <a title="500px" href="http://500px.com" target="_blank" rel="noopener">
                            <i class="icon fa fa-500px"></i>
                        </a>
                    </li>
                    
			</ul>
</nav>

        <div id="main" >
            <div class ="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;" >
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2 >八大排序算法</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="八大排序算法"><a href="#八大排序算法" class="headerlink" title="八大排序算法"></a><center>八大排序算法</center></h1><p>@[TOC]</p>
<table>
<thead>
<tr>
<th>资料</th>
</tr>
</thead>
<tbody><tr>
<td>来源：<a href="%E3%80%90%E3%80%90%E5%B0%9A%E7%A1%85%E8%B0%B7%E3%80%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%89%E3%80%91%20https://www.bilibili.com/video/BV1E4411H73v/?p=54&share_source=copy_web&vd_source=6e0b6c3885757906cee58baa8a4f1f60">【尚硅谷】数据结构与算法（Java数据结构与算法）</a></td>
</tr>
<tr>
<td>课件：<a target="_blank" rel="noopener" href="https://www.aliyundrive.com/s/Ue8FqtH7HUC">数据结构和算法.exe</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/topic/6439782051">图解排序</a></td>
</tr>
</tbody></table>
<h2 id="一-冒泡排序"><a href="#一-冒泡排序" class="headerlink" title="一 冒泡排序"></a>一 冒泡排序</h2><ol>
<li>基本介绍<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;冒泡排序（ bubble sorting ）</li>
<li>基本思想<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过对待排序序列从前向后（从下标较小的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;因为排序的过程中，各元素不断接近自己的位置，如果一趟比较下来没有进行过交换，就说明序列有序，因此要在排序过程中设置一个标志flag判断元素是否进行过交换。从而减少不必要的比较。（这里说的优化，可以在冒泡排序写好后，在进行）</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp=<span class="number">0</span>;	<span class="comment">// 临时变量</span></span><br><span class="line">	<span class="type">boolean</span> flag=<span class="literal">false</span>;	<span class="comment">// 表示变量，表示是否进行过交换</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-<span class="number">1</span>-i;j++)&#123;</span><br><span class="line">			<span class="comment">// 如果前面的数比后面的数大（逆序），则交换</span></span><br><span class="line">			<span class="keyword">if</span>(arr[j]&gt;arr[j+<span class="number">1</span>])&#123;</span><br><span class="line">				temp=arr[j];</span><br><span class="line">				arr[j]=arr[j+<span class="number">1</span>];</span><br><span class="line">				arr[j+<span class="number">1</span>]=temp;</span><br><span class="line">				flag=<span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 优化：如果在一趟排序中，一次交换都没有发生过，则退出循环</span></span><br><span class="line">		<span class="keyword">if</span>(!flag) <span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">// 重置 flag ，进行下次交换</span></span><br><span class="line">		flag=<span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li>时间复杂度为 O(n^2)</li>
<li>8 万个数据用时 16s &#x2F; 23s</li>
</ul>
</li>
<li>总结<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一个 for 循环实现第几趟大的排序，第二个 for 循环实现在一次大的排序中，进行几次比较。第一个 for 循环，如果有 5 个数，则进行 5-1&#x3D;4 次循环。第二个 for 循环可以将所有的数进行比较，但是比较浪费时间，因此比较次数可以根据比较的趟数依次递减</li>
</ol>
<h2 id="二-选择排序"><a href="#二-选择排序" class="headerlink" title="二 选择排序"></a>二 选择排序</h2><ol>
<li>基本介绍<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;选择排序（ select sorting ）也属于内部排序法，是从欲排序的数据中，按指定的规则选出某一元素，再依规定交换位置后达到排序的目的。</li>
<li>基本思想<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一次从 arr[0]<del>arr[n-1] 中选取最小值，与 arr[0] 交换，第二次从  arr[1]</del>arr[n-1] 中选取最小值，与 arr[1] 交换，第三次从 arr[2]<del>arr[n-1] 中选取最小值，与 arr[2] 交换，…，第 i 次从 arr[i-2]</del>arr[n-1] 中选取最小值，与 arr[i-1] 交换，…，第 n-1 次从 arr[n-2]~arr[n-1] 中选取最小值，与 arr[n-2] 交换，总共通过 n-1 次，得到一个按排序码从小到大排列的有序序列</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">selectSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> minIndex,temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">		minIndex=i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[minIndex]&gt;arr[j])&#123;	<span class="comment">// 说明假定的最小值，并不是最小</span></span><br><span class="line">				minIndex=j;	<span class="comment">// 重置 minIndex</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 将最小值与待交换位置的值进行交换</span></span><br><span class="line">		<span class="keyword">if</span>(minIndex!=i)&#123;	<span class="comment">// 如果假定待交换位置的值已经是最小的，就不需要交换</span></span><br><span class="line">			temp=arr[minIndex];</span><br><span class="line">			arr[minIndex]=arr[i];</span><br><span class="line">			arr[i]=temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li>时间复杂度为 O(n^2)</li>
<li>8 万个数据用时 2s &#x2F; 3s</li>
</ul>
</li>
<li>总结<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;第一个 for 循环假定为待插入的位置，同时假定它为当次循环中最小的值的下标，该 for 循环的次数为 arr.length-1 次。第二个 for 循环在待插入位置的后一位开始一直查找完整个数组，来更新最小值的下标，该 for 循环结束一轮后，将待插入位置与最小值下标的值进行交换</li>
</ol>
<h2 id="三-插入排序"><a href="#三-插入排序" class="headerlink" title="三 插入排序"></a>三 插入排序</h2><ol>
<li>基本介绍<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;插入排序（ insertion sorting）属于内部排序法，是对于欲排序的元素以插入的方式找寻该元素的适当位置，以达到排序的目的</li>
<li>基本思想<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;把 n 个待排序的元素看成为一个有序表和一个无序表，开始时有序表中只包含一个元素，无序表中包含有 n-1 个元素，排序过程中每次从无序表中取出第一个元素，把它的排序码依次与有序表元素的排列码进行比较，将它插入到有序表中的适当位置，使之成为新的有序表</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> insertVal,insertIndex;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="comment">// 保存待插入的数</span></span><br><span class="line">		insertVal=arr[i];</span><br><span class="line">		<span class="comment">// 保存待插入的下标</span></span><br><span class="line">		insertIndex=i-<span class="number">1</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		* 给 insertVal 找到插入的位置</span></span><br><span class="line"><span class="comment">		* 说明：</span></span><br><span class="line"><span class="comment">		* 	1.insertIndex&gt;=0 保证在给 insertVal 找插入位置，不越界</span></span><br><span class="line"><span class="comment">		* 	2.insertVal&lt;arr[insertIndex]，说明待插入的数，还没有找到插入位置</span></span><br><span class="line"><span class="comment">		* 	3.就需要将 arr[insertIndex] 后移</span></span><br><span class="line"><span class="comment">		*/</span></span><br><span class="line">		<span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertIndex])&#123;</span><br><span class="line">			arr[insertIndex+<span class="number">1</span>]=arr[insertIndex];</span><br><span class="line">			insertIndex--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 当退出 while 循环时，说明插入的位置找到，insertIndex+1</span></span><br><span class="line">		<span class="comment">// 这里判断是否需要赋值（也可以不用判断）</span></span><br><span class="line">		<span class="keyword">if</span>(insertIndex+<span class="number">1</span>!=i)&#123;</span><br><span class="line">			arr[insertIndex+<span class="number">1</span>]=insertVal;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li>8 万个数据用时 4s &#x2F; 5s</li>
</ul>
</li>
<li>总结<br>  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;该 for 循环代表无序表中的第一个数（ for 循环从数组下标 1 开始，一直循环完整个数组中的数据 ），从 1 开始是因为第 0 个位置刚开始就被当成有序表的数据。待插入位置为有序表最后一位，即 i-1 。当 insertIndex 下标的值不符和插入的条件时，就把当前 insertIndex 所指的值赋值给它所在的后一位下标上。<br>  &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;最后赋值需要 insertIndex+1 ，是因为此时 insertIndex 所指的值小于待插入的值（也可能是由于 insertIndex&gt;&#x3D;0 这个条件不满足，此时 insertIndex&#x3D;-1，代表此时待插入数据在有序表中最小，需要插入到 0 这个位置，此时 insertIndex+1&#x3D;0 ）,所以待插入的值需要插入到此时 insertIndex 所指的值的后面（此时 insertIndex+1 下标的值已经保存在 insertIndex+1+1 这个下标所在的位置了）</li>
</ol>
<h2 id="四-希尔排序"><a href="#四-希尔排序" class="headerlink" title="四 希尔排序"></a>四 希尔排序</h2><ol>
<li>基本介绍<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;希尔排序是希尔（ Donald Shell ）于 1959 年提出的一种排序算法。希尔排序也是一种 插入排序 ，提示简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序</li>
<li>基本思想<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;把记录按下标的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止</li>
</ol>
<h3 id="代码实现（交换法）"><a href="#代码实现（交换法）" class="headerlink" title="代码实现（交换法）"></a>代码实现（交换法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="comment">// 遍历各组中所有的元素（共 gap 组，每组有 arr.length/gap 个元素），步长为 gap</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=i-gap;j&gt;=<span class="number">0</span>;j-=gap)&#123;</span><br><span class="line">				<span class="comment">// 如果当前元素大于加上步长后的那个元素，说明交换</span></span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123;</span><br><span class="line">					temp=arr[j];</span><br><span class="line">					arr[j]=arr[j+gap];</span><br><span class="line">					arr[j+gap]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自己实现</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;arr.length-gap;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length-gap;j+=gap)&#123;</span><br><span class="line">				<span class="keyword">if</span>(arr[j]&gt;arr[j+gap])&#123;</span><br><span class="line">					temp=arr[j];</span><br><span class="line">					arr[j]=arr[j+gap];</span><br><span class="line">					arr[j+gap]=temp;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码实现（移位法）"><a href="#代码实现（移位法）" class="headerlink" title="代码实现（移位法）"></a>代码实现（移位法）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="comment">// 增量 gap，并逐步缩小增量</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="comment">// 从第 gap 个元素，逐个对其所在的组进行直接插入排序</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="type">int</span> insertIndex=i;</span><br><span class="line">			<span class="type">int</span> insertVal=arr[i];</span><br><span class="line">			<span class="keyword">if</span>(arr[insertIndex]&lt;arr[insertIndex-gap])&#123;</span><br><span class="line">				<span class="keyword">while</span>(insertIndex-gap&gt;=<span class="number">0</span> &amp;&amp; insertVal&lt;arr[insertIndex-gap])&#123;</span><br><span class="line">					<span class="comment">// 移动</span></span><br><span class="line">					arr[insertIndex]=arr[insertIndex-gap];</span><br><span class="line">					insertIndex-=gap;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 当退出 while 循环后，就给 insertVal 找到了插入的位置</span></span><br><span class="line">				arr[insertIndex]=insertVal;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 自己实现</span></span><br><span class="line"><span class="comment">* </span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> arr</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shellSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> gap=arr.length/<span class="number">2</span>;gap&gt;<span class="number">0</span>;gap/=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=gap;i&lt;arr.length;i++)&#123;</span><br><span class="line">			<span class="type">int</span> insertIndex=i-gap;</span><br><span class="line">			<span class="type">int</span> insertVal=arr[i];</span><br><span class="line">			<span class="comment">// 移位</span></span><br><span class="line">			<span class="keyword">while</span>(insertIndex&gt;=<span class="number">0</span> &amp;&amp; arr[insertIndex]&gt;insertVal)&#123;</span><br><span class="line">				arr[insertIndex+gap]=arr[insertIndex];</span><br><span class="line">				insertIndex-=gap;</span><br><span class="line">			&#125;</span><br><span class="line">			arr[insertIndex+gap]=insertVal;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li><pre><code>交换法
</code></pre>
<ul>
<li>8 万个数据用时 17s</li>
</ul>
</li>
<li>移位法<ul>
<li>8 万个数据用时 0s &#x2F; 1s</li>
<li>80 万个数据用时 1s</li>
<li>800 万个数据用时 4s</li>
</ul>
</li>
</ul>
</li>
<li>总结<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;根据步长分组，通过算法将每一组实现有序（交换法相当于冒泡排序，移位法相当于插入排序），实现有序后再缩小步长，当步长为 1 时，相当于整个数组了，此时再次进行排序后即为最终答案</li>
</ol>
<h2 id="五-快速排序"><a href="#五-快速排序" class="headerlink" title="五 快速排序"></a>五 快速排序</h2><ol>
<li>基本介绍<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;快速排序（ Quicksort ）是对冒泡排序的一种改进</li>
<li>基本思想<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列</li>
</ol>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">	<span class="type">int</span> l=left;	<span class="comment">// 左下标</span></span><br><span class="line">	<span class="type">int</span> r=right; <span class="comment">// 右下标</span></span><br><span class="line">	<span class="comment">// int mid=(left+right)/2;	// 中间下标	不能使用，会出现排序错误</span></span><br><span class="line">	<span class="comment">// pivot 中轴值</span></span><br><span class="line">	<span class="type">int</span> pivot=arr[(left+right)/<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> temp; <span class="comment">//临时变量，作为交换时使用</span></span><br><span class="line">	<span class="comment">// while 循环的目的是让比 pivot 值小的放到左边，比 pivot 值大的放到右边</span></span><br><span class="line">	<span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">		<span class="comment">// 在 pivot 的左边一直找，找到大于等于 pivot 值的数，才退出</span></span><br><span class="line">		<span class="keyword">while</span>(arr[l]&lt;pivot) l++;</span><br><span class="line">		<span class="comment">// 在 pivot 的右边一直找，找到小于等于 pivot 值的数，才退出</span></span><br><span class="line">		<span class="keyword">while</span>(arr[r]&gt;pivot) r--;</span><br><span class="line">		<span class="comment">// 如果 l&gt;=r 说明 pivot 左右两边边的值，已经按照左边全部是小于等于 pivot 值的数，</span></span><br><span class="line">		<span class="comment">// 右边全部是大于等于 pivot 值的数</span></span><br><span class="line">		<span class="keyword">if</span>(l&gt;=r) <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 交换</span></span><br><span class="line">		temp=arr[l];</span><br><span class="line">		arr[l]=arr[r];</span><br><span class="line">		arr[r]=temp;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 如果交换完后，发现这个 arr[l]==pivot 值 相等 r--，前移</span></span><br><span class="line">		<span class="keyword">if</span>(arr[l]==pivot) r--;</span><br><span class="line">		<span class="comment">// 如果交换完后，发现这个 arr[r]==pivot 值 相等 l++，后移</span></span><br><span class="line">		<span class="keyword">if</span>(arr[r]==pivot) l++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 如果 l==r ，必须 l++，r--，否则会出现栈溢出</span></span><br><span class="line">	<span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">		l++;</span><br><span class="line">		r--;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 向左递归</span></span><br><span class="line">	<span class="keyword">if</span>(left&lt;r)	quickSort(arr,left,r);</span><br><span class="line">	<span class="comment">// 向右递归</span></span><br><span class="line">	<span class="keyword">if</span>(right&gt;l)	quickSort(arr,l,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li>8 万个数据用时 0s &#x2F; 1s</li>
<li>80 万个数据用时 0s</li>
<li>800 万个数据用时 2s &#x2F; 4s</li>
</ul>
</li>
<li>总结</li>
</ol>
<h2 id="六-归并排序"><a href="#六-归并排序" class="headerlink" title="六 归并排序"></a>六 归并排序</h2><ol>
<li>基本介绍<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;归并排序（ MERGE-SORT ）是利用归并的思想实现的排序方法，该算法采用经典的分治（ divide-and-conquer ）策略（分治法将问题分（ divide ）成一些小的问题然后递归求解，而治（ conquer ）的阶段则将分的阶段得到的各答案“修补”在一起，即分而治之）</li>
<li>基本思想<br> <img src="https://img-blog.csdnimg.cn/d1b083fe58274dfebf5c388099ec22b8.png" alt="在这里插入图片描述"><br> <img src="https://img-blog.csdnimg.cn/1c3e4baf83d54c56aa707cd46e264007.png" alt="在这里插入图片描述"></li>
</ol>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分+和方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(left&lt;right)&#123;</span><br><span class="line">		<span class="type">int</span> mid=(left+right)/<span class="number">2</span>;	<span class="comment">// 中间索引</span></span><br><span class="line">		<span class="comment">// 向左递归进行分解</span></span><br><span class="line">		mergeSort(arr,left,mid,temp);</span><br><span class="line">		<span class="comment">// 向右递归进行分解</span></span><br><span class="line">		mergeSort(arr,mid+<span class="number">1</span>,right,temp);</span><br><span class="line">		<span class="comment">// 合并</span></span><br><span class="line">		merge(arr,left,mid,right,temp);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并的方法</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr   排序的原始数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left  左边有序序列的初始索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mid   中间索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right 右边索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> temp  做中转的数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left,<span class="type">int</span> mid,<span class="type">int</span> right,<span class="type">int</span>[] temp)</span>&#123;</span><br><span class="line">	<span class="type">int</span> i=left;	<span class="comment">//初始化 i ，左边有序序列的初始索引</span></span><br><span class="line">	<span class="type">int</span> j=mid+<span class="number">1</span>;	<span class="comment">// 初始化 j ，右边有序序列的初始索引</span></span><br><span class="line">	<span class="type">int</span> t=<span class="number">0</span>;	<span class="comment">// 指向 temp 数组的当前索引</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (一)</span></span><br><span class="line">	<span class="comment">// 先把左右两边（有序）的数据按照规则填充到 temp 数组</span></span><br><span class="line">	<span class="comment">// 直到左右两边的有序序列，有一边处理完毕为止</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid &amp;&amp; j&lt;=right)&#123;<span class="comment">// 继续</span></span><br><span class="line">		<span class="comment">// 如果左边的有序序列的当前元素，小于等于右边有序序列的当前元素</span></span><br><span class="line">		<span class="comment">// 即将左边的当前元素，填充到 temp 数组</span></span><br><span class="line">		<span class="comment">// 然后 t++,i++</span></span><br><span class="line">		<span class="keyword">if</span>(arr[i]&lt;=arr[j])&#123;</span><br><span class="line">			temp[t]=arr[i];</span><br><span class="line">			t++;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;<span class="comment">// 反之，将右边有序序列的当前元素，填充到 temp 数组</span></span><br><span class="line">			temp[t]=arr[j];</span><br><span class="line">			t++;</span><br><span class="line">			j++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (二)</span></span><br><span class="line">	<span class="comment">// 把有剩余数据的一边的数据依次全部填充到 temp</span></span><br><span class="line">	<span class="keyword">while</span>(i&lt;=mid)&#123;<span class="comment">// 左边的有序序列还有剩余的元素，就全部填充到 temp</span></span><br><span class="line">		temp[t]=arr[i];</span><br><span class="line">		t++;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(j&lt;=right)&#123;<span class="comment">// 右边的有序序列还有剩余的元素，就全部填充到 temp</span></span><br><span class="line">		temp[t]=arr[j];</span><br><span class="line">		t++;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// (三)</span></span><br><span class="line">	<span class="comment">// 将 temp 数组的元素拷贝到 arr</span></span><br><span class="line">	<span class="comment">// 注意：并不是每次都拷贝所有</span></span><br><span class="line">	<span class="comment">// 第一次合并：tempLeft=0,right=1，第二次合并：tempLeft=2,right=3</span></span><br><span class="line">	<span class="comment">// 第三次合并：tempLeft=0,right=3......</span></span><br><span class="line">	<span class="comment">// 最后一次合并：tempLeft=0,right=arr.length-1</span></span><br><span class="line">	t=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> tempLeft=left;</span><br><span class="line">	<span class="keyword">while</span>(tempLeft&lt;=right)&#123;</span><br><span class="line">		arr[tempLeft]=temp[t];</span><br><span class="line">		t++;</span><br><span class="line">		tempLeft++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li>8 万个数据用时 0s &#x2F; 1s</li>
<li>80 万个数据用时 1s</li>
<li>800 万个数据用时 3s &#x2F; 4s</li>
</ul>
</li>
<li>总结</li>
</ol>
<h2 id="七-基数排序"><a href="#七-基数排序" class="headerlink" title="七 基数排序"></a>七 基数排序</h2><ol>
<li>基本介绍<ul>
<li>基数排序（ radix sort ）属于“分配式排序”（ distributio sort ），又称“桶子法”（ bucket sort ）或 bin sort ，顾名思义，它是通过键值的各个位的值，将要排序的元素分配至某些“桶”中，达到排序的作用</li>
<li>基数排序法属于稳定性的排序，基数排序法是效率高的稳定性排序法</li>
<li>基数排序（ Radix Sort ）是桶排序的扩展</li>
<li>基数排序是 1887 年郝尔曼.何乐礼发明的。它是这样实现的：将整数按位数切割成不同的数字，然后按每个位数分别比较</li>
</ul>
</li>
<li>基本思想<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行依次排序，这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列</li>
</ol>
<h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="comment">// 得到数组中最大数的位数</span></span><br><span class="line">	<span class="type">int</span> max=arr[<span class="number">0</span>];	<span class="comment">// 假设第一数就是最大数</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(arr[i]&gt;max) max=arr[i];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得到最大数是几位数</span></span><br><span class="line">	<span class="type">int</span> maxLength=(max+<span class="string">&quot;&quot;</span>).length();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 定义一个二维数组，表示 10 个桶，每个桶就是一个一维数组</span></span><br><span class="line">	<span class="comment">// 说明</span></span><br><span class="line">	<span class="comment">// 1.二维数组包含 10 个一维数组</span></span><br><span class="line">	<span class="comment">// 2.为了防止在放入数的时候，数据溢出，则每个一维数组（桶），大小定为 arr.length</span></span><br><span class="line">	<span class="comment">// 3.很明确，基数排序是使用空间换时间的经典算法</span></span><br><span class="line">	<span class="type">int</span>[][] bucket=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>][arr.length];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 为了记录每个桶中，实际存放了多少个数据，我们定义一个一维数组来记录各个桶的每次放入</span></span><br><span class="line">	<span class="comment">// 的数据个数，可以这样理解</span></span><br><span class="line">	<span class="comment">// 比如：bucketElementCounts[0] 记录的就是 bucket[0] 桶的放入数据个数</span></span><br><span class="line">	<span class="type">int</span>[] bucketElementCounts=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 这里我们使用循环将代码处理，依次处理各个数的个位、十位、百位......</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,n=<span class="number">1</span>;i&lt;maxLength;i++,n*=<span class="number">10</span>)&#123;</span><br><span class="line">		<span class="comment">// 针对每个元素的对应位进行排序处理，第一次是个位，第二次是十位，第三次是百位...</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;arr.length;j++)&#123;</span><br><span class="line">			<span class="comment">// 取出每个元素的对应位的值</span></span><br><span class="line">			<span class="type">int</span> digitOfElement=arr[j]/n % <span class="number">10</span>;</span><br><span class="line">			<span class="comment">// 放入到对应的桶中</span></span><br><span class="line">			bucket[digitOfElement][bucketElementCounts[digitOfElement]]=arr[j];</span><br><span class="line">			bucketElementCounts[digitOfElement]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 按照这个桶的顺序（一维数组的下标依次取出数据，放入原来数组）</span></span><br><span class="line">		<span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 遍历每一个桶，并将桶中的数据，放入到原数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;bucketElementCounts.length;k++)&#123;</span><br><span class="line">			<span class="comment">// 如果桶中，有数据，我们才放入到原数组</span></span><br><span class="line">			<span class="keyword">if</span>(bucketElementCounts[k]!=<span class="number">0</span>)&#123;</span><br><span class="line">				<span class="comment">// 循环该桶即第 k 个桶（即第 k 个一维数组），放入</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">0</span>;l&lt;bucketElementCounts[k];l++)&#123;</span><br><span class="line">					<span class="comment">// 取出元素放入到 arr</span></span><br><span class="line">					arr[index++]=bucket[k][l];</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 处理完后，需要将每个 bucketElementCounts[k]=0!!!!!!</span></span><br><span class="line">			bucketElementCounts[k]=<span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li>8 万个数据用时 0s &#x2F; 1s</li>
<li>80 万个数据用时 0s</li>
<li>800 万个数据用时 1s</li>
<li>8000 万个数据报错 OutOfMemoryError</li>
</ul>
</li>
<li>总结<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;根据各个数据指定位数的大小将各个数据放入到合适的桶中，全部放完后，从第 0 个桶开始依次取出数据到原数组，当一个桶中有多个数据时，根据先放入先取出的原则来进行转移<br> &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;整个大的循环次数是根据数组中最大值的位数来确定的</li>
<li>补充<ul>
<li>基数排序是对传统桶排序的扩展，速度很快</li>
<li>基数排序是经典的空间换时间的方式，占用内存很大，当对海量数据排序时，容易造成 OutOfMemoryError</li>
<li>技术排序是稳定的	[注：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变，即在原序列中，r[i]&#x3D;r[j]，且 r[i] 在 r[j] 之前，而在排序后的序列中，r[i] 仍在 r[j] 之前，则称这种排序算法是稳定的，否则称为不稳定的]</li>
<li>有负数的数组，我们不用基数排序来进行排序，如果要支持负数，参考：<a target="_blank" rel="noopener" href="https://code.i-harness.com/zh-CN/q/e98fa9">链接</a></li>
</ul>
</li>
</ol>
<h2 id="八-堆排序"><a href="#八-堆排序" class="headerlink" title="八 堆排序"></a>八 堆排序</h2><ol>
<li>基本介绍<ul>
<li>堆排序是利用堆这种数据结构而设计的一种排序算法，堆排序是一种选择排序，它的最坏、最好、平均时间复杂度均为 O(nlogn)，它也是不稳定排序</li>
<li>堆是具有以下性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，注意：没有要求结点的左孩子的值和右孩子的值的大小关系</li>
<li>每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆</li>
<li>大顶堆举例说明：<br>  <img src="https://img-blog.csdnimg.cn/be1ef1ee85d64b36b56eef95aa4be996.png" alt="在这里插入图片描述"></li>
<li>小顶堆举例说明：<br>  <img src="https://img-blog.csdnimg.cn/ca246da9a614489bb16737c30e9bd4db.png" alt="在这里插入图片描述"></li>
<li>一般升序采用大顶堆，降序采用小顶堆</li>
</ul>
</li>
<li>基本思想<ul>
<li>将待排序序列构造成一个大顶堆</li>
<li>此时，整个序列的最大值就是堆顶的根结点</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值</li>
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次大值。如此反复执行，便能得到一个有序序列了<br> 可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了</li>
</ul>
</li>
</ol>
<h3 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">	<span class="type">int</span> temp;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=arr.length/<span class="number">2</span>-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		adjustHeap(arr,i,arr.length);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 1.将堆顶元素与末尾元素交换，将最大元素“沉”到数组末端</span></span><br><span class="line">	<span class="comment">// 2.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=arr.length-<span class="number">1</span>;i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="comment">// 交换</span></span><br><span class="line">		temp=arr[i];</span><br><span class="line">		arr[i]=arr[<span class="number">0</span>];</span><br><span class="line">		arr[<span class="number">0</span>]=temp;</span><br><span class="line">		adjustHeap(arr,<span class="number">0</span>,i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 讲一个数组（二叉树），调整成一个大顶堆</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 功能：完成将以 i 对应的非叶子结点的树调整成大顶堆</span></span><br><span class="line"><span class="comment"> * 举例：int[] arr=&#123;4,6,8,5,9&#125; =&gt; i=1 =&gt; adjustHeap =&gt; 得到&#123;4,9,8,5,6&#125;</span></span><br><span class="line"><span class="comment"> * 		如果我们再次调用 adjustHeap 传入的是 i=0 =&gt; 得到&#123;9,6,8,5,4&#125;</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> arr	待调整的数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i		表示非叶子结点在数组中索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> length 表示对多少个元素继续调整，length 是在逐渐的减少</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">adjustHeap</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> i,<span class="type">int</span> length)</span>&#123;</span><br><span class="line"> 	<span class="type">int</span> temp=arr[i]; <span class="comment">// 先取出当前元素的值，保存在临时变量</span></span><br><span class="line"> 	<span class="comment">// 开始调整</span></span><br><span class="line"> 	<span class="comment">// 说明：k=i*2+1，k是 i 结点的左子结点</span></span><br><span class="line"> 	<span class="keyword">for</span>(<span class="type">int</span> k=i*<span class="number">2</span>+<span class="number">1</span>;k&lt;length;k=k*<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"> 		<span class="keyword">if</span>(k+<span class="number">1</span>&lt;length &amp;&amp; arr[k]&lt;arr[k+<span class="number">1</span>])&#123;<span class="comment">// 说明左子结点的值小于右子结点的值</span></span><br><span class="line"> 			k++; <span class="comment">// k指向右子结点</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 		<span class="keyword">if</span>(arr[k]&gt;temp)&#123;<span class="comment">// 如果子结点大于父结点</span></span><br><span class="line"> 			arr[i]=arr[k]; <span class="comment">// 把较大的值赋给当前结点</span></span><br><span class="line"> 			i=k; <span class="comment">// i 指向 k ，继续进行循环比较 !!!</span></span><br><span class="line"> 		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> 			<span class="keyword">break</span>; <span class="comment">// !!!</span></span><br><span class="line"> 		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 当 for 循环结束后，我们已经将以 i 为父结点的树的最大值，放在了最顶部（局部）</span></span><br><span class="line"> 	arr[i]=temp; <span class="comment">// 将 temp 值放到调整后的位置</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>性能<ul>
<li>8 万个数据用时 0s &#x2F; 1s</li>
<li>80 万个数据用时 0s</li>
<li>800 万个数据用时 4s &#x2F; 5s</li>
</ul>
</li>
<li>总结</li>
</ol>
<h2 id="九-常用排序算法对比"><a href="#九-常用排序算法对比" class="headerlink" title="九 常用排序算法对比"></a>九 常用排序算法对比</h2><table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n²)</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(1)</td>
<td>In-place</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(n log n)</td>
<td>O(n log² n)</td>
<td>O(n log² n)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
<td>In-place</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n²)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody></table>
<p>相关术语解释：</p>
<ol>
<li>稳定：如果 a 原本在 b 前面，而 a&#x3D;b，排序之后 a 仍然在 b 的前面</li>
<li>不稳定：如果 a 原本在 b 的前面，而 a&#x3D;b，排序之后 a 可能会出现在 b 的后面</li>
<li>内排序：所有排序操作都在内存中完成</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行</li>
<li>时间复杂度：一个算法执行所耗费的时间</li>
<li>空间复杂度：运行完一个程序所需内存的大小</li>
<li>n：数据规模</li>
<li>k：“桶”的个数</li>
<li>In-place：不占用额外内存</li>
<li>Out-place：占用额外内存</li>
</ol>

            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'http-miccall-tech'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://example.com/2022/11/30/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://example.com/2022/11/30/%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//http-miccall-tech.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a target="_blank" rel="noopener" href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a target="_blank" rel="noopener" href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
